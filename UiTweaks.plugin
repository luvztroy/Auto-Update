import traceback
import re
import urllib.parse
import os
import json
import urllib.request
import base64
import weakref
import threading
import time


from typing import Set, Any, Optional, List, Dict
from base_plugin import BasePlugin, MenuItemData, MenuItemType, HookResult, HookStrategy, MethodReplacement, AppEvent, MethodHook
from hook_utils import find_class, get_private_field, set_private_field
from java import dynamic_proxy, jclass, jlong

from ui.settings import Header, Switch, Divider, Selector, Text, EditText
from ui.bulletin import BulletinHelper
from ui.alert import AlertDialogBuilder

from client_utils import get_last_fragment, get_send_messages_helper, get_messages_storage, run_on_queue, PLUGINS_QUEUE, get_messages_controller, get_account_instance
from android_utils import run_on_ui_thread, log, OnLongClickListener, OnClickListener
from com.exteragram.messenger.plugins.ui.components.templates import UniversalFragment

from android.view import View, ViewGroup, Gravity, HapticFeedbackConstants
from android.widget import FrameLayout, TextView, ImageView, LinearLayout, HorizontalScrollView
from android.graphics import Canvas, Path, Rect, Typeface
from android.graphics.drawable import Drawable, GradientDrawable
from android.text import SpannableStringBuilder, TextUtils, Spanned
from android.text.style import ForegroundColorSpan, TypefaceSpan, CharacterStyle
from android.text import InputType
from android.util import TypedValue
from android.os import Bundle, Handler, Looper
from android.content import Context, ClipData, ClipboardManager
from android.os import Vibrator
from java.util import ArrayList
import threading
from com.exteragram.messenger.plugins import PluginsController
from com.exteragram.messenger.plugins.ui import PluginsActivity, PluginSettingsActivity

from org.telegram.messenger import R as R_tg
from org.telegram.messenger import MessagesController, UserConfig, ApplicationLoader, LocaleController, AndroidUtilities, MessagesStorage
from org.telegram.messenger import UserObject, ChatObject, ImageLocation, MessageObject, DialogObject, NotificationCenter, BotWebViewVibrationEffect, SendMessagesHelper, CodeHighlighting, AccountInstance
from org.telegram.ui.Components import EditTextBoldCursor, URLSpanUserMention
from org.telegram.tgnet import TLRPC
from org.telegram.ui.ActionBar import ActionBarPopupWindow, Theme, ActionBarMenuItem
from org.telegram.ui.Components import AvatarDrawable, BackupImageView, LayoutHelper
from org.telegram.ui import ChatActivity, ProfileActivity, TopicsFragment, DialogsActivity, LaunchActivity
from org.telegram.ui.ActionBar import BaseFragment
from com.google.android.exoplayer2.util import Consumer

try:
    import quantahut
    if hasattr(quantahut, '__version__') and quantahut.__version__ < "1.4.8":
        raise Exception(f"QuantaHut {quantahut.__version__} is too old. Need 1.4.8+")
    from quantahut import showmultiselector, showupdatebottomsheet, export_plugin_settings
except ImportError:
    raise Exception("QuantaHut is required but not installed. Install it first. (Don't report this as a bug - it's your fault.)")

QuantaHut = quantahut

__id__ = "ui_tweaks"
__name__ = "UiTweaks"
__description__ = "Well sometimes you just need to tweak things... (requires QuantaHut)"
__version__ = "1.8.2"
__author__ = "@luvztroy"
__min_version__ = "12.1.1"
__icon__ = "luvztroyIcons/13"
__dependencies__ = ["quantahut"]


CUSTOM_CODE_ID = 99999
CUSTOM_MENTION_ID = 99998
DEBOUNCE_TIME = 0.5

def show_confirmation_selector():
    try:
        global uitweaks_plugin_instance
        if uitweaks_plugin_instance:
            uitweaks_plugin_instance._show_confirmation_selector()
    except Exception as e:
        pass

def get_string(key: str, default: str = None) -> str:
    try:
        selected_language = get_selected_language_preference()
        if selected_language:
            localized_text = quantahut.get_localized_string("UiTweaks", key, default or key)
            return localized_text
        else:
            current_language = LocaleController.getInstance().getCurrentLocaleInfo().getLangCode()
            if current_language == "en":
                return default or key
            localized_text = quantahut.get_localized_string("UiTweaks", key, default or key)
            return localized_text
    except Exception as e:
        return default or key

def get_selected_language_preference():
    try:
        from base_plugin import PluginsController
        from hook_utils import get_private_field
        prefs = get_private_field(PluginsController.getInstance(), "preferences")
        return prefs.getString("plugin_setting_ui_tweaks_selected_language", None)
    except Exception as e:
        return None

def set_selected_language_preference(lang_code):
    try:
        from base_plugin import PluginsController
        from hook_utils import get_private_field
        prefs = get_private_field(PluginsController.getInstance(), "preferences")
        prefs.edit().putString("plugin_setting_ui_tweaks_selected_language", lang_code).apply()
    except Exception as e:
        pass



TL_documentAttributeSticker = jclass('org.telegram.tgnet.TLRPC$TL_documentAttributeSticker')
TL_documentAttributeAudio = jclass('org.telegram.tgnet.TLRPC$TL_documentAttributeAudio')
TL_documentAttributeVideo = jclass('org.telegram.tgnet.TLRPC$TL_documentAttributeVideo')
TL_documentAttributeAnimated = jclass('org.telegram.tgnet.TLRPC$TL_documentAttributeAnimated')


class NonClickablePreviewDispatchTouchHook:
    def before_hooked_method(self, param):
        try:
            fragment_view = param.thisObject
            if not fragment_view:
                return
            
            chat_activity_field = fragment_view.getClass().getDeclaredField("this$0")
            chat_activity_field.setAccessible(True)
            chat_activity = chat_activity_field.get(fragment_view)
            if not chat_activity:
                return
            
            parent_layout_field = chat_activity.getClass().getSuperclass().getDeclaredField("parentLayout")
            parent_layout_field.setAccessible(True)
            parent_layout = parent_layout_field.get(chat_activity)
            if not parent_layout:
                return
            
            is_preview_method = parent_layout.getClass().getDeclaredMethod("isInPreviewMode")
            is_preview_method.setAccessible(True)
            in_preview_mode = is_preview_method.invoke(parent_layout)
            
            if in_preview_mode:
                try:
                    allow_field = chat_activity.getClass().getDeclaredField("allowExpandPreviewByClick")
                    allow_field.setAccessible(True)
                    allow_expand = allow_field.getBoolean(chat_activity)
                    
                    if allow_expand:
                        allow_field.setBoolean(chat_activity, False)
                except:
                    pass
        except:
            pass


class NonClickablePreviewPresentFragmentHook:
    def after_hooked_method(self, param):
        try:
            fragment = param.thisObject
            preview_fragment = param.args[0]
            preview_menu = param.args[1]
            
            if not preview_fragment or not preview_menu:
                return
                
            ChatActivity = jclass("org.telegram.ui.ChatActivity")
            if not isinstance(preview_fragment, ChatActivity):
                return
                
            try:
                allow_field = preview_fragment.getClass().getDeclaredField("allowExpandPreviewByClick")
                allow_field.setAccessible(True)
                allow_field.setBoolean(preview_fragment, False)
            except:
                pass

            try:
                chat_list_field = preview_fragment.getClass().getDeclaredField("chatListView")
                chat_list_field.setAccessible(True)
                chat_list_view = chat_list_field.get(preview_fragment)
                if chat_list_view is not None:
                    try:
                        chat_list_view.setOnItemClickListener(None)
                    except:
                        pass
                    try:
                        chat_list_view.setOnItemLongClickListener(None)
                    except:
                        pass
                    try:
                        chat_list_view.setClickable(False)
                    except:
                        pass
                    try:
                        chat_list_view.setLongClickable(False)
                    except:
                        pass
            except:
                pass

            dialog_id = preview_fragment.getDialogId()
            
            MessagesController = jclass("org.telegram.messenger.MessagesController")
            DialogObject = jclass("org.telegram.messenger.DialogObject")
            
            if DialogObject.isUserDialog(dialog_id):
                user = MessagesController.getInstance(fragment.currentAccount).getUser(dialog_id)
                if not user:
                    return
                self._add_open_profile_item(fragment, preview_menu, dialog_id)
                self._add_open_chat_item(fragment, preview_menu, dialog_id)
            else:
                chat_id_for_lookup = -dialog_id
                chat = MessagesController.getInstance(fragment.currentAccount).getChat(chat_id_for_lookup)
                if not chat:
                    return
                self._add_open_profile_item(fragment, preview_menu, dialog_id)
                self._add_open_chat_item(fragment, preview_menu, dialog_id)
        except:
            pass
    
    def _add_open_profile_item(self, fragment, preview_menu, dialog_id):
        try:
            ActionBarMenuSubItem = jclass("org.telegram.ui.ActionBar.ActionBarMenuSubItem")
            ProfileActivity = jclass("org.telegram.ui.ProfileActivity")
            DialogObject = jclass("org.telegram.messenger.DialogObject")
            R = jclass("org.telegram.messenger.R")
            
            item_text = get_string("open_profile", "Open Profile")
            item_icon = R.drawable.msg_openprofile
            
            open_profile_item = ActionBarMenuSubItem(fragment.getParentActivity(), False, False)
            open_profile_item.setTextAndIcon(item_text, item_icon)
            open_profile_item.setMinimumWidth(160)
            
            click_listener = OnClickListener(lambda *args: self._open_profile(fragment, dialog_id))
            open_profile_item.setOnClickListener(click_listener)
            
            preview_menu.addView(open_profile_item)
        except:
            pass
    
    def _add_open_chat_item(self, fragment, preview_menu, dialog_id):
        try:
            ActionBarMenuSubItem = jclass("org.telegram.ui.ActionBar.ActionBarMenuSubItem")
            R = jclass("org.telegram.messenger.R")
            
            item_text = get_string("open_chat", "Open Chat")
            item_icon = R.drawable.msg_msgbubble3
            
            open_chat_item = ActionBarMenuSubItem(fragment.getParentActivity(), False, False)
            open_chat_item.setTextAndIcon(item_text, item_icon)
            open_chat_item.setMinimumWidth(160)
            
            click_listener = OnClickListener(lambda *args: self._open_chat(fragment))
            open_chat_item.setOnClickListener(click_listener)
            
            preview_menu.addView(open_chat_item)
        except:
            pass
    
    def _open_chat(self, fragment):
        try:
            parent_layout = fragment.getParentLayout()
            if parent_layout:
                parent_layout.expandPreviewFragment()
        except:
            pass
    
    def _open_profile(self, fragment, dialog_id):
        try:
            fragment.finishPreviewFragment()
            
            Bundle = jclass("android.os.Bundle")
            args = Bundle()
            args.putBoolean("expandPhoto", False)
            
            DialogObject = jclass("org.telegram.messenger.DialogObject")
            if DialogObject.isUserDialog(dialog_id):
                args.putLong("user_id", dialog_id)
            else:
                chat_id_for_bundle = -dialog_id
                args.putLong("chat_id", chat_id_for_bundle)
            
            ProfileActivity = jclass("org.telegram.ui.ProfileActivity")
            present_fragment_method = fragment.getClass().getDeclaredMethod("presentFragment", jclass("org.telegram.ui.ActionBar.BaseFragment"))
            present_fragment_method.setAccessible(True)
            present_fragment_method.invoke(fragment, ProfileActivity(args))
        except:
            pass


class AddToFolderAllTabsHook:
    def __init__(self, plugin):
        self.plugin = plugin

    def after_hooked_method(self, param):
        try:
            dialogs_activity = param.thisObject
            
            add_to_folder_item_field = dialogs_activity.getClass().getDeclaredField("addToFolderItem")
            add_to_folder_item_field.setAccessible(True)
            add_to_folder_item = add_to_folder_item_field.get(dialogs_activity)
            
            if add_to_folder_item is None:
                return
            
            filter_tabs_view_field = dialogs_activity.getClass().getDeclaredField("filterTabsView")
            filter_tabs_view_field.setAccessible(True)
            filter_tabs_view = filter_tabs_view_field.get(dialogs_activity)
            
            folder_id_field = dialogs_activity.getClass().getDeclaredField("folderId")
            folder_id_field.setAccessible(True)
            folder_id = folder_id_field.getInt(dialogs_activity)
            
            selected_dialogs_field = dialogs_activity.getClass().getDeclaredField("selectedDialogs")
            selected_dialogs_field.setAccessible(True)
            selected_dialogs = selected_dialogs_field.get(dialogs_activity)
            
            FiltersListBottomSheetClass = find_class("org.telegram.ui.Components.FiltersListBottomSheet")
            if FiltersListBottomSheetClass:
                can_add_filters = FiltersListBottomSheetClass.getCanAddDialogFilters(dialogs_activity, selected_dialogs)
                has_available_folders = can_add_filters is not None and not can_add_filters.isEmpty()
            else:
                has_available_folders = False
            
            should_show = False
            
            if folder_id == 1:
                should_show = True
            elif (filter_tabs_view is not None and 
                  filter_tabs_view.getVisibility() == View.VISIBLE and 
                  has_available_folders):
                should_show = True
            
            if should_show:
                add_to_folder_item.setVisibility(View.VISIBLE)
            else:
                add_to_folder_item.setVisibility(View.GONE)
                
        except Exception:
            pass

class UnreadCountHook:
    def __init__(self, plugin_instance):
        self.plugin = plugin_instance
    
    def after_hooked_method(self, param):
        try:
            show_message_count = self.plugin.get_setting("unread_message_count", False)
            show_chat_count = self.plugin.get_setting("unread_chat_count", False)
            exclude_archived = self.plugin.get_setting("exclude_archived_from_count", False)
            process_counts = show_message_count or show_chat_count

            exclude_archived = self.plugin.get_setting("exclude_archived_from_count", False)
            process_counts = show_message_count or show_chat_count

            if not (process_counts or exclude_archived):
                return

            messages_storage = param.thisObject
            apply = param.args[0] if len(param.args) > 0 else False
            from org.telegram.messenger import UserConfig; current_account = UserConfig.selectedAccount
            from java import jclass; MessagesController = jclass("org.telegram.messenger.MessagesController"); messages_controller = MessagesController.getInstance(current_account)

            if process_counts:
                dialog_filters_field = messages_controller.getClass().getDeclaredField("dialogFilters"); dialog_filters_field.setAccessible(True); dialog_filters = dialog_filters_field.get(messages_controller)

                for i in range(dialog_filters.size()):
                    try:
                        filter_dialog = dialog_filters.get(i)

                        dialogs_field = filter_dialog.getClass().getDeclaredField("dialogs"); dialogs_field.setAccessible(True); dialogs = dialogs_field.get(filter_dialog)

                        if dialogs is None or dialogs.size() == 0:
                            continue

                        unread_count = 0; muted_excluded = 0; muted_with_mentions = 0; non_muted_counted = 0

                        for j in range(dialogs.size()):
                            dialog = dialogs.get(j)

                            dialog_unread_count = dialog.unread_count; dialog_unread_mentions = dialog.unread_mentions_count

                            if dialog_unread_count == 0 and dialog_unread_mentions == 0:
                                continue

                            if exclude_archived and hasattr(dialog, 'folder_id') and dialog.folder_id != 0:
                                continue

                            dialog_id = dialog.id; is_muted = messages_controller.isDialogMuted(dialog_id, 0)

                            if is_muted:
                                if show_message_count and not show_chat_count:
                                    unread_count += dialog_unread_count + dialog_unread_mentions
                                elif dialog_unread_mentions > 0 and show_chat_count and not show_message_count:
                                    unread_count += 1
                                muted_excluded += 1
                                continue

                            if show_message_count:
                                unread_count += dialog_unread_count
                            elif show_chat_count:
                                unread_count += 1
                            non_muted_counted += 1

                        filter_dialog.unreadCount = unread_count; filter_dialog.pendingUnreadCount = unread_count

                    except Exception:
                        continue

            if exclude_archived:
                try:
                    pending_archive_count_field = messages_storage.getClass().getDeclaredField("pendingArchiveUnreadCount")
                    pending_archive_count_field.setAccessible(True)
                    pending_archive_count_field.setInt(messages_storage, 0)

                    archive_count_field = messages_storage.getClass().getDeclaredField("archiveUnreadCount")
                    archive_count_field.setAccessible(True)
                    archive_count_field.setInt(messages_storage, 0)
                except Exception:
                    pass

                if not process_counts:
                    try:
                        from org.telegram.messenger import NotificationCenter
                        notification_center = NotificationCenter.getInstance(current_account)
                        notification_center.postNotificationName(NotificationCenter.dialogsUnreadCounterChanged, current_account)
                    except Exception:
                        pass

            if process_counts:
                main_unread_count_field = messages_storage.getClass().getDeclaredField("pendingMainUnreadCount")
                main_unread_count_field.setAccessible(True)
                previous_pending = main_unread_count_field.getInt(messages_storage)

                previous_main = None
                main_unread_count_apply_field = None
                if apply:
                    main_unread_count_apply_field = messages_storage.getClass().getDeclaredField("mainUnreadCount")
                    main_unread_count_apply_field.setAccessible(True)
                    previous_main = main_unread_count_apply_field.getInt(messages_storage)

                main_dialogs_method = messages_controller.getClass().getMethod("getAllDialogs")
                main_dialogs = main_dialogs_method.invoke(messages_controller)

                filtered_count = 0
                if main_dialogs is not None:
                    for k in range(main_dialogs.size()):
                        dialog = main_dialogs.get(k)
                        dialog_unread_count = dialog.unread_count
                        dialog_unread_mentions = dialog.unread_mentions_count

                        if dialog_unread_count == 0 and dialog_unread_mentions == 0:
                            continue

                        if exclude_archived and hasattr(dialog, 'folder_id') and dialog.folder_id != 0:
                            continue

                        dialog_id = dialog.id
                        is_muted = messages_controller.isDialogMuted(dialog_id, 0)

                        if is_muted:
                            if show_message_count and not show_chat_count:
                                filtered_count += dialog_unread_count + dialog_unread_mentions
                            elif dialog_unread_mentions > 0 and show_chat_count and not show_message_count:
                                filtered_count += 1
                            continue

                        if show_message_count:
                            filtered_count += dialog_unread_count
                        elif show_chat_count:
                            filtered_count += 1

                main_unread_count_field.setInt(messages_storage, filtered_count)

                if apply and main_unread_count_apply_field is not None:
                    main_unread_count_apply_field.setInt(messages_storage, filtered_count)

                should_notify = filtered_count != previous_pending or (apply and previous_main is not None and filtered_count != previous_main)

                if should_notify:
                    try:
                        from org.telegram.messenger import NotificationCenter
                        notification_center = NotificationCenter.getInstance(current_account)
                        notification_center.postNotificationName(NotificationCenter.dialogsUnreadCounterChanged, current_account)
                    except Exception:
                        pass
            
        except Exception:
            pass


class ContactStatusUpdateRowsIdsHook:
    def __init__(self, plugin):
        self.plugin = plugin

    def before_hooked_method(self, param):
        activity = param.thisObject
        state = self.plugin.contact_status_activity_state.setdefault(activity, {"mutualRow": -1})

        state["shouldInsertMutual"] = False

        user = self._get_profile_user(activity)
        if not user or not getattr(user, "mutual_contact", False):
            state["mutualRow"] = -1
            return

        state["shouldInsertMutual"] = True

    def after_hooked_method(self, param):
        activity = param.thisObject
        state = self.plugin.contact_status_activity_state.get(activity)
        if not state:
            return

        if not state.get("shouldInsertMutual"):
            state["mutualRow"] = -1
            state.pop("shouldInsertMutual", None)
            return

        insert_position = self._calculate_insert_position(activity)
        if insert_position == -1:
            state["mutualRow"] = -1
            state.pop("shouldInsertMutual", None)
            return

        state["mutualRow"] = insert_position
        state.pop("shouldInsertMutual", None)

        row_count = self._get_int_field(activity, "rowCount")
        if row_count != -1:
            self._set_int_field(activity, "rowCount", row_count + 1)

        try:
            activity_class = activity.getClass()
            fields = activity_class.getDeclaredFields()
            for i in range(len(fields)):
                field = fields[i]
                name = field.getName()
                if "Row" not in name and "row" not in name:
                    continue
                if name in ("rowCount", "phoneRow", "mutualRow"):
                    continue
                field_type = field.getType()
                INTEGER_CLASS = jclass("java.lang.Integer")
                if field_type != INTEGER_CLASS.TYPE and field_type != INTEGER_CLASS:
                    continue
                field.setAccessible(True)
                value_obj = field.get(activity)
                if value_obj is None:
                    continue
                try:
                    value = int(value_obj)
                except Exception:
                    continue
                if value >= state["mutualRow"] and value != -1:
                    try:
                        if field_type == INTEGER_CLASS.TYPE:
                            field.setInt(activity, value + 1)
                        else:
                            field.set(activity, INTEGER_CLASS(value + 1))
                    except Exception:
                        pass
        except Exception:
            pass

    def _get_profile_user(self, activity):
        try:
            user_id = self._get_long_field(activity, "userId")
            if user_id == 0:
                return None
            from org.telegram.messenger import MessagesController, UserConfig
            account = UserConfig.selectedAccount
            controller = MessagesController.getInstance(account)
            if not controller:
                return None
            try:
                user_id_int = int(user_id)
            except Exception:
                user_id_int = user_id
            user = controller.getUser(user_id_int)
            if user:
                return user
            user_full = self._get_object_field(activity, "userInfo")
            if user_full and getattr(user_full, "user", None):
                return user_full.user
        except Exception:
            return None

    def _get_int_field(self, obj, name):
        try:
            field = obj.getClass().getDeclaredField(name)
            field.setAccessible(True)
            return field.getInt(obj)
        except Exception:
            return -1

    def _set_int_field(self, obj, name, value):
        try:
            field = obj.getClass().getDeclaredField(name)
            field.setAccessible(True)
            field.setInt(obj, value)
        except Exception:
            pass

    def _get_long_field(self, obj, name):
        try:
            field = obj.getClass().getDeclaredField(name)
            field.setAccessible(True)
            return field.getLong(obj)
        except Exception:
            return 0

    def _get_object_field(self, obj, name):
        try:
            field = obj.getClass().getDeclaredField(name)
            field.setAccessible(True)
            return field.get(obj)
        except Exception:
            return None

    def _calculate_insert_position(self, activity):
        anchors = [
            "phoneRow",
            "infoHeaderRow",
            "infoHeaderRowEmpty",
            "userInfoRow",
            "usernameRow",
            "birthdayRow",
            "bizHoursRow",
            "bizLocationRow",
            "noteRow",
        ]
        for name in anchors:
            value = self._get_int_field(activity, name)
            if value != -1:
                return value + 1
        return -1


class ContactStatusListAdapterGetItemViewTypeHook:
    def __init__(self, plugin):
        self.plugin = plugin

    def before_hooked_method(self, param):
        adapter = param.thisObject
        activity = self._get_activity_from_adapter(adapter)
        state = self.plugin.contact_status_activity_state.get(activity)
        if not state:
            return
        position_arg = param.args[0]
        try:
            position = int(position_arg)
        except Exception:
            position = position_arg
        if position == state.get("mutualRow", -1):
            try:
                INTEGER_CLASS = jclass("java.lang.Integer")
                param.setResult(INTEGER_CLASS(1024))
            except Exception:
                param.setResult(1024)

    def _get_activity_from_adapter(self, adapter):
        try:
            field = adapter.getClass().getDeclaredField("this$0")
            field.setAccessible(True)
            return field.get(adapter)
        except Exception:
            return None


class ContactStatusListAdapterCreateViewHolderHook:
    def __init__(self, plugin):
        self.plugin = plugin

    def before_hooked_method(self, param):
        view_type = param.args[1]
        if view_type != 1024:
            return

        try:
            adapter = param.thisObject
            activity = self._get_activity_from_adapter(adapter)

            context = None
            parent = param.args[0]
            if parent is not None:
                try:
                    context = parent.getContext()
                except Exception:
                    context = None
            if context is None and activity is not None:
                for getter in ("getParentActivity", "getContext"):
                    try:
                        method = getattr(activity, getter)
                        context = method()
                        if context:
                            break
                    except Exception:
                        continue
            if context is None:
                raise ValueError("No context available for mutual cell")

            from org.telegram.ui.Cells import TextDetailCell
            cell = TextDetailCell(context)
            holder_class = jclass("org.telegram.ui.Components.RecyclerListView$Holder")
            holder = holder_class(cell)
            param.setResult(holder)
        except Exception:
            pass

    def _get_activity_from_adapter(self, adapter):
        try:
            field = adapter.getClass().getDeclaredField("this$0")
            field.setAccessible(True)
            return field.get(adapter)
        except Exception:
            return None


class ContactStatusListAdapterBindViewHolderHook:
    def __init__(self, plugin):
        self.plugin = plugin

    def after_hooked_method(self, param):
        position_arg = param.args[1]
        try:
            position = int(position_arg)
        except Exception:
            position = position_arg
        adapter = param.thisObject
        activity = self._get_activity_from_adapter(adapter)
        state = self.plugin.contact_status_activity_state.get(activity)
        if not state or position != state.get("mutualRow", -1):
            return

        try:
            holder = param.args[0]
            item_view = holder.itemView
            from org.telegram.ui.Cells import TextDetailCell
            if isinstance(item_view, TextDetailCell):
                item_view.setTextAndValue(
                    get_string("mutual_contact", "Mutual contact"),
                    get_string("both_saved_as_contacts", "Both saved as contacts"),
                    True
                )
        except Exception:
            pass

    def _get_activity_from_adapter(self, adapter):
        try:
            field = adapter.getClass().getDeclaredField("this$0")
            field.setAccessible(True)
            return field.get(adapter)
        except Exception:
            return None


class UiTweaksPlugin(BasePlugin):
    def __init__(self):
        super().__init__()
        
        self._class_cache = {}

        self.hook_dialogs_ref = None
        self.hook_dialogs_destroy_ref = None
        self.hook_dialog_cell_ref = None
        self.hook_photo_cell_ref = None
        self.hook_gif_spoiler_ref = None
        self.hook_gif_dismiss_ref = None
        self.hook_process_external_url_ref = None
        self.hook_photo_cell_set_entry_ref = None
        self.hook_drawer_icon_ref = None
        self.hook_swipe_prevention_ref = None
        self.hook_star_reaction_menu_ref = None
        self.hook_star_reaction_visible_list_ref = None
        self.hook_article_viewer_ref = None
        self.hook_webapp_swipe_prevention_ref = None
        self.hook_download_manager_ref = None
        self.hook_proxy_button_ref = None
        self.current_popup = None
        self._cached_accounts = None
        self.hook_phone_number_ref = None
        self.hook_messages_controller_ref = None
        self.hook_update_bot_button_ref = None
        self.hook_call_buttons_ref = None
        self.hook_group_voice_chat_icon_ref = None
        self.hook_voice_message_control_ref = None
        self.hook_voice_message_time_display_ref = None
        self.hook_video_message_control_ref = None
        self.create_view_hook_ref = None
        self.destroy_hook_ref = None
        self.current_chat_activity = None
        self.current_back_button = None
        self.counter_views = {}
        self._unhook_layout = None
        self.hook_add_to_folder_all_tabs_ref = None
        self.forced_scroll_offset = 200
        
        self.unhook_send_message = None
        self.unhook_deeplink = None
        self.unhook_set_command = None
        self.hook_handler = None
        self.command_from_message_click = False
        self.hook_link_confirmation_ref = None
        self.hook_disable_topic_swipe_ref = None
        self.hook_select_all_media_ref = None
        self.hook_account_visibility_drawer_ref = None
        self.hook_account_visibility_profile_ref = None
        self.hook_fill_action_mode_menu_ref = None
        self.hook_perform_menu_action_ref = None
        self.hook_message_preview_view_ref = None
        self.hook_share_sheet_folders_ref = None
        self.hook_swipe_disable_ref = None
        self.hook_star_reaction_gradient_ref = None
        self.hook_star_reaction_layout_draw_ref = None
        self.hook_disable_auto_web_login_ref = None
        self.hook_do_not_share_phone_number_ref = None
        self.hook_prefer_common_groups_tab_ref = None
        self.hook_non_clickable_dispatch_ref = None
        self.hook_non_clickable_present_ref = None
        self.hook_non_clickable_present_ref2 = None
        self.hook_birthday_alert_ref = None
        self.hook_forward_confirmation_ref = None
        self.hook_join_confirmation_ref = None
        self.hook_send_typing_refs = None
        self.hook_open_link_internally_ref = None

        self.hook_browser_open_url_ref = None
        self.hook_code_formatting_ref = None
        self.hook_sender_select_popup_ref = None
        self.hook_unread_count_ref = None
        self.contact_status_update_rows_hook = None
        self.contact_status_get_item_view_type_hook = None
        self.contact_status_create_view_holder_hook = None
        self.contact_status_bind_view_holder_hook = None
        self.contact_status_activity_state = {}
        
        self.safe_mode_hook_ref = None
        self.safe_mode_last_volume_down_time = 0
        self.safe_mode_volume_down_count = 0
        self.safe_mode_multi_tap_window = 2000
        self.safe_mode_required_taps = 5
        self.safe_mode_cooldown = 5000
        self.safe_mode_volume_down_press_time = 0
        self.safe_mode_is_holding = False
        
        self.no_quote_forward_menu_handle = None
        self.repeat_menu_handle = None
        
        self.hook_search_by_user_id_ref = None
        self.hook_settings_header_ref = None
        self.added_send_media_buttons = set()
        self._no_quote_buttons_created = set()
        self._no_quote_button_cache = {}

        self._select_all_id = 1000
        self._select_all_added_modes = set()
        
        self._goto_items_added = set()
        

        self.hooked_activities = set()
        self.hook_chat_activity_cleanup_ref = None
        self.memory_check_running = False
        
       
        self.hidden_folders_data = {}
        self.hide_all_chats_folder = {}
        self.hook_folder_visibility_ref = None
        self.hook_reply_in_another_chat_layout_ref = None
        self.hook_reply_in_another_chat_dialogs_ref = None
        self.allow_reply_button_hook_ref = None
        self.hook_gift_drawer_reset_ref = None
        self.hook_gift_drawer_click_ref = None
        self.hook_gift_drawer_cell_ref = None
        
        self.hook_ai_summarize_create_view_ref = None
        self.hook_ai_summarize_item_click_ref = None
        self.ai_summarize_menu_id = 99997
        self.ai_summarize_hooked_activities = set()
        
        self.goto_message_menu_id = 99996
        self.chat_action_bar_hooked_activities = set()
        
        self.hook_ai_role_limit_constructor_ref = None
        self.hook_ai_role_limit_settext_ref = None
        
        self.hook_sleep_timer_ref = None
        self.hook_sleep_timer_click_ref = None
        self.sleep_timer_active = False
        self._sleep_handler = None
        self._sleep_runnable = None
        
        self.hook_adaptive_audio_ref = None
        
        self.hook_music_speed_control_ref = None
        
        self.hook_custom_saved_messages_ref = None
        self.custom_saved_chat_id = None
        
        self.hook_disable_emoji_suggestions_ref = None
        self.hook_message_swipe_action_ref = None
        self.hook_join_request_direct_profile_ref = None
        self.hook_search_filter_open_search_ref = None
        self.hook_search_filter_send_request_ref = None
        self.search_filter_current = 0
        self.search_filter_buttons = {}
        
        self.hook_play_sound_ref = None
        self.hook_soundpool_load_ref = None
        self.ios_sound_path = None
        self.soundpool_instance = None
        self.ios_sound_id = None
        
        self.hook_search_links_ref = None
        self.hook_enter_view_constructor_ref = None
        self.hook_send_message_params_ref = None
        
        self.hook_reactions_container_ref = None
        
        self.hook_unify_username_behavior_process_click_ref = None
        self.hook_unify_username_behavior_bind_ref = None
        
        self.hook_edit_file_name_ref = None
        self._last_item_options = None
        self._menu_item_added = False
        self._message_send_preview = None

    def log(self, message: str):
        if self.get_setting("show_logs", False):
            log(f"[UiTweaks] {message}")
    
    def _perform_haptic(self, host=None):
        try:
            root = None
            if host:
                get_pa = getattr(host, 'getParentActivity', None)
                if callable(get_pa):
                    act = get_pa()
                    if act:
                        root = act.getWindow().getDecorView()
                if root is None and hasattr(host, 'getWindow'):
                    root = host.getWindow().getDecorView()
            if root is None:
                cf = get_last_fragment()
                if cf:
                    act = cf.getParentActivity()
                    if act:
                        root = act.getWindow().getDecorView()
            if root:
                flags = HapticFeedbackConstants.FLAG_IGNORE_VIEW_SETTING | HapticFeedbackConstants.FLAG_IGNORE_GLOBAL_SETTING
                root.performHapticFeedback(HapticFeedbackConstants.KEYBOARD_TAP, flags)
        except:
            pass
    
    def _get_launch_activity(self, host=None):
        try:
            la = LaunchActivity.instance
        except:
            la = None
        if not la and host:
            try:
                pa = host.getParentActivity()
                if pa:
                    la = pa
            except:
                pass
        return la
    
    def _check_memory(self):
        try:
            if not self.get_setting("enable_memory_warning", True):
                return
                
            from java.lang import Runtime
            
            runtime = Runtime.getRuntime()
            used_memory = (runtime.totalMemory() - runtime.freeMemory()) / (1024 * 1024)
            
            if used_memory > 500:
                self.log(f"Memory threshold exceeded: {used_memory:.2f}MB")
                run_on_ui_thread(lambda: self._show_memory_alert(used_memory))
                return True
        except Exception as e:
            self.log(f"Error checking memory: {e}")
        return False
    
    def _show_memory_alert(self, used_mb):
        try:
            fragment = get_last_fragment()
            if not fragment:
                return
            
            context = fragment.getParentActivity()
            if not context:
                context = ApplicationLoader.applicationContext
            
            builder = AlertDialogBuilder(context)
            title_text = get_string("memory_warning_title", "Memory Warning")
            message_template = get_string("memory_warning_message", "High memory usage: {used_mb}MB.\n\nRestart app or dump memory?")
            message_text = message_template.replace("{used_mb}", f"{used_mb:.0f}")
            builder.set_title(title_text)
            builder.set_message(message_text)
            
            def on_restart(dialog, which):
                dialog.dismiss()
                from quantahut import restart_app
                restart_app(fragment)
            
            def on_dump_memory(dialog, which):
                dialog.dismiss()
                self._dump_memory()
            
            builder.set_positive_button(get_string("restart_app", "Restart"), on_restart)
            builder.set_neutral_button(get_string("dump_memory", "Dump Memory"), on_dump_memory)
            builder.set_negative_button(get_string("cancel", "Cancel"), lambda d, w: d.dismiss())
            builder.show()
            builder.set_canceled_on_touch_outside(False)
        except Exception as e:
            self.log(f"Error showing memory alert: {e}")
    
    def _dump_memory(self):
        try:
            from java.lang import System
            from java.lang import Runtime
            import time
            
            runtime = Runtime.getRuntime()
            used_memory_before = (runtime.totalMemory() - runtime.freeMemory()) / (1024 * 1024)
            
            System.gc()
            System.runFinalization()
            System.gc()
            
            time.sleep(0.5)
            
            used_memory_after = (runtime.totalMemory() - runtime.freeMemory()) / (1024 * 1024)
            freed_memory = used_memory_before - used_memory_after
            
            self.log(f"Memory dump completed. Freed: {freed_memory:.2f}MB (Before: {used_memory_before:.2f}MB, After: {used_memory_after:.2f}MB)")
            
            from ui.bulletin import BulletinHelper
            if freed_memory > 0:
                BulletinHelper.show_success(get_string("memory_dump_success", "Memory dump successful! Freed {freed_memory:.1f}MB").format(freed_memory=freed_memory))
            else:
                BulletinHelper.show_info(get_string("memory_dump_no_freed", "Memory dump completed. No significant memory was freed."))
                
        except Exception as e:
            self.log(f"Error dumping memory: {e}")
            from ui.bulletin import BulletinHelper
            BulletinHelper.show_error(get_string("memory_dump_failed", "Failed to dump memory"))
    
    def _start_memory_monitoring(self):
        if self.memory_check_running:
            return
        
        self.memory_check_running = True
        self._last_memory_alert = 0
        
        def monitor():
            import time
            while self.memory_check_running:
                try:
                    current_time = time.time()
                    if current_time - self._last_memory_alert > 600:
                        alert_shown = self._check_memory()
                        if alert_shown:
                            self._last_memory_alert = current_time
                    time.sleep(60)
                except:
                    pass
        
        thread = threading.Thread(target=monitor)
        thread.daemon = True
        thread.start()

    def on_plugin_load(self):
        self.log(f"UiTweaks {__version__} loaded")
        self.custom_saved_chat_id = self.get_setting("custom_saved_chat_id", None)
        self.add_on_send_message_hook()
        self._load_hidden_folders()
        self._setup_quanta_file_hook()
        global uitweaks_plugin_instance
        uitweaks_plugin_instance = self
        
        self.current_mode = self.get_setting("forward_mode", "forward")
        
        self._send_comments_bypass = False
        self._send_comments_pending = {}
        
        self.update_available = False
        self.latest_version = None
        self.changelog = None
        self.download_url = None
        self.checking_update = False
        
        self.hook_always_visible_schedule_button_ref = None
        self.hook_remove_greeting_sticker_ref = None
        self.hook_remove_https_from_links_ref = None
        self.hook_share_alert_forward_open_ref = None
        self.hook_share_alert_forward_process_ref = None
        
        try:
            locale_controller = LocaleController.getInstance()
            current_language = locale_controller.getCurrentLocaleInfo().getLangCode()
            self.log(f"Language detected: {current_language}")
        except Exception as e:
            current_language = "en"
            self.log(f"Language detection failed: {e}, using default: {current_language}")
        try:
            _pref_lang = get_selected_language_preference()
            if _pref_lang:
                self.log(f"[Diag] overriding detected language with stored preference: {_pref_lang}")
                current_language = _pref_lang
        except Exception as e:
            self.log(f"[Diag] failed to apply stored preference override: {e}")
        
        
        
        self.hook_handler = ConfirmationHook(self)
        self.add_hook("TL_messages_forwardMessages")
        self._apply_hooks()
        self._setup_confirmation_hooks()
        self._setup_deeplink_hooks()
        self._setup_open_profile_hooks()
        self._setup_open_link_internally_hook()
        self._setup_settings_header_hook()
        
        if self.get_setting("enable_goto_message", False):
            self._hook_goto_message()
        
        if self.get_setting("enable_reply_in_another_chat_shortcut", False):
            self._hook_reply_in_another_chat()
            self._hook_allow_reply_button()
        
        if self.get_setting("enable_reply_private_chat", False):
            self._add_reply_private_chat_menu_item()
        
        if self.get_setting("enable_no_quote_forward", False):
            self._add_no_quote_forward_menu_item()

        if self.get_setting("enable_select_all_dialogs", False):
            self._setup_select_all_dialogs()
        


        
        try:
            run_on_queue(self._perform_heavy_operations, PLUGINS_QUEUE, 2000)
        except Exception as e:
            run_on_ui_thread(self._perform_heavy_operations, 3000)
        
        self._start_memory_monitoring()
        
        self._check_for_updates_on_load()

    def _setup_select_all_dialogs(self):
        try:
            DialogsActivityCls = find_class("org.telegram.ui.DialogsActivity")
            CreateActionMode = DialogsActivityCls.getClass().getDeclaredMethod("createActionMode", find_class("java.lang.String").getClass())
            CreateActionMode.setAccessible(True)
            ActionBarMenuCls = find_class("org.telegram.ui.ActionBar.ActionBarMenu")
            OnItemClick = ActionBarMenuCls.getClass().getDeclaredMethod("onItemClick", find_class("java.lang.Integer").TYPE)
            OnItemClick.setAccessible(True)

            class _UT_AddSelectAllMenu:
                def __init__(self, plugin):
                    self.plugin = plugin

                def after_hooked_method(self, param):
                    try:
                        dlg = param.thisObject
                        actionBar = getattr(dlg, "actionBar", None)
                        if actionBar is None:
                            return
                        actionMode = actionBar.getActionMode()
                        if actionMode is None:
                            return
                        try:
                            hc = actionMode.hashCode()
                            if hc in self.plugin._select_all_added_modes:
                                return
                        except Exception:
                            pass
                        otherItem = None
                        for i in range(actionMode.getChildCount()):
                            child = actionMode.getChildAt(i)
                            if child is not None and child.getClass().getName().endswith("ActionBarMenuItem"):
                                try:
                                    if hasattr(child, "hasSubMenu") and child.hasSubMenu():
                                        otherItem = child
                                        break
                                except Exception:
                                    pass
                        if otherItem is None:
                            return
                        try:
                            popup = get_private_field(otherItem, "popupLayout")
                            if popup is not None:
                                for k in range(popup.getItemsCount()):
                                    v = popup.getItemAt(k)
                                    if v is not None and v.getTag() == self.plugin._select_all_id:
                                        self.plugin._select_all_added_modes.add(hc)
                                        return
                        except Exception:
                            pass
                        title = get_string("select_all", "Select all")
                        otherItem.addSubItem(self.plugin._select_all_id, R_tg.drawable.msg_select_between_solar, title)
                        try:
                            self.plugin._select_all_added_modes.add(hc)
                        except Exception:
                            pass
                    except Exception:
                        pass

            class _UT_InterceptSelectAllClick:
                def __init__(self, plugin):
                    self.plugin = plugin

                def before_hooked_method(self, param):
                    try:
                        itemId = int(param.args[0])
                        if itemId != self.plugin._select_all_id:
                            return
                        menu = param.thisObject
                        actionBar = get_private_field(menu, "parentActionBar")
                        if actionBar is None:
                            return
                        fragment = get_private_field(actionBar, "parentFragment")
                        if fragment is None:
                            return
                        if fragment.getClass().getName() != "org.telegram.ui.DialogsActivity":
                            return
                        dlg = fragment

                        viewPages = get_private_field(dlg, "viewPages")
                        adapter = None
                        listView = None
                        if viewPages is not None:
                            try:
                                vp0 = viewPages[0]
                                adapter = get_private_field(vp0, "dialogsAdapter") or getattr(vp0, "dialogsAdapter", None)
                                listView = get_private_field(vp0, "listView") or getattr(vp0, "listView", None)
                            except Exception:
                                pass
                        if adapter is None or listView is None:
                            try:
                                GetListView = dlg.getClass().getDeclaredMethod("getListView")
                                GetListView.setAccessible(True)
                                listView = GetListView.invoke(dlg)
                                adapter = listView.getAdapter() if listView is not None else None
                            except Exception:
                                pass
                        selected = get_private_field(dlg, "selectedDialogs")
                        if adapter is None or listView is None or selected is None:
                            return

                        DialogsActivityCls2 = dlg.getClass()
                        ShowOrUpdate = None
                        methods = DialogsActivityCls2.getDeclaredMethods()
                        for m in methods:
                            try:
                                if m.getName() == "showOrUpdateActionMode" and len(m.getParameterTypes()) == 2:
                                    ShowOrUpdate = m
                                    break
                            except Exception:
                                pass
                        if ShowOrUpdate is None:
                            return
                        ShowOrUpdate.setAccessible(True)

                        LongClass = find_class("java.lang.Long")
                        DialogInterface = find_class("org.telegram.tgnet.TLRPC$Dialog")

                        state = {"index": 0}
                        state["count"] = adapter.getItemCount()
                        BATCH_SIZE = 24
                        MAX_LOAD_ATTEMPTS = 8
                        state["load_attempts"] = 0
                        initial_adapter = adapter

                        def step():
                            try:
                                if listView.getAdapter() != initial_adapter:
                                    return
                                actionBar2 = getattr(dlg, "actionBar", None)
                                actionMode2 = actionBar2.getActionMode() if actionBar2 is not None else None
                                if actionMode2 is None:
                                    return
                     
                                try:
                                    if not actionBar2.isActionModeShowed():
                                        return
                                except Exception:
                                    pass

                                done = False
                                for _ in range(BATCH_SIZE):
                                    i = state["index"]
                                    if i >= state.get("count", 0):
                                        def _attempt_load_more():
                                            try:
                                                if listView.getAdapter() != initial_adapter:
                                                    return
                                                actionBar3 = getattr(dlg, "actionBar", None)
                                                actionMode3 = actionBar3.getActionMode() if actionBar3 is not None else None
                                                if actionMode3 is None:
                                                    return
                                  
                                                try:
                                                    if not actionBar3.isActionModeShowed():
                                                        return
                                                except Exception:
                                                    pass
                                                try:
                                                    pos = max(0, state.get("count", 0) - 1)
                                                    listView.scrollToPosition(pos)
                                                except Exception:
                                                    pass
                                                def _check_new_count():
                                                    try:
                                                        new_count = adapter.getItemCount()
                                                        if new_count > state.get("count", 0):
                                                            state["count"] = new_count
                                                            state["load_attempts"] = 0
                                                            run_on_ui_thread(step)
                                                        else:
                                                            state["load_attempts"] = state.get("load_attempts", 0) + 1
                                                            if state["load_attempts"] < MAX_LOAD_ATTEMPTS:
                                                                run_on_ui_thread(_attempt_load_more, 200)
                                                            else:
                                                                try:
                                                                    update_counters = dlg.getClass().getDeclaredMethod("updateCounters", find_class("java.lang.Boolean").TYPE)
                                                                    update_counters.setAccessible(True)
                                                                    update_counters.invoke(dlg, True)
                                                                except Exception:
                                                                    pass
                                                    except Exception:
                                                        pass
                                                run_on_ui_thread(_check_new_count, 200)
                                            except Exception:
                                                pass
                                        _attempt_load_more()
                                        return
                                    try:
                                        item = adapter.getItem(i)
                                        state["index"] = i + 1
                                        if item is None:
                                            continue
                                        try:
                                            if not DialogInterface.isInstance(item):
                                                continue
                                        except Exception:
                                            if not str(item.getClass().getName()).startswith("org.telegram.tgnet.TLRPC$"):
                                                continue
                                        did = getattr(item, "id", None)
                                        if did is None:
                                            continue
                                        try:
                                            if selected.contains(LongClass.valueOf(did)):
                                                continue
                                        except Exception:
                                            try:
                                                if selected.contains(jlong(did)):
                                                    continue
                                            except Exception:
                                                pass
                                        holder = listView.findViewHolderForAdapterPosition(i)
                                        cellView = holder.itemView if holder is not None else None
                                        ShowOrUpdate.invoke(dlg, jlong(did), cellView)
                                    except Exception:
                                        pass

                                if done:
                                    try:
                                        update_counters = dlg.getClass().getDeclaredMethod("updateCounters", find_class("java.lang.Boolean").TYPE)
                                        update_counters.setAccessible(True)
                                        update_counters.invoke(dlg, True)
                                    except Exception:
                                        pass
                                else:
                                    run_on_ui_thread(step)
                            except Exception:
                                pass

                        run_on_ui_thread(step)
                    except Exception:
                        pass

            self.hook_method(CreateActionMode, _UT_AddSelectAllMenu(self))
            self.hook_method(OnItemClick, _UT_InterceptSelectAllClick(self), priority=10)
        except Exception as e:
            try:
                pass
            except Exception:
                pass

    def _perform_heavy_operations(self):
        try:
            start_time = time.time()
            timeout = 30
            
            if time.time() - start_time > timeout:
                return
                
            
            if time.time() - start_time > timeout:
                return
                
                    
        except Exception as e:
            pass



    def _setup_settings_header_hook(self):
        try:
            PSA = find_class("com.exteragram.messenger.plugins.ui.PluginSettingsActivity")
            if not PSA:
                return
            method = PSA.getClass().getDeclaredMethod("fillItems", find_class("java.util.ArrayList"), find_class("org.telegram.ui.Components.UniversalAdapter"))
            method.setAccessible(True)
            self.hook_settings_header_ref = self.hook_method(method, UiTweaksSettingsHeaderHook(self))
        except:
            pass

    def _create_settings_header(self, context):
        try:
            from android.widget import FrameLayout, TextView
            from android.view import Gravity
            from android.util import TypedValue
            from org.telegram.messenger import AndroidUtilities, MediaDataController, ImageLocation
            from org.telegram.ui.ActionBar import Theme
            from org.telegram.ui.Components import LayoutHelper, BackupImageView
            
            container = FrameLayout(context)
            
            if self.get_setting("enable_header_particles", True):
                try:
                    from org.telegram.ui.Components.Premium import StarParticlesView

                    particlesView = StarParticlesView(context)
                    particlesView.setClipWithGradient()
                    particlesView.drawable.colorKey = Theme.key_premiumStarGradient2
                    particlesView.drawable.isCircle = True
                    particlesView.drawable.centerOffsetY = AndroidUtilities.dp(0)
                    particlesView.drawable.minLifeTime = 2000
                    particlesView.drawable.randLifeTime = 3000
                    particlesView.drawable.useRotate = False
                    particlesView.drawable.updateColors()
                    container.addView(particlesView, LayoutHelper.createFrame(-1, 220, Gravity.CENTER_HORIZONTAL | Gravity.TOP, 0, 0, 0, 0))

                    run_on_ui_thread(lambda: particlesView.flingParticles(360), 200)
                except: pass
            
            imageView = BackupImageView(context)
            imageView.setRoundRadius(AndroidUtilities.dp(54))
            
            def try_load_sticker(img):
                ss = MediaDataController.getInstance(0).getStickerSetByName("luvztroyIcons") or MediaDataController.getInstance(0).getStickerSetByEmojiOrName("luvztroyIcons")
                if ss and ss.documents and ss.documents.size() > 13:
                    img.setImage(ImageLocation.getForDocument(ss.documents.get(13)), "108_108", None, None, 0, 1)

                    return True
                return False
            
            if not try_load_sticker(imageView):

                MediaDataController.getInstance(0).loadStickersByEmojiOrName("luvztroyIcons", False, False)
                run_on_ui_thread(lambda: try_load_sticker(imageView), 1500)
            
            container.addView(imageView, LayoutHelper.createFrame(108, 108, Gravity.CENTER | Gravity.TOP, 0, 20, 0, 0))
            
            title = TextView(context)
            title.setTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteBlackText))
            title.setTypeface(AndroidUtilities.getTypeface(AndroidUtilities.TYPEFACE_ROBOTO_MEDIUM))
            title.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 22)
            title.setText(f"UiTweaks {__version__}")
            title.setSingleLine(True)
            title.setGravity(Gravity.CENTER)
            container.addView(title, LayoutHelper.createFrame(-2, -2, Gravity.CENTER | Gravity.TOP, 50, 145, 50, 0))
            
            subtitle = TextView(context)
            subtitle.setTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteGrayText))
            subtitle.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 14)
            subtitle.setText("An experimental plugin for exteraGram based on python!")
            subtitle.setGravity(Gravity.CENTER)
            container.addView(subtitle, LayoutHelper.createFrame(-2, -2, Gravity.CENTER | Gravity.TOP, 60, 180, 60, 27))
            
            try:
                from java import dynamic_proxy
                from android.view import View, MotionEvent
                class TouchListener(dynamic_proxy(View.OnTouchListener)):
                    def onTouch(self, v, event):
                        action = event.getAction()
                        if action == MotionEvent.ACTION_DOWN:
                            v.animate().scaleX(0.9).scaleY(0.9).setDuration(100).start()
                        elif action == MotionEvent.ACTION_UP or action == MotionEvent.ACTION_CANCEL:
                            v.animate().scaleX(1.0).scaleY(1.0).setDuration(100).start()
                        return True
                imageView.setOnTouchListener(TouchListener())
            except: pass
            
            return container
        except:
            return None

    def _create_general_settings(self):
        return [
            Header(text=get_string("security_and_privacy", "Security & Privacy")),
            self.Quanta_switch("confirm_deeplinks", get_string("confirm_deeplinks", "Confirm Telegram Deep Links"), False, lambda v: self._apply_hooks(), link_alias="confirm_deeplinks"),
            self.Quanta_switch("confirm_ayugram_deeplinks", get_string("confirm_ayugram_deeplinks", "Confirm AyuGram Deep Links"), False, lambda v: self._apply_hooks(), link_alias="confirm_ayugram_deeplinks"),
            self.Quanta_switch("disable_auto_web_login", get_string("disable_auto_web_login", "Disable Auto Web Login"), False, lambda v: self._apply_hooks(), link_alias="disable_auto_web_login"),
            self.Quanta_switch("do_not_share_phone_number", get_string("do_not_share_phone_number", "Do Not Share My Phone Number"), False, lambda v: self._apply_hooks(), link_alias="do_not_share_phone_number"),
            self.Quanta_switch("hide_phone_number", get_string("hide_phone_number", "Hide Phone Number in Profiles"), False, lambda v: self._apply_hooks(), link_alias="hide_phone_number"),
            Divider(text=get_string("hide_phone_number_info", "This will hide the recipient's phone number from their profile.")),
            
            Header(text=get_string("profile_and_chats", "Profile & Chats")),
            self.Quanta_switch("hide_birthday_alert", get_string("hide_birthday_alert", "Hide Birthday Alert"), False, lambda v: self._apply_hooks(), link_alias="hide_birthday_alert"),
            self.Quanta_switch("prefer_common_groups_tab", get_string("prefer_common_groups_tab", "Prefer Common Groups Tab"), False, lambda v: self._apply_hooks(), link_alias="prefer_common_groups_tab"),
            Divider(text=get_string("prefer_common_groups_tab_info", "Automatically selects the Groups tab instead of Gifts tab in user profiles when both are available.")),
            
            
            Header(text=get_string("navigation_controls", "Navigation Controls")),
            self.Quanta_switch("prevent_swipe_while_editing", get_string("prevent_swipe_while_editing", "Prevent swipe back while editing"), False, lambda v: self._apply_hooks(), link_alias="prevent_swipe_while_editing"),
            self.Quanta_switch("prevent_swipe_while_typing", get_string("prevent_swipe_while_typing", "Prevent swipe back while typing"), False, lambda v: self._apply_hooks(), link_alias="prevent_swipe_while_typing"),
            self.Quanta_switch("disable_article_viewer_swipe", get_string("disable_article_viewer_swipe", "Disable ArticleViewer swipe to close"), False, lambda v: self._apply_hooks(), link_alias="disable_article_viewer_swipe"),
            self.Quanta_switch("prevent_webapp_swipe_down", get_string("prevent_webapp_swipe_down", "Prevent swipe down in webapp bots"), False, lambda v: self._apply_hooks(), link_alias="prevent_webapp_swipe_down"),
            self.Quanta_switch("disable_topics_swipe", get_string("disable_topics_swipe", "Disable Topics Swipe to Hide"), False, lambda v: self._apply_hooks(), link_alias="disable_topics_swipe"),
            Divider(text=get_string("navigation_controls_info", "This will prevent the Telegram navigation gestures to work from these scenarios.")),
            
            Header(text=get_string("quick_access", "Quick Access")),
            self.Quanta_switch("fab_settings_shortcut", get_string("fab_settings_shortcut", "FAB Shortcut"), False, lambda v: self._apply_hooks(), link_alias="fab_settings_shortcut"),
            self.Quanta_selector("fab_action_selector", get_string("fab_action_selector", "Action"), [get_string("fab_action_uitweaks_settings", "UiTweaks Settings"), get_string("fab_action_archived_chats", "Archived Chats")], 0, lambda v: self._apply_hooks(), link_alias="fab_action_selector") if self.get_setting("fab_settings_shortcut", False) else None,
            self.Quanta_switch("quick_access_gift_market", get_string("quick_access_gift_market", "Quick Access to Gift Market"), False, lambda v: self._apply_hooks(), link_alias="quick_access_gift_market"),
            
            Header(text=get_string("general", "General")),
            self.Quanta_switch("enable_select_all_media", get_string("enable_select_all_media", "Select All Media Button"), False, lambda v: self._apply_hooks(), link_alias="enable_select_all_media"),
            self.Quanta_switch("enable_sleep_timer", get_string("sleep_timer", "Music Sleep Timer"), False, lambda v: self._apply_hooks(), link_alias="enable_sleep_timer"),
            self.Quanta_switch("disable_emoji_suggestions", get_string("disable_emoji_suggestions", "Disable Emoji Suggestions"), False, lambda v: self._apply_hooks(), link_alias="disable_emoji_suggestions"),
            self.Quanta_switch("remove_greeting_sticker", get_string("remove_greeting_sticker", "Remove Greeting Sticker"), False, lambda v: self._apply_hooks(), link_alias="remove_greeting_sticker"),
            self.Quanta_switch("remove_https_from_links", get_string("remove_https_from_links", "Remove HTTPS From Links"), False, lambda v: self._apply_hooks(), link_alias="remove_https_from_links"),
            self.Quanta_switch("enable_music_speed_control", get_string("enable_music_speed_control", "Music Speed Control"), False, lambda v: self._apply_hooks(), link_alias="enable_music_speed_control"),
            Divider(text=get_string("music_speed_control_info", "Enable playback speed control for all music files regardless of duration.")) if self.get_setting("enable_music_speed_control", False) else None,

        ]

    def _create_miscellaneous_settings(self):
        return [ 
            Header(text=get_string("chats", "Chats")),
            self.Quanta_switch("enable_message_preview_enhancement", get_string("message_preview_send_button", "Share media from link preview"), False, lambda v: self._apply_hooks(), link_alias="enable_message_preview_enhancement"),
            self.Quanta_switch("enable_share_sheet_folders", get_string("add_folders_to_share_sheet", "Folders in direct share sheet"), False, lambda v: self._apply_hooks(), link_alias="enable_share_sheet_folders"),
            self.Quanta_switch("enable_sender_select_enhancement", get_string("sender_select_improvements", "Send message as menu improvements"), False, lambda v: self._apply_hooks(), link_alias="enable_sender_select_enhancement"),
            Divider(text=get_string("sender_select_subtext", "Show personal account in \"send message as\" menu where you are the owner of the group")),
            self.Quanta_switch("enable_join_request_direct_profile", get_string("join_request_direct_profile", "Open user profile directly from join requests"), False, lambda v: self._apply_hooks(), link_alias="enable_join_request_direct_profile"),

            Header(text=get_string("chat_list", "Chat List")),
            self.Quanta_switch("enable_select_all_dialogs", get_string("select_all_dialogs_menu", "Select All Chats"), False, lambda v: self._apply_hooks(), link_alias="enable_select_all_dialogs"),
            self.Quanta_switch("enable_add_to_folder_all_tabs", get_string("add_to_folder_all_tabs", "Add to Folder in All Tabs"), False, lambda v: self._apply_hooks(), link_alias="enable_add_to_folder_all_tabs"),
            self.Quanta_switch("enable_swipe_disable", get_string("disable_swipe_gestures", "Swipe gesture menu improvements"), False, lambda v: self._apply_hooks(), link_alias="enable_swipe_disable"),
            Divider(text=get_string("disable_swipe_subtext", "Add disable option in Telegrams \"Chat list swipe gesture\" menu")),
            
            Header(text=get_string("account_and_display", "Account & Display")),
            self.Quanta_switch("enable_non_clickable_preview", get_string("non_clickable_preview", "Non-Clickable Chat Preview"), False, lambda v: self._apply_hooks(), link_alias="enable_non_clickable_preview"),
            self.Quanta_switch("enable_account_visibility", get_string("account_visibility", "Account Visibility"), False, lambda v: self._apply_hooks(), link_alias="enable_account_visibility"),
            Divider(text=get_string("account_visibility_subtext", "Hide/show accounts by long-pressing theme button")),
            
            Header(text=get_string("advanced", "Advanced")),
            self.Quanta_switch("enable_ai_role_limit", get_string("ai_role_limit", "AI Role Limit Increaser"), False, lambda v: self._apply_hooks(), link_alias="enable_ai_role_limit"),
            self.Quanta_switch("enable_search_by_user_id", get_string("search_by_user_id", "Search by User ID"), False, lambda v: self._apply_hooks(), link_alias="enable_search_by_user_id"),
            self.Quanta_switch("enable_safe_mode", get_string("safe_mode", "Safe Mode"), False, lambda v: self._apply_hooks(), link_alias="enable_safe_mode"),
            Divider(text=get_string("safe_mode_subtext", "Press volume down 5 times quickly to enable plugin safe mode ~ In Safe Mode, all plugins are inactive. This allows you to safely find and disable a problematic plugin.")),
        ]

    def _create_appearance_settings(self):
        settings = []
        
        settings.extend([
            Header(text=get_string("hide_elements", "Hide Elements")),
            self.Quanta_switch("hide_bot_open", get_string("hide_bot_open", "Bot 'Open' button in chat list"), False, lambda v: self._apply_hooks(), link_alias="hide_bot_open"),
            self.Quanta_switch("hide_hd_icon", get_string("hide_hd_icon", "HD icon in media picker"), False, lambda v: self._apply_hooks(), link_alias="hide_hd_icon"),
            Divider(text=get_string("hide_hd_icon_info", "This will only remove the HD icon from the media picker. It will not affect the quality of the media.")),
            self.Quanta_switch("hide_archived_chats", get_string("hide_archived_chats", "Hide Archived Chats"), False, lambda v: self._apply_hooks(), link_alias="hide_archived_chats"),
            self.Quanta_switch("hide_archived_from_drawer", get_string("hide_archived_from_drawer", "Hide from drawer"), False, lambda v: self._on_hide_archived_from_drawer_change(v), link_alias="hide_archived_from_drawer") if self.get_setting("hide_archived_chats", False) else None,
            Divider(text=get_string("hide_archived_chats_info", "This will remove archived chats cell from the chat list by filtering them out of the dialogs query.")),
        ])

        settings.extend([
            Header(text=get_string("profile", "Profile")),
            self.Quanta_switch("enable_contact_status_in_profile", get_string("contact_status_in_profile", "Mutual Contact in Profile"), False, lambda v: self._apply_hooks(), link_alias="enable_contact_status_in_profile"),
            self.Quanta_switch("enable_unify_username_behavior", get_string("unify_username_behavior", "Unify Username Behavior"), False, lambda v: self._apply_hooks(), link_alias="enable_unify_username_behavior"),
        ])
        
        settings.extend([
            Header(text=get_string("action_bar", "Action Bar")),
            self.Quanta_switch("always_show_download_manager", get_string("always_show_download_manager", "Always Show Download Manager"), False, lambda v: self._apply_hooks(), link_alias="always_show_download_manager"),
            self.Quanta_switch("always_show_proxy_button", get_string("always_show_proxy_button", "Always Show Proxy Button"), False, lambda v: self._apply_hooks(), link_alias="always_show_proxy_button"),
            Divider(text=get_string("menu_visibility_info", "This will force the buttons to always show in the action bar.")),
        ])
        
        settings.extend([
            Header(text=get_string("Indicators", "Indicators")),
            self.Quanta_switch("unread_badge_on_back_button", get_string("unread_badge_on_back_button", "Unread Badge on Back Button"), False, lambda v: self._apply_hooks(), link_alias="unread_badge_on_back_button"),
        ])

        
        settings.extend([
            Header(text=get_string("manage_folders", "Manage Folders")),
            self.Quanta_switch("unread_chat_count", get_string("unread_chat_count", "Show Unread Chat Count"), False, lambda v: self._apply_hooks(), link_alias="unread_chat_count"),
            self.Quanta_switch("unread_message_count", get_string("unread_message_count", "Show Unread Message Count"), False, lambda v: self._apply_hooks(), link_alias="unread_message_count"),
            self.Quanta_switch("exclude_archived_from_count", get_string("exclude_archived_from_count", "Exclude Archived Chats from Count"), False, lambda v: self._apply_hooks(), link_alias="exclude_archived_from_count"),
            Divider(text=get_string("unread_count_info", "Adjust how unread counters behave in folders. When both are enabled, only non-muted chats are counted.")),
            self.Quanta_switch("hidefolders_enabled", get_string("hide_folders", "Hide Folders"), False, lambda v: self._toggle_hide_folders(v), link_alias="hide_folders"),
            self.Quanta_text(text=get_string("select_folders", "Select Folders"), on_click=lambda v: self._show_folder_selector(), link_alias="select_folders") if self.get_setting("hidefolders_enabled", False) else None,
            Divider(text=get_string("hide_folders_info", "Hide specific folders from the folder list. Select which folders to hide.")) if self.get_setting("hidefolders_enabled", False) else None,
        ])

        return settings

    def _create_chats_settings(self):
        settings = []
        
        settings.extend([
            Header(text=get_string("input_field", "Input Field")),
            self.Quanta_switch("hide_bot_button", get_string("hide_bot_button", "Hide Bot Button in Input Field"), False, lambda v: self._apply_hooks(), link_alias="hide_bot_button"),
            self.Quanta_switch("typing_instead_sticker", get_string("typing_instead_sticker", "Typing Instead of Choosing Sticker"), False, lambda v: self._apply_hooks(), link_alias="typing_instead_sticker"),
            self.Quanta_switch("enable_code_formatting", get_string("code_formatting_menu", "Code & Mention Formatting"), False, lambda v: self._apply_hooks(), link_alias="enable_code_formatting"),
            self.Quanta_switch("always_visible_schedule_button", get_string("always_visible_schedule_button", "Always Visible Schedule Button"), False, lambda v: self._apply_hooks(), link_alias="always_visible_schedule_button"),
        ])
        
        settings.extend([
            Header(text=get_string("message_reactions", "Message Reactions")),
            self.Quanta_switch("hide_star_reaction", get_string("hide_star_reaction", "Hide Star Reaction"), False, lambda v: self._apply_hooks(), link_alias="hide_star_reaction"),
            self.Quanta_text(text=get_string("star_reaction_hide_location", "Select from where"),on_click=lambda v: self._show_star_reaction_selector(),link_alias="star_reaction_hide_location") if self.get_setting("hide_star_reaction", False) else None,
            self.Quanta_text(text=get_string("pinned_reactions", "Pinned Reactions"),on_click=lambda v: self._open_pinned_reactions_settings_ui(),link_alias="pinned_reactions"),
        ])
        
        settings.extend([
            Header(text=get_string("message_actions", "Message Actions")),
            self.Quanta_switch("enable_confirmation_settings", get_string("enable_confirmation_settings", "Enable Confirmation Settings"), False, lambda v: self._apply_hooks(), on_long_click=lambda v: self._handle_long_click_with_enable("enable_confirmation_settings", show_confirmation_selector), subtext=get_string("long_press_to_configure_actions", "Long-press to configure actions")),
            self.Quanta_switch("enable_reply_private_chat", get_string("enable_reply_private_chat", "Enable Reply in Private Chat"), False, lambda v: self._update_reply_private_chat_menu_item(), link_alias="enable_reply_private_chat"),
            self.Quanta_switch("enable_reply_in_another_chat_shortcut", get_string("enable_reply_in_another_chat_shortcut", "Reply in Another Chat Shortcut"), False, lambda v: self._apply_hooks(), link_alias="enable_reply_in_another_chat_shortcut"),
            Divider(text=get_string("reply_in_another_chat_shortcut_info", "Long-press the Reply button to quickly reply to a message in another chat.")) if self.get_setting("enable_reply_in_another_chat_shortcut", False) else None,
            self.Quanta_switch("send_comments_after_forward", get_string("send_comments_after_forward", "Send Comments After Forward"), False, lambda v: self._apply_hooks(), link_alias="send_comments_after_forward"),
            self.Quanta_switch("enable_no_quote_forward", get_string("enable_no_quote_forward", "Enable No-Quote Forward"), False, lambda v: self._update_no_quote_forward_menu_item(), link_alias="enable_no_quote_forward"),
            self.Quanta_switch("enable_message_repeat", get_string("enable_message_repeat", "Enable Message Repeat"), False, lambda v: self._update_message_repeat_menu_item(), link_alias="enable_message_repeat"),
            Selector(key="swipe_action", text=get_string("swipe_action", "Message Swipe Action"), default=0, items=[get_string("swipe_reply", "Reply"), get_string("swipe_save", "Save"), get_string("swipe_translate", "Translate"), get_string("swipe_direct_share", "Direct Share")]),
            self.Quanta_switch("enable_edit_file_name", get_string("enable_edit_file_name", "Edit File Name"), False, lambda v: self._apply_hooks(), link_alias="enable_edit_file_name"),
            self.Quanta_switch("enable_delete_with_duration", get_string("enable_delete_with_duration", "Delete with Duration Selection"), False, lambda v: self._apply_delete_with_duration_hooks(), link_alias="enable_delete_with_duration"),
            Divider(text=get_string("delete_with_duration_info", "Adds duration selection when banning/restricting users after deleting their messages.")) if self.get_setting("enable_delete_with_duration", False) else None,
        ])
        
        settings.extend([
            Header(text=get_string("media_playback", "Media Playback")),
            self.Quanta_switch("dont_auto_play_enabled", get_string("dont_auto_play_enabled", "Don't Auto Play Next"), False, lambda v: self._apply_hooks(), on_long_click=lambda v: self._handle_long_click_with_enable("dont_auto_play_enabled", self._show_dont_auto_play_selector), subtext=get_string("long_press_to_select_message_types", "Long-press to select message types")),
            Divider(text=get_string("dont_auto_play_info", "Prevents automatic playback of the next voice or video message in a chat, giving you control over when media plays.")) if self.get_setting("dont_auto_play_enabled", False) else None,
            self.Quanta_switch("progress_timestamp_enabled", get_string("progress_timestamp_enabled", "Progress Timestamp"), False, lambda v: self._apply_hooks(), on_long_click=lambda v: self._handle_long_click_with_enable("progress_timestamp_enabled", self._show_progress_timestamp_selector), subtext=get_string("long_press_to_select_message_types", "Long-press to select message types")),
            Divider(text=get_string("progress_timestamp_info", "Shows the current playback time and total duration on voice and video messages for better media control.")) if self.get_setting("progress_timestamp_enabled", False) else None,
            self.Quanta_switch("enable_adaptive_audio_length", get_string("enable_adaptive_audio_length", "Adaptive Audio Message Length"), False, lambda v: self._apply_hooks(), link_alias="enable_adaptive_audio_length"),
            Divider(text=get_string("adaptive_audio_length_info", "The audio message bubble length will depend on the recording duration and automatically adjust to the screen width.")) if self.get_setting("enable_adaptive_audio_length", False) else None,
        ])
        
        settings.extend([
            Header(text=get_string("general", "General")),
            self.Quanta_switch("enable_goto_message", get_string("enable_goto_message", "Search by Message ID"), False, lambda v: self._apply_hooks(), link_alias="enable_goto_message"),
            self.Quanta_switch("enable_gif_spoiler", get_string("gif_spoiler_caption", "GIF Spoiler & Caption"), False, lambda v: self._apply_hooks(), link_alias="enable_gif_spoiler"),
            self.Quanta_switch("enable_ai_summarize", get_string("enable_ai_summarize", "Summarize Chat"), False, lambda v: self._apply_hooks(), link_alias="enable_ai_summarize"),
            self.Quanta_switch("enable_search_filter", get_string("enable_search_filter", "Search Filter"), False, lambda v: self._apply_hooks(), link_alias="enable_search_filter"),
            self.Quanta_switch("enable_old_forward", get_string("enable_old_forward", "Classic Forward Sheet"), False, lambda v: self._handle_forward_mode_change("enable_old_forward", v), link_alias="enable_old_forward"),
            self.Quanta_switch("enable_share_alert_forward", get_string("enable_share_alert_forward", "ShareAlert for All Forwards"), False, lambda v: self._handle_forward_mode_change("enable_share_alert_forward", v), link_alias="enable_share_alert_forward"),
            self.Quanta_switch("disable_link_preview", get_string("disable_link_preview", "Disable Link Preview"), False, lambda v: self._apply_hooks(), link_alias="disable_link_preview"),
            EditText(key="disable_link_preview_exclude_pattern", hint=get_string("disable_link_preview_pattern_hint", "Regex pattern to exclude"), default="", max_length=500, multiline=True) if self.get_setting("disable_link_preview", False) else None,
            Divider(text=get_string("disable_link_preview_info", "You can exclude links that match the regex pattern. Use regex101.com to check your pattern")) if self.get_setting("disable_link_preview", False) else None,
        ])
        
        settings.extend([
            Header(text=get_string("saved_messages", "Saved Messages")),
            self.Quanta_switch("enable_custom_saved_messages", get_string("enable_custom_saved_messages", "Custom Saved Messages"), False, lambda v: self._apply_hooks(), link_alias="enable_custom_saved_messages"),
        ])
        
        if self.get_setting("enable_custom_saved_messages", False):
            settings.append(
                self.Quanta_text(text=get_string("selected_chat", "Selected Chat") + f": {self._get_custom_saved_chat_name()}", on_click=lambda v: self._select_custom_saved_chat(), link_alias="select_custom_saved_chat")
            )
        
        settings.extend([
            Header(text=get_string("notifications", "Notifications")),
            self.Quanta_selector("notification_sound", get_string("notification_sound", "Sound Type"), [get_string("sound_disable", "Disable"), get_string("sound_default", "Default"), get_string("sound_ios", "iOS")], 1, lambda v: self._on_notification_sound_change(v), link_alias="notification_sound"),
            self.Quanta_selector("in_chat_vibration", get_string("in_chat_vibration", "In-Chat Vibration"), [get_string("vibrate_disable", "Disable"), get_string("vibrate_click", "1"), get_string("vibrate_wave", "2"), get_string("vibrate_keyboard", "3"), get_string("vibrate_long", "4")], 0, lambda v: self._on_vibration_change(v), link_alias="in_chat_vibration"),
        ])
        
        return settings

    def _create_others_settings(self):
        settings = []
        
        show_branch_selector = self.get_setting("show_branch_selector", False)
        
        settings.extend([
            Header(text=get_string("support", "Support Development")),
            Text(text=get_string("boosty", "Boosty"), icon="boosty_icon", on_click=lambda v: self._open_boosty()),
            Text(text=get_string("ton_keeper", "Ton Keeper"), icon="ton_icon", on_click=lambda v: self._copy_ton_address()),
            Text(text=get_string("know_more", "Know more"), icon="msg_info", accent=True, on_click=lambda v: self._show_donation_info()),
            Divider(text=get_string("another_services", "If the provided services are not available in your country, you can contact me via [direct message](https://t.me/luvztroy)")),

            


            Text(text=get_string("export_settings", "Export Settings"), icon="msg_photo_rotate_solar", on_click=lambda v: self._export_settings()),
            
            Text(text=get_string("reset_shared_preferences", "Reset Shared Preferences"), icon="msg_delete", red=True, on_click=lambda v: self._reset_all_preferences()),
            Divider(text=get_string("reset_preferences_description", "Reset all application settings including themes, language, notifications, and user configurations. This action cannot be undone.")),
        ])
        
        if show_branch_selector:
            settings.extend([
                Header(text=get_string("auto_update", "Auto Update")),
                self.Quanta_selector("update_branch", get_string("update_branch", "Update Branch"), [get_string("branch_main", "Main"), get_string("branch_beta", "Beta")], 0, link_alias="update_branch"),
                Divider(text=get_string("update_branch_info", "Select which branch to receive updates. Beta may contain experimental features and bugs."))
            ])
        
        settings.extend([
            self.Quanta_switch("enable_header_particles", get_string("enable_header_particles", "Enable Particle Effect"), default=True, icon="msg_settings_ny", link_alias="enable_header_particles"),
            Text(text=get_string("Language", "Language"), icon="msg_language", on_click=lambda v: self._open_language(), on_long_click=lambda v: self._toggle_branch_selector()),
        ])
        
        
        return settings

    def Quanta_switch(self, key, text, default=True, on_change=None, subtext=None, link_alias=None, on_long_click=None, icon=None):
        try:
            return Switch(key=key, text=text, icon=icon, link_alias=link_alias, default=default, on_change=on_change, subtext=subtext, on_long_click=on_long_click) if link_alias else Switch(key=key, text=text, icon=icon, default=default, on_change=on_change, subtext=subtext, on_long_click=on_long_click)
        except Exception:
            return Switch(key=key, text=text, icon=icon, default=default, on_change=on_change, subtext=subtext) if subtext else Switch(key=key, text=text, icon=icon, default=default)

    def Quanta_selector(self, key, text, items, default=0, on_change=None, subtext=None, link_alias=None):
        try:
            return Selector(key=key, text=text, items=items, link_alias=link_alias, default=default, on_change=on_change, subtext=subtext) if link_alias else Selector(key=key, text=text, items=items, default=default, on_change=on_change, subtext=subtext)
        except Exception:
            return Selector(key=key, text=text, items=items, default=default, on_change=on_change, subtext=subtext) if subtext else Selector(key=key, text=text, items=items, default=default)

    def Quanta_text(self, text, icon=None, link_alias=None, create_sub_fragment=None, on_click=None, accent=None):
        try:
            return Text(text=text, icon=icon, link_alias=link_alias, create_sub_fragment=create_sub_fragment, on_click=on_click, accent=accent) if link_alias else Text(text=text, icon=icon, create_sub_fragment=create_sub_fragment, on_click=on_click, accent=accent)
        except Exception:
            return Text(text=text, icon=icon, create_sub_fragment=create_sub_fragment, on_click=on_click, accent=accent) if any([icon, create_sub_fragment, on_click, accent]) else Text(text=text, icon=icon)

    def create_settings(self):
        return [
            Header(text=get_string("uitweaks_settings", "Categories")),
            
            self.Quanta_text(
                text=get_string("general", "General"),
                icon="msg_media_solar",
                link_alias="general",
                create_sub_fragment=self._create_general_settings
            ),
            
            self.Quanta_text(
                text=get_string("appearance", "Appearance"), 
                icon="msg_theme",
                link_alias="appearance",
                create_sub_fragment=self._create_appearance_settings   
            ),
            
            self.Quanta_text(
                text=get_string("chats", "Chats"),
                icon="msg_msgbubble3_solar",
                link_alias="chats",
                create_sub_fragment=self._create_chats_settings 
            ),
            
            self.Quanta_text(
                text=get_string("miscellaneous", "Miscellaneous"),
                icon="msg_reactions_solar",
                link_alias="miscellaneous",
                create_sub_fragment=self._create_miscellaneous_settings
            ),

            self.Quanta_text(
                text=get_string("others", "Others"),
                icon="msg_fave_solar",
                link_alias="others",
                create_sub_fragment=self._create_others_settings   
            ),
            
            
#            Text(
#                text=get_string("performance_warning", "Performance Warning"),
#                icon="msg_info_solar",
#                accent=True,
#                on_click=lambda view: self._show_performance_warning()
#            ),
            
            Header(text=get_string("links", "Links")),
            Text(text=get_string("channel", "Channel"), icon="msg_channel_solar", on_click=lambda v: self._open_channel()),
            Text(text=get_string("chats", "Chats"), icon="msg_groups_solar", on_click=lambda v: self._open_group()),
            Text(text=get_string("tips_and_tricks", "Tips and Tricks"), icon="menu_feature_reactions_solar", on_click=lambda v: self._open_tips()),
            Text(text=get_string("translate", "Translate"), icon="msg_translate_solar", on_click=lambda v: self._open_translation()),
        ]

    def _collect_all_settings_with_values(self):
        settings = {}
        
        def extract_settings(items):
            for item in items or []:
                if hasattr(item, 'key') and item.key:
                    settings[item.key] = self.get_setting(item.key, getattr(item, 'default', None))
                if hasattr(item, 'create_sub_fragment'):
                    try:
                        extract_settings(item.create_sub_fragment())
                    except:
                        pass
        
        extract_settings(self.create_settings())
        
        if hasattr(self, '_multi_selector_settings'):
            for key in self._multi_selector_settings:
                if key not in settings:
                    settings[key] = self.get_setting(key, False)
        
        return settings
    
    def _export_settings(self):
        export_plugin_settings("ui_tweaks", "UiTweaks", __version__)
    
    def _toggle_branch_selector(self):
        current = self.get_setting("show_branch_selector", False)
        self.set_setting("show_branch_selector", not current, reload_settings=True)
        
        if not current:
            BulletinHelper.show_success(get_string("branch_selector_enabled", "Branch selector enabled!"))
        else:
            BulletinHelper.show_info(get_string("branch_selector_disabled", "Branch selector hidden"))
    

    
    def _on_hide_archived_from_drawer_change(self, value):
        if value:
            self.set_setting("fab_action_selector", 1)
        else:
            self.set_setting("fab_action_selector", 0)
        self._apply_hooks()
    
    def _setup_quanta_file_hook(self):
        try:
            from java.lang import Class
            from java import jclass
            AndroidUtilitiesClass = Class.forName("org.telegram.messenger.AndroidUtilities")
            MessageObjectClass = Class.forName("org.telegram.messenger.MessageObject")
            ActivityClass = Class.forName("android.app.Activity")
            ResourcesProviderClass = Class.forName("org.telegram.ui.ActionBar.Theme$ResourcesProvider")
            open_for_view = AndroidUtilitiesClass.getDeclaredMethod(
                "openForView",
                MessageObjectClass,
                ActivityClass,
                ResourcesProviderClass,
                jclass("java.lang.Boolean").TYPE,
            )
            open_for_view.setAccessible(True)
            class OpenForViewHook:
                def __init__(hook_self):
                    hook_self.plugin = self
                def before_hooked_method(hook_self, param):
                    try:
                        if len(param.args) >= 1:
                            msg = param.args[0]
                            if msg and hasattr(msg, "getDocumentName"):
                                name = msg.getDocumentName()
                                if name and str(name).lower().endswith(".quanta"):
                                    hook_self.plugin._show_import_bottom_sheet(msg)
                                    param.setResult(False)
                    except Exception as e:
                        pass
            self.hook_method(open_for_view, OpenForViewHook())
        except Exception as e:
            pass
    
    def _show_import_bottom_sheet(self, message_object):
        def show_sheet():
            try:
                from com.exteragram.messenger.utils import ChatUtils
                from file_utils import read_file
                
                changes_count = 0
                try:
                    file_path = ChatUtils.getInstance().getPathToMessage(message_object)
                    if file_path:
                        content = read_file(file_path)
                        if content:
                            backup_data = json.loads(content)
                            
                            if backup_data.get("plugin") != "UiTweaks":
                                BulletinHelper.show_error(get_string("not_uitweaks_settings_file", "Not a UiTweaks settings file"))
                                return
                            
                            settings = backup_data.get("settings", {})
                            controller = PluginsController.getInstance()
                            engine = controller.getPluginEngine("ui_tweaks")
                            
                            if engine and settings:
                                current_settings = engine.getAllPluginSettings("ui_tweaks")
                                for key, value in settings.items():
                                    current_value = current_settings.get(key) if current_settings else None
                                    if current_value != value:
                                        changes_count += 1
                except Exception:
                    changes_count = 1
                
                if changes_count == 0:
                    BulletinHelper.show_error(get_string("settings_same_as_current", "It looks like the settings are the same as the current ones."))
                    return
                
                subtitle = get_string("changes_will_be_applied_singular", "{count} change will be applied to the current settings.").format(count=changes_count) if changes_count == 1 else get_string("changes_will_be_applied_plural", "{count} changes will be applied to the current settings.").format(count=changes_count)
                
                def on_import_click():
                    self._import_from_message(message_object)
                
                showupdatebottomsheet(
                    title=get_string("apply_settings_confirmation", "Are you sure you want to apply these settings?"),
                    subtitle=subtitle,
                    button_text=get_string("yes_apply", "Yes, apply"),
                    button2_text=get_string("no_leave_as_is", "No, leave as is"),
                    show_close_button=False,
                    raw_resource=R_tg.raw.email_check_inbox,
                    on_button_click=on_import_click,
                    on_button2_click=lambda: None
                )
                
            except Exception as e:
                pass
        
        run_on_ui_thread(show_sheet)
    
    def _import_from_message(self, message_object):
        try:
            from com.exteragram.messenger.utils import ChatUtils
            from file_utils import read_file
            
            file_path = ChatUtils.getInstance().getPathToMessage(message_object)
            if not file_path:
                return
            
            content = read_file(file_path)
            if not content:
                return
            
            backup_data = json.loads(content)

            if backup_data.get("plugin") != "UiTweaks":
                BulletinHelper.show_error(get_string("not_uitweaks_settings_file", "Not a UiTweaks settings file"))
                return
            
            settings = backup_data.get("settings", {})
            controller = PluginsController.getInstance()
            engine = controller.getPluginEngine("ui_tweaks")
            imported_count = 0
            
            if engine and settings:
                for key, value in settings.items():
                    try:
                        engine.setPluginSetting("ui_tweaks", key, value)
                        imported_count += 1
                    except Exception:
                        pass
                
                controller.loadPluginSettings("ui_tweaks")
            
            BulletinHelper.show_success(get_string("imported_settings_count", "Imported {count} settings").format(count=imported_count))
            
        except Exception as e:
            BulletinHelper.show_error(get_string("failed_to_import_settings", "Failed to import settings"))
    
    def _reset_all_preferences(self):
        fragment = get_last_fragment()
        if not fragment:
            return

        builder = AlertDialogBuilder(fragment.getParentActivity())
        builder.set_title(get_string("warning", "Warning"))
        builder.set_message(get_string("reset_confirmation", "Are you sure you want to reset?"))
        builder.set_positive_button(get_string("reset_all", "Reset All"), lambda bld, which: (self._perform_reset(), bld.dismiss()))
        builder.set_negative_button(get_string("cancel", "Cancel"), lambda bld, which: bld.dismiss())
        builder.show()

    def _perform_reset(self):
        try:
            from org.telegram.messenger import UserConfig
            account = UserConfig.selectedAccount
            
            settings = jclass("org.telegram.messenger.MessagesController").getInstance(account).getMainSettings()
            count = settings.getAll().size()
            log(f"Total preferences found: {count}")
            
            def perform_reset():
                settings.edit().clear().apply()
                jclass("org.telegram.messenger.BirthdayController").getInstance(account).check()
                log(f"Successfully cleared {count} preferences")
                from quantahut import restart_app
                restart_app()
            
            def undo_reset():
                log("Reset operation cancelled by user")
            
            BulletinHelper.show_undo(
                get_string("shared_preferences_reset_success", "Reset {count} preferences? App will restart.").format(count=count),
                on_undo=undo_reset,
                on_action=perform_reset,
                fragment=get_last_fragment()
            )
            
        except Exception as e:
            log(f"Reset failed: {str(e)}")
            BulletinHelper.show_error(get_string("reset_failed", "Reset failed: {error}").format(error=str(e)))
    
    def _restart_after_bulletin(self):
        from quantahut import restart_app
        restart_app()
    
    def _open_boosty(self):
        from android.content import Intent
        from android.net import Uri
        
        intent = Intent(Intent.ACTION_VIEW)
        intent.setData(Uri.parse("https://boosty.to/luvztroy/donate"))
        get_last_fragment().getParentActivity().startActivity(intent)
    
    def _copy_ton_address(self):
        clipboard = get_last_fragment().getParentActivity().getSystemService(Context.CLIPBOARD_SERVICE)
        clipboard.setPrimaryClip(ClipData.newPlainText("TON Address", "UQAZFPWF06gVehwcXlYDj3AWgx6i0x0VwUZOOUJ0A_gTcshN"))
        BulletinHelper.show_copied_to_clipboard(get_string("ton_address_copied", "TON address copied to clipboard"))
    
    def _open_channel(self):
        try:
            from client_utils import get_last_fragment
            from java import jclass
            fragment = get_last_fragment()
            if fragment:
                MessagesController = jclass("org.telegram.messenger.MessagesController")
                messages_controller = MessagesController.getInstance(0)
                messages_controller.openByUserName("QuantaPlugins", fragment, 1)
        except Exception as e:
            self.log(f"Error opening channel: {e}")
    
    def _open_group(self):
        try:
            from client_utils import get_last_fragment
            from java import jclass
            fragment = get_last_fragment()
            if fragment:
                MessagesController = jclass("org.telegram.messenger.MessagesController")
                messages_controller = MessagesController.getInstance(0)
                messages_controller.openByUserName("QuantaPlayground", fragment, 1)
        except Exception as e:
            self.log(f"Error opening group: {e}")
    
    def _open_tips(self):
        try:
            from client_utils import get_last_fragment
            from java import jclass
            fragment = get_last_fragment()
            if fragment:
                MessagesController = jclass("org.telegram.messenger.MessagesController")
                messages_controller = MessagesController.getInstance(0)
                messages_controller.openByUserName("QuantaTips", fragment, 1)
        except Exception as e:
            self.log(f"Error opening tips: {e}")

    def _open_translation(self):
        from android.content import Intent
        from android.net import Uri
        intent = Intent(Intent.ACTION_VIEW, Uri.parse("https://github.com/luvztroy/UiTweaks"))
        get_last_fragment().getParentActivity().startActivity(intent)     
    
    def _open_language(self):
        try:
            from com.exteragram.messenger.plugins.ui.components.templates import UniversalFragment
            from java import dynamic_proxy
            from org.telegram.ui.Components import UItem
            from org.telegram.messenger import R
            from ui.bulletin import BulletinHelper
            from base_plugin import PluginsController
            from hook_utils import get_private_field
            
            plugin = self
            
            class LanguageSelectorDelegate(dynamic_proxy(UniversalFragment.UniversalFragmentDelegate)):
                def __init__(self):
                    super().__init__()
                    self.fragment = None
                    try:
                        prefs = get_private_field(PluginsController.getInstance(), "preferences")
                        self.selected_language = prefs.getString("plugin_setting_ui_tweaks_selected_language", None) or "en"
                    except:
                        self.selected_language = "en"
                
                def getTitle(self):
                    return get_string("select_language", "Select Language")
                
                def beforeCreateView(self):
                    return None
                
                def afterCreateView(self, view):
                    return view
                
                def onFragmentCreate(self):
                    pass
                
                def onFragmentDestroy(self):
                    pass
                
                def onMenuItemClick(self, id):
                    pass
                
                def fillItems(self, items, adapter):
                    items.add(UItem.asHeader(get_string("available_languages", "Available Languages")))
                    
                    default_item = UItem.asRadio(-1, get_string("default", "Default"), get_string("english", "English"))
                    default_item.checked = (self.selected_language == "en" or not self.selected_language)
                    items.add(default_item)
                    
                    languages = quantahut.available_languages if quantahut and hasattr(quantahut, 'available_languages') else []
                    if not languages:
                        items.add(UItem.asButton(-2, get_string("loading", "Loading...")))
                    else:
                        for i, lang in enumerate(languages):
                            lang_code = lang.get("code", "")
                            
                            if lang_code == "en":
                                continue
                            
                            native_name = lang.get("display_name", lang_code)

                            try:
                                from java.util import Locale
                                clean_code = lang_code.replace("-raw", "")
                                parts = clean_code.split("-")
                                if len(parts) == 1:
                                    locale = Locale(parts[0])
                                else:
                                    locale = Locale(parts[0], parts[1] if len(parts) > 1 else "")
                                english_name = locale.getDisplayLanguage(Locale.ENGLISH)
                            except:
                                english_name = lang_code.replace("-raw", "").title()
                            
                            item = UItem.asRadio(i, english_name, native_name)
                            item.checked = (lang_code == self.selected_language)
                            items.add(item)
                    
                    items.add(UItem.asShadow(None))
                    items.add(UItem.asHeader(get_string("localization_options", "Localization Options")))
                    items.add(UItem.asButton(-3, get_string("refresh_localization", "Refresh Localization")))
                    items.add(UItem.asShadow(get_string("refresh_localization_info", "Force update the localization for the selected language.")))
                
                def onClick(self, item, view, position, x, y):
                    item_id = item.id
                    
                    def save_lang(code):
                        try:
                            prefs = get_private_field(PluginsController.getInstance(), "preferences")
                            prefs.edit().putString("plugin_setting_ui_tweaks_selected_language", code).apply()
                        except:
                            pass
                    
                    def refresh_and_finish(msg):
                        PluginsController.getInstance().loadPluginSettings("ui_tweaks")
                        PluginsController.getInstance().loadPluginSettings("quantahut")
                        NotificationCenter.getGlobalInstance().postNotificationName(NotificationCenter.pluginSettingsRegistered, "ui_tweaks")
                        NotificationCenter.getGlobalInstance().postNotificationName(NotificationCenter.pluginSettingsRegistered, "quantahut")
                        try:
                            if quantahut and hasattr(quantahut, 'QuantaHut') and hasattr(quantahut.QuantaHut, 'instance') and quantahut.QuantaHut.instance:
                                quantahut.QuantaHut.instance._update_restart_menu_item()
                        except:
                            pass
                        if self.fragment:
                            self.fragment.finishFragment()
                        BulletinHelper.show_simple(msg, R.raw.contact_check, get_last_fragment())
                    
                    if item_id == -1:
                        self.selected_language = "en"
                        save_lang("en")
                        refresh_and_finish(get_string("language_changed_to", "Language changed to") + " English")
                        return
                    
                    if item_id == -3:
                        lang_code = self.selected_language or "en"
                        if lang_code == "en":
                            BulletinHelper.show_simple(get_string("no_localization_for_english", "No localization needed for English"), R.raw.info, self.fragment)
                            return
                        
                        BulletinHelper.show_simple(get_string("refreshing_localization", "Refreshing localization..."), R.raw.info, self.fragment)
                        
                        def do_refresh():
                            try:
                                quantahut.github_localization.download_localization("UiTweaks", lang_code, force_refresh=True)
                                run_on_ui_thread(lambda: refresh_and_finish(get_string("localization_refreshed", "Localization refreshed successfully")))
                            except Exception as e:
                                err_msg = str(e)
                                plugin.log(f"Refresh localization error: {err_msg}")
                                run_on_ui_thread(lambda: BulletinHelper.show_simple(get_string("refresh_failed", "Refresh failed") + f": {err_msg}", R.raw.error, self.fragment))
                        
                        import threading
                        threading.Thread(target=do_refresh, daemon=True).start()
                        return
                    
                    languages = quantahut.available_languages if quantahut and hasattr(quantahut, 'available_languages') else []
                    if item_id >= 0 and item_id < len(languages):
                        lang = languages[item_id]
                        lang_code = lang.get("code")
                        lang_display = lang.get("display_name", lang_code)
                        self.selected_language = lang_code
                        save_lang(lang_code)
                        
                        if self.fragment:
                            try:
                                self.fragment.listView.getAdapter().update(False)
                            except:
                                pass
                        
                        def do_download():
                            try:
                                quantahut.github_localization.download_localization("UiTweaks", lang_code)
                                run_on_ui_thread(lambda: refresh_and_finish(get_string("language_changed_to", "Language changed to") + f" {lang_display}"))
                            except:
                                run_on_ui_thread(lambda: BulletinHelper.show_simple(get_string("download_failed", "Download failed"), R.raw.error, self.fragment))
                        
                        import threading
                        threading.Thread(target=do_download, daemon=True).start()
                
                def onLongClick(self, item, view, position, x, y):
                    return False
                
                def onBackPressed(self):
                    return None
            
            delegate = LanguageSelectorDelegate()
            fragment = UniversalFragment(delegate)
            delegate.fragment = fragment
            last_fragment = get_last_fragment()
            if last_fragment:
                last_fragment.presentFragment(fragment)
        except Exception as e:
            self.log(f"Error opening language selector: {e}")
    
    def _show_donation_info(self):
        showupdatebottomsheet(
            title=get_string("donation_info_title", "About Donations"),
            subtitle=get_string("donation_info_subtitle", "Supporting UiTweaks Development"),
            description=get_string("donation_info_description", 
                "Donations are a way to appreciate the effort behind this Plugin. They dont grant special privileges, though you may request a feature as thanks."),
            github_url=None,
            plugin_name="UiTweaks_DonationInfo",
            sticker_pack="luvztroyIcons",
            sticker_index=15,
            button_text=get_string("understood", "Understood"),
            bottom_text=get_string("donation_info_footer", "Thank you for considering supporting the development of UiTweaks!"),
            show_user_avatar=False,
            description_centered=True
        )
    
    def on_app_event(self, event_type: AppEvent):
        if event_type == AppEvent.START:
            if self.get_setting("hidefolders_enabled", False):
                try:
                    self._hook_folder_visibility()
                    
                    from android.os import Handler, Looper
                    from android_utils import R
                    
                    def post_notification():
                        try:
                            NotificationCenter.getInstance(UserConfig.selectedAccount).postNotificationName(
                                NotificationCenter.dialogFiltersUpdated
                            )
                        except Exception:
                            pass
                    
                    Handler(Looper.getMainLooper()).postDelayed(R(post_notification), 100)
                except Exception:
                    pass
        
        elif event_type == AppEvent.RESUME:
            if self.get_setting("hide_archived_chats", False) and self.get_setting("hide_archived_from_drawer", False):
                try:
                    from android.os import Handler, Looper
                    from android_utils import R
                    
                    def refresh_drawer():
                        try:
                            from org.telegram.ui import LaunchActivity
                            if (hasattr(LaunchActivity, 'instance') and LaunchActivity.instance):
                                drawer_adapter = get_private_field(LaunchActivity.instance, "drawerLayoutAdapter")
                                if drawer_adapter and hasattr(drawer_adapter, 'notifyDataSetChanged'):
                                    drawer_adapter.notifyDataSetChanged()
                        except Exception:
                            pass
                    
                    Handler(Looper.getMainLooper()).postDelayed(R(refresh_drawer), 500)
                except Exception:
                    pass

    def _check_for_updates_on_load(self):
        def delayed_check():
            time.sleep(5)
            
            try:
                if hasattr(quantahut, 'QuantaHut'):
                    qh_instance = quantahut.QuantaHut.instance if hasattr(quantahut.QuantaHut, 'instance') else None
                    if qh_instance and hasattr(qh_instance, 'update_available') and qh_instance.update_available:
                        self.log("QuantaHut update is available, skipping UiTweaks update check")
                        return
            except Exception:
                pass
            
            self.log("Auto-checking for UiTweaks updates...")
            self._check_for_updates(show_on_load=True)
        
        thread = threading.Thread(target=delayed_check)
        thread.daemon = True
        thread.start()
    
    def _check_for_updates(self, show_on_load=False):
        if self.checking_update:
            self.log("Already checking for updates...")
            return
        
        self.checking_update = True
        
        def check_thread():
            try:
                self.log("Checking for UiTweaks updates from GitHub...")
                
                branch_index = self.get_setting("update_branch", 0)
                branch = "main" if branch_index == 0 else "Beta"
                
                version_url = f"https://raw.githubusercontent.com/luvztroy/Auto-Update/refs/heads/{branch}/changelog.json"
                self.log(f"Fetching from {branch} branch: {version_url}")
                
                with urllib.request.urlopen(version_url, timeout=10) as response:
                    if response.getcode() != 200:
                        raise Exception(f"HTTP {response.getcode()}")
                    
                    version_data = json.loads(response.read().decode('utf-8'))
                    
                    self.latest_version = version_data.get("version", "0.0.0")
                    self.changelog = version_data.get("changelog_text", "No changelog available")
                    sticker_pack = version_data.get("sticker_pack")
                    sticker_index = version_data.get("sticker_index")
                    sticker_circle = version_data.get("sticker_circle", False)
                    sticker_size = version_data.get("sticker_size", 160)
                    
                    self.download_url = f"https://raw.githubusercontent.com/luvztroy/Auto-Update/refs/heads/{branch}/UiTweaks.plugin"
                    
                    self.log(f"Latest version: {self.latest_version}")
                    self.log(f"Current version: {__version__}")
                    
                    if self._is_newer_version(self.latest_version, __version__):
                        self.update_available = True
                        self.log("UiTweaks update available!")
                        
                        if show_on_load:
                            run_on_ui_thread(lambda: self._show_update_bottom_sheet(
                                sticker_pack, sticker_index, sticker_circle, sticker_size
                            ))
                    else:
                        self.update_available = False
                        self.log("UiTweaks is up to date")
                
            except Exception as e:
                self.log(f"Error checking UiTweaks updates: {e}")
            finally:
                self.checking_update = False
        
        thread = threading.Thread(target=check_thread)
        thread.daemon = True
        thread.start()
    
    def _compare_versions(self, version1: str, version2: str) -> int:
        try:
            def clean_version(version):
                version = version.split('-')[0].split(' ')[0].strip()
                return version
            
            v1_clean = clean_version(version1)
            v2_clean = clean_version(version2)
            
            v1_parts = [int(x) for x in v1_clean.split('.')]
            v2_parts = [int(x) for x in v2_clean.split('.')]
            
            max_len = max(len(v1_parts), len(v2_parts))
            v1_parts += [0] * (max_len - len(v1_parts))
            v2_parts += [0] * (max_len - len(v2_parts))
            
            if v1_parts > v2_parts:
                return 1
            elif v1_parts < v2_parts:
                return -1
            else:
                return 0
        except Exception as e:
            self.log(f"Error comparing versions: {e}")
            return 0
    
    def _is_newer_version(self, latest: str, current: str) -> bool:
        return self._compare_versions(latest, current) > 0
    
    def _show_update_bottom_sheet(self, sticker_pack, sticker_index, sticker_circle, sticker_size):
        if not self.update_available:
            return
        
        self.log("Showing UiTweaks update bottom sheet")
        
        try:
            showupdatebottomsheet(
                title=f"UiTweaks Update: v{self.latest_version}",
                subtitle=f"Current version: {__version__}",
                description=self.changelog,
                sticker_pack=sticker_pack,
                sticker_index=sticker_index,
                sticker_circle=sticker_circle,
                sticker_size=sticker_size,
                button_text="Update Now",
                show_close_button=False,
                on_button_click=self._download_and_install_update
            )
        except Exception as e:
            self.log(f"Error showing UiTweaks update sheet: {e}")
    
    def _download_and_install_update(self):
        self.log("Starting UiTweaks update download...")
        BulletinHelper.show_info("Downloading UiTweaks update...")
        
        def download_thread():
            try:
                with urllib.request.urlopen(self.download_url, timeout=30) as response:
                    plugin_content = response.read()
                
                from com.exteragram.messenger.plugins import PluginsController, PluginsConstants
                from org.telegram.messenger import ApplicationLoader, Utilities
                from java import dynamic_proxy, jclass
                
                plugins_dir = os.path.join(str(ApplicationLoader.applicationContext.getFilesDir()), "plugins")
                temp_file = os.path.join(plugins_dir, "ui_tweaks_update.tmp")
                
                with open(temp_file, 'wb') as f:
                    f.write(plugin_content)
                
                try:
                    from org.telegram.messenger import LocaleController
                    lang = LocaleController.getInstance().getCurrentLocaleInfo().getLangCode()
                    if lang != "en":
                        quantahut.github_localization.download_localization("UiTweaks", lang)
                except:
                    pass
                
                version = self.latest_version
                
                class Callback(dynamic_proxy(Utilities.Callback)):
                    def run(self_cb, error):
                        if error:
                            run_on_ui_thread(lambda: BulletinHelper.show_error(f"Update failed: {error}"))
                        else:
                            run_on_ui_thread(lambda: BulletinHelper.show_success(f"UiTweaks updated to v{version}!"))
                        try:
                            os.remove(temp_file)
                        except:
                            pass
                
                class Runnable(dynamic_proxy(jclass("java.lang.Runnable"))):
                    def run(self_r):
                        PluginsController.engines.get(PluginsConstants.PYTHON).loadPluginFromFile(temp_file, None, Callback())
                
                Utilities.pluginsQueue.postRunnable(Runnable())
                
            except Exception as e:
                run_on_ui_thread(lambda: BulletinHelper.show_error(f"Update failed: {e}"))
        
        threading.Thread(target=download_thread, daemon=True).start()


    def on_plugin_unload(self):
        self.memory_check_running = False
        
        self._unhook_all()
        
        self.current_chat_activity = None
        self.current_back_button = None
        self.counter_views.clear()
        
        self._remove_reply_private_chat_menu_item()
        self._remove_no_quote_forward_menu_item()
        self._remove_message_repeat_menu_item()
        self._no_quote_buttons_created.clear()
        
        if hasattr(self, '_goto_plugin_menu_id') and self._goto_plugin_menu_id:
            self.remove_menu_item(self._goto_plugin_menu_id)
            self._goto_plugin_menu_id = None
        
        if hasattr(self, 'hook_gif_spoiler_ref') and self.hook_gif_spoiler_ref:
            if hasattr(self.hook_gif_spoiler_ref, 'cleanup_menu_items'):
                self.hook_gif_spoiler_ref.cleanup_menu_items()
        
        try:
            from quantahut import cleanup_quantahut_hooks
            cleanup_quantahut_hooks(self)
        except Exception:
            pass
            
        if hasattr(self, 'recent_manager') and self.recent_manager:
            self.recent_manager.cleanup()
            self.recent_manager.recent_dialogs.clear()
        
        if hasattr(self, 'popup_manager') and self.popup_manager:
            self.popup_manager.destroy()
        
        self._cleanup_activity_resources()
        
        if hasattr(self, 'contact_status_activity_state'):
            self.contact_status_activity_state.clear()
        
        if hasattr(self, '_class_cache'):
            self._class_cache.clear()



    def _cleanup_activity_resources(self):
        try:
            sets_to_clear = [
                'hooked_activities',
                'added_send_media_buttons',
                '_no_quote_buttons_created',
                '_select_all_added_modes',
                '_goto_items_added',
                'ai_summarize_hooked_activities',
                'chat_action_bar_hooked_activities',
            ]
            for set_name in sets_to_clear:
                if hasattr(self, set_name):
                    s = getattr(self, set_name)
                    if s:
                        s.clear()
            
            dicts_to_clear = [
                '_no_quote_button_cache',
                'search_filter_buttons',
                'contact_status_activity_state',
            ]
            for dict_name in dicts_to_clear:
                if hasattr(self, dict_name):
                    d = getattr(self, dict_name)
                    if d:
                        d.clear()
        except Exception as e:
            self.log(f"Error cleaning up activity resources: {e}")

    def _get_class(self, class_name: str):
        if class_name in self._class_cache:
            return self._class_cache[class_name]
        
        cls = find_class(class_name)
        if cls is not None:
            self._class_cache[class_name] = cls
        return cls


    def _open_archived_chats(self, context):
        from client_utils import get_last_fragment
        from java import jclass
        
        fragment = get_last_fragment()
        if fragment:
            bundle = jclass("android.os.Bundle")()
            bundle.putInt("folderId", 1)
            
            dialogs_activity = jclass("org.telegram.ui.DialogsActivity")(bundle)
            fragment.presentFragment(dialogs_activity)
    
    def _open_archived_chats_from_fab(self, dialogs_activity):
        from java import jclass
        
        try:
            bundle = jclass("android.os.Bundle")()
            bundle.putInt("folderId", 1)
            
            archived_dialogs_activity = jclass("org.telegram.ui.DialogsActivity")(bundle)
            dialogs_activity.presentFragment(archived_dialogs_activity)
        except Exception as e:
            pass
    def _unhook_all(self):
        self.log("Unhooking all methods")
        for ref_attr in (
            "hook_dialogs_ref",
            "hook_dialogs_destroy_ref",
            "hook_dialog_cell_ref",
            "hook_photo_cell_ref",
            "hook_photo_cell_set_entry_ref",
            "hook_swipe_prevention_ref",
            "hook_star_reaction_menu_ref",
            "hook_star_reaction_visible_list_ref",
            "hook_star_reaction_gradient_ref",
            "hook_star_reaction_layout_draw_ref",
            "hook_link_confirmation_ref",
            "hook_article_viewer_ref",
            "hook_webapp_swipe_prevention_ref",
            "hook_download_manager_ref",
            "hook_proxy_button_ref",
            "hook_phone_number_ref",
            "hook_messages_controller_ref",
            "hook_update_bot_button_ref",
            "hook_voice_message_control_ref",
            "hook_voice_message_time_display_ref",
            "hook_video_message_control_ref",
            "hook_forward_confirmation_ref",
            "hook_join_confirmation_ref",
            "hook_send_typing_refs",
            "hook_gif_spoiler_ref",
            "hook_gif_dismiss_ref",
            "hook_process_external_url_ref",
            "hook_fill_action_mode_menu_ref",
            "hook_perform_menu_action_ref",
            "hook_drawer_icon_ref",

            "hook_call_buttons_ref",
            "hook_group_voice_chat_icon_ref",
            "hook_message_preview_view_ref",
            "hook_browser_open_url_ref",
            "hook_disable_auto_web_login_ref",
            "hook_do_not_share_phone_number_ref",
            "hook_prefer_common_groups_tab_ref",
            "hook_non_clickable_dispatch_ref",
            "hook_non_clickable_present_ref",
            "hook_non_clickable_present_ref2",
            "hook_birthday_alert_ref",
            "hook_code_formatting_ref",
            "hook_sender_select_popup_ref",
            "hook_swipe_disable_ref",
            "hook_share_sheet_folders_ref",
            "hook_disable_topic_swipe_ref",
            "hook_account_visibility_drawer_ref",
            "hook_account_visibility_profile_ref",
            "contact_status_update_rows_hook",
            "contact_status_get_item_view_type_hook",
            "contact_status_create_view_holder_hook",
            "contact_status_bind_view_holder_hook",
            "safe_mode_hook_ref",
            "hook_folder_visibility_ref",
            "hook_search_by_user_id_ref",
            "hook_gift_drawer_reset_ref",
            "hook_no_quote_pause_ref",
            "hook_gift_drawer_click_ref",
            "hook_gift_drawer_cell_ref",
            "hook_ai_summarize_create_view_ref",
            "hook_ai_summarize_item_click_ref",
            "delete_with_duration_fillitems_ref",
            "delete_with_duration_onclick_ref",
            "hook_ai_role_limit_constructor_ref",
            "hook_ai_role_limit_settext_ref",
            "hook_select_all_media_ref",
            "hook_always_visible_schedule_button_ref",
            "hook_remove_greeting_sticker_ref",
            "hook_remove_https_from_links_ref",
            "hook_sleep_timer_ref",
            "hook_sleep_timer_click_ref",
            "hook_adaptive_audio_ref",
            "hook_music_speed_control_ref",
            "hook_custom_saved_messages_ref",
            "hook_disable_emoji_suggestions_ref",
            "hook_message_swipe_action_ref",
            "hook_join_request_direct_profile_ref",
            "hook_search_filter_open_search_ref",
            "hook_search_filter_send_request_ref",
            "create_view_hook_ref",
            "destroy_hook_ref",
            "hook_reply_in_another_chat_layout_ref",
            "hook_reply_in_another_chat_dialogs_ref",
            "allow_reply_button_hook_ref",
            "hook_check_send_button_ref",
            "hook_unread_count_ref",
            "hook_add_to_folder_all_tabs_ref",
            "hook_play_sound_ref",
            "hook_soundpool_load_ref",
            "hook_search_links_ref",
            "hook_enter_view_constructor_ref",
            "hook_send_message_params_ref",
            "hook_reactions_container_ref",
            "hook_share_alert_forward_open_ref",
            "hook_share_alert_forward_process_ref",
            "hook_unify_username_behavior_process_click_ref",
            "hook_unify_username_behavior_bind_ref",
            "hook_edit_file_name_ref",
            "hook_send_comments_after_forward_ref",
        ):
            ref = getattr(self, ref_attr, None)
            if ref:
                if isinstance(ref, list):
                    for r in ref:
                        if r:
                            self.unhook_method(r)
                else:
                    self.unhook_method(ref)
                setattr(self, ref_attr, None)
        
        if self.unhook_send_message:
            self.unhook_method(self.unhook_send_message)
            self.unhook_send_message = None
        if hasattr(self, 'unhook_deeplink') and self.unhook_deeplink:
            self.unhook_method(self.unhook_deeplink)
            self.unhook_deeplink = None
        if hasattr(self, 'unhook_set_command') and self.unhook_set_command:
            self.unhook_method(self.unhook_set_command)
            self.unhook_set_command = None
        if self._unhook_layout:
            self.unhook_method(self._unhook_layout)
            self._unhook_layout = None
        if hasattr(self, 'hook_chat_activity_cleanup_ref') and self.hook_chat_activity_cleanup_ref:
            self.unhook_method(self.hook_chat_activity_cleanup_ref)
            self.hook_chat_activity_cleanup_ref = None

    def _hook_chat_activity_cleanup(self):
        try:
            if self.hook_chat_activity_cleanup_ref:
                return
            ChatActivityClass = self._get_class("org.telegram.ui.ChatActivity")
            if not ChatActivityClass:
                return
            destroy_method = ChatActivityClass.getClass().getDeclaredMethod("onFragmentDestroy")
            destroy_method.setAccessible(True)
            self.hook_chat_activity_cleanup_ref = self.hook_method(
                destroy_method,
                ChatActivityCleanupHook(self)
            )
        except Exception:
            pass

    def _apply_hooks(self):
        self._unhook_all()
        self._hook_chat_activity_cleanup()
        try:
            if (self.get_setting("hide_bot_open", False) or 
                self.get_setting("fab_settings_shortcut", False)):
                self._hook_dialogs_activity()
                if self.get_setting("hide_bot_open", False):
                    self._hook_dialog_cell()
            if self.get_setting("hide_hd_icon", False):
                self._hook_photo_cell()
            if self.get_setting("prevent_swipe_while_editing", False) or self.get_setting("prevent_swipe_while_typing", False):
                self._hook_swipe_prevention()
            if self.get_setting("disable_article_viewer_swipe", False):
                self._hook_article_viewer()
            if self.get_setting("prevent_webapp_swipe_down", False):
                self._hook_webapp_swipe_prevention()
            if self.get_setting("enable_code_formatting", False):
                self._hook_code_formatting()
            if self.get_setting("hide_star_reaction", False):
                hide_menu = self.get_setting("star_reaction_hide_menu", False)
                hide_cells = self.get_setting("star_reaction_hide_cells", False)
                
                if hide_menu: 
                    self._hook_star_reaction_menu()
                
                if hide_cells: 
                    self._hook_star_reaction_layout()
            else:
                self._remove_star_reaction_hooks()
            if self.get_setting("always_show_download_manager", False):
                self._hook_download_manager()
            if self.get_setting("always_show_proxy_button", False):
                self._hook_proxy_button()
            if self.get_setting("hide_phone_number", False):
                self._hook_phone_number()
            if self.get_setting("hide_archived_chats", False):
                if self.get_setting("hide_archived_from_drawer", False):
                    self._hook_messages_controller()
                else:
                    self._hook_messages_controller()
                    self._hook_chat_utils_has_archived()
                    self._hook_extera_config_archived()
            if self.get_setting("enable_ai_summarize", False):
                self._hook_ai_summarize()
            if self.get_setting("enable_goto_message", False):
                self._hook_goto_message()
            if self.get_setting("enable_delete_with_duration", False):
                self._hook_delete_with_duration()
            if self.get_setting("dont_auto_play_enabled", False):
                if self.get_setting("dont_auto_play_next_voice", False):
                    self._hook_voice_message_control()
                if self.get_setting("dont_auto_play_next_video", False):
                    self._hook_video_message_control()
            if self.get_setting("progress_timestamp_enabled", False):
               self._hook_voice_message_time_display()
            if self.get_setting("unread_badge_on_back_button", False):
                self._hook_unread_badge()
            if self.get_setting("hide_bot_button", False):
                self._hook_update_bot_button()
            if self.get_setting("confirm_forward", True):
                self._hook_forward_confirmation()
            if self.get_setting("confirm_join_chat", False):
                self._hook_join_confirmation()
            if self.get_setting("enable_no_quote_forward", False):
                self._hook_actions_buttons_layout()
            if self.get_setting("typing_instead_sticker", False):
                self._hook_send_typing_method()

            if self.get_setting("hide_birthday_alert", False):
                self._hook_birthday_alert()
            
            if self.get_setting("disable_auto_web_login", False):
                self._hook_disable_auto_web_login()
            if self.get_setting("do_not_share_phone_number", False):
                self._hook_do_not_share_phone_number()
            if self.get_setting("prefer_common_groups_tab", False):
                self._hook_prefer_common_groups_tab()
            
            if self.get_setting("enable_gif_spoiler", False):
                self._hook_gif_spoiler()
            
            if self.get_setting("enable_confirmation_settings", False) and self.get_setting("confirm_external_links", False):
                self._hook_process_external_url()
            
            if self.get_setting("enable_message_preview_enhancement", False):
                self._hook_message_preview_view()
            
            if self.get_setting("enable_sender_select_enhancement", False):
                self._hook_sender_select_popup()
            
            if self.get_setting("enable_swipe_disable", False):
                self._hook_swipe_disable()
            
            if self.get_setting("enable_share_sheet_folders", False):
                self._hook_share_sheet_folders()
            
            if self.get_setting("enable_non_clickable_preview", False):
                self._hook_non_clickable_preview()
            
            if self.get_setting("disable_topics_swipe", False):
                self._hook_disable_topic_swipe()
            
            if self.get_setting("enable_account_visibility", False):
                self._hook_account_visibility()
            
            if self.get_setting("enable_add_to_folder_all_tabs", False):
                self._hook_add_to_folder_all_tabs()
            
            if self.get_setting("unread_chat_count", False) or self.get_setting("unread_message_count", False) or self.get_setting("exclude_archived_from_count", False):
                self._hook_unread_count()
            
            if self.get_setting("enable_contact_status_in_profile", False):
                self._hook_contact_status_in_profile()
            
            if self.get_setting("enable_unify_username_behavior", False):
                self._hook_unify_username_behavior()
            
            if self.get_setting("enable_safe_mode", False):
                self._hook_safe_mode()
            
            if self.get_setting("hidefolders_enabled", False):
                self._hook_folder_visibility()
            
            if self.get_setting("enable_search_by_user_id", False):
                self._hook_search_by_user_id()
            
            if self.get_setting("quick_access_gift_market", False):
                self._hook_gift_drawer()
            
            if self.get_setting("enable_ai_role_limit", False):
                self._hook_ai_role_limit()
            
            if self.get_setting("enable_select_all_media", False):
                self._hook_select_all_media()
            
            if self.get_setting("always_visible_schedule_button", False):
                self._hook_always_visible_schedule_button()

            if self.get_setting("enable_sleep_timer", False):
                self._hook_sleep_timer()
            
            if self.get_setting("enable_adaptive_audio_length", False):
                self._hook_adaptive_audio_length()
            
            if self.get_setting("enable_music_speed_control", False):
                self._hook_music_speed_control()
            
            if self.get_setting("enable_custom_saved_messages", False):
                self._hook_custom_saved_messages()
            
            if self.get_setting("disable_emoji_suggestions", False):
                self._hook_disable_emoji_suggestions()
            
            if self.get_setting("enable_message_repeat", False):
                self._update_message_repeat_menu_item()
            
            if self.get_setting("swipe_action", 0) != 0:
                self._hook_message_swipe_action()
            
            if self.get_setting("remove_greeting_sticker", False):
                self._hook_remove_greeting_sticker()
            
            if self.get_setting("remove_https_from_links", False):
                self._hook_remove_https_from_links()
            
            if self.get_setting("enable_join_request_direct_profile", False):
                self._hook_join_request_direct_profile()
            
            if self.get_setting("enable_search_filter", False):
                self._hook_search_filter()
            
            if self.get_setting("notification_sound", 1) != 1 or self.get_setting("in_chat_vibration", 0) != 0:
                self._ensure_ios_sound()
                self._hook_play_in_chat_sound()
                if self.get_setting("notification_sound", 1) == 2:
                    self._hook_soundpool_load()
            
            if self.get_setting("disable_link_preview", False):
                self._hook_disable_link_preview()
            
            if self.get_setting("pinned_reactions_enabled_chats", "true") == "true" or self.get_setting("pinned_reactions_enabled_channels", "true") == "true":
                self._hook_pinned_reactions()
            
            if self.get_setting("enable_share_alert_forward", False):
                self._hook_share_alert_forward()
            
            if self.get_setting("enable_edit_file_name", False):
                self._hook_edit_file_name()
            
            if self.get_setting("send_comments_after_forward", False):
                self._hook_send_comments_after_forward()

        except Exception as e:
            pass


    
    
    def _add_reply_private_chat_menu_item(self):
        try:
            self.reply_private_chat_menu_handle = quantahut.utilities.register_message_menu_item(
                text=get_string("reply_in_private_chat", "Reply in private chat"),
                option_id=2033,
                icon_res=R_tg.drawable.msg_reply_solar,
                condition_predicate=lambda m: (m is not None and not m.isOut() and self._is_group_chat(m) and hasattr(m.messageOwner.from_id, 'user_id') and m.messageOwner.from_id.user_id),
                on_click=self._on_reply_private_chat_click,
                insert_at_top=True
            )
        except Exception:
            pass

    def _remove_reply_private_chat_menu_item(self):
        try:
            if hasattr(self, 'reply_private_chat_menu_handle') and self.reply_private_chat_menu_handle:
                quantahut.utilities.unregister_message_menu_item(self.reply_private_chat_menu_handle)
                self.reply_private_chat_menu_handle = None
        except Exception:
            pass

    def _update_reply_private_chat_menu_item(self):
        if self.get_setting("enable_reply_private_chat", False):
            if not hasattr(self, 'reply_private_chat_menu_item_id') or not self.reply_private_chat_menu_item_id:
                self._add_reply_private_chat_menu_item()
        else:
            self._remove_reply_private_chat_menu_item()

    def _is_group_chat(self, message):
        try:
            if not message or not message.messageOwner:
                return False
            chat_id = message.messageOwner.peer_id.channel_id if hasattr(message.messageOwner.peer_id, 'channel_id') and message.messageOwner.peer_id.channel_id else message.messageOwner.peer_id.chat_id if hasattr(message.messageOwner.peer_id, 'chat_id') and message.messageOwner.peer_id.chat_id else 0
            return chat_id != 0
        except Exception:
            return False
    
    def _on_reply_private_chat_click(self, chat_activity, message):
        try:
            if not message or not chat_activity:
                return
            sender_id = message.messageOwner.from_id.user_id if message.messageOwner.from_id else 0
            if not sender_id:
                return
            from android.os import Bundle
            chat_args = Bundle()
            chat_args.putLong("user_id", sender_id)
            private_chat = ChatActivity(chat_args)
            chat_activity.presentFragment(private_chat)
            try:
                if (getattr(private_chat, 'chatActivityEnterView', None) is not None and 
                    getattr(chat_activity, 'chatActivityEnterView', None) is not None):
                    original_text = chat_activity.chatActivityEnterView.getFieldText()
                    if original_text:
                        private_chat.chatActivityEnterView.setFieldText(original_text)
                private_chat.replyingTopMessage = message
                private_chat.showFieldPanelForReplyQuote(message, None)
            except Exception:
                pass
        except Exception:
            pass
    
    def _hook_reply_in_another_chat(self):
        try:
            LayoutClass = self._get_class("org.telegram.ui.Components.chat.layouts.ChatActivityActionsButtonsLayout")
            if LayoutClass is None:
                return
            
            ContextClass = self._get_class("android.content.Context")
            ResourcesProviderClass = self._get_class("org.telegram.ui.ActionBar.Theme$ResourcesProvider")
            ColorProviderClass = self._get_class("org.telegram.ui.Components.blur3.drawable.color.BlurredBackgroundColorProvider")
            BlurredBackgroundDrawableViewFactoryClass = self._get_class("org.telegram.ui.Components.blur3.BlurredBackgroundDrawableViewFactory")
            
            constructor = LayoutClass.getClass().getDeclaredConstructor(
                ContextClass,
                ResourcesProviderClass,
                ColorProviderClass,
                BlurredBackgroundDrawableViewFactoryClass
            )
            constructor.setAccessible(True)
            self.hook_reply_in_another_chat_layout_ref = self.hook_method(constructor, ReplyInAnotherChatLayoutHook(self))
            
            ChatActivity = self._get_class("org.telegram.ui.ChatActivity")
            DialogsActivity = self._get_class("org.telegram.ui.DialogsActivity")
            ArrayList = self._get_class("java.util.ArrayList")
            CharSequence = self._get_class("java.lang.CharSequence")
            TopicsFragment = self._get_class("org.telegram.ui.TopicsFragment")
            
            boolean_type = jclass("java.lang.Boolean").TYPE
            int_type = jclass("java.lang.Integer").TYPE
            
            method = ChatActivity.getClass().getDeclaredMethod(
                "didSelectDialogs",
                DialogsActivity,
                ArrayList,
                CharSequence,
                boolean_type,
                boolean_type,
                int_type,
                TopicsFragment
            )
            method.setAccessible(True)
            self.hook_reply_in_another_chat_dialogs_ref = self.hook_method(method, ReplyInAnotherChatDialogsHook())
        except Exception as e:
            pass
    
    def _hook_allow_reply_button(self):
        try:
            ChatActivity = self._get_class("org.telegram.ui.ChatActivity")
            methods = ChatActivity.getClass().getDeclaredMethods()
            
            for method in methods:
                if method.getName() == "addToSelectedMessages":
                    try:
                        method.setAccessible(True)
                        self.allow_reply_button_hook_ref = self.hook_method(method, AllowReplyButtonHook(self))
                    except Exception as e:
                        pass
        except Exception as e:
            pass
    
    def _setup_reply_button(self, layout):
        try:
            try:
                replyButton_field = layout.getClass().getDeclaredField("replyButton")
                replyButton_field.setAccessible(True)
                button_holder = replyButton_field.get(layout)
            except Exception as e:
                return
            
            if button_holder is None:
                return
            
            try:
                button_field = button_holder.getClass().getDeclaredField("button")
                button_field.setAccessible(True)
                reply_button_view = button_field.get(button_holder)
            except Exception as e:
                return
            
            if reply_button_view is None:
                return
            
            def on_long_click(view):
                try:
                    self._perform_haptic()
                    LaunchActivity = find_class("org.telegram.ui.LaunchActivity")
                    ChatActivity = find_class("org.telegram.ui.ChatActivity")
                    last_fragment = LaunchActivity.getLastFragment()
                    if last_fragment and isinstance(last_fragment, ChatActivity):
                        self._launch_reply_in_another_chat(last_fragment)
                        return True
                    else:
                        return False
                except Exception as e:
                    return False
            
            reply_button_view.setOnLongClickListener(OnLongClickListener(on_long_click))
        except Exception as e:
            pass
    
    def _launch_reply_in_another_chat(self, chat_activity):
        try:
            try:
                f_selectedMessagesIds = chat_activity.getClass().getDeclaredField("selectedMessagesIds")
                f_selectedMessagesIds.setAccessible(True)
                selectedMessagesIds = f_selectedMessagesIds.get(chat_activity)
                sparse_array = selectedMessagesIds[0]
                count = sparse_array.size()
                
                if count == 0:
                    try:
                        f_selectedObject = chat_activity.getClass().getDeclaredField("selectedObject")
                        f_selectedObject.setAccessible(True)
                        selectedObject = f_selectedObject.get(chat_activity)
                        if selectedObject:
                            sparse_array.put(selectedObject.getId(), selectedObject)
                        else:
                            return
                    except Exception as e:
                        return
            except Exception as e:
                return
            
            Bundle = jclass("android.os.Bundle")
            args = Bundle()
            args.putBoolean("onlySelect", True)
            args.putBoolean("reply_in_another_chat_plugin", True)
            DialogsActivity = find_class("org.telegram.ui.DialogsActivity")
            dialogs_type = 3
            args.putInt("dialogsType", dialogs_type)
            args.putBoolean("quote", True)
            args.putBoolean("reply_to", True)
            args.putBoolean("canSelectTopics", True)
            fragment = DialogsActivity(args)
            fragment.setDelegate(chat_activity)
            chat_activity.presentFragment(fragment)
        except Exception as e:
            pass
    
    def _add_no_quote_forward_menu_item(self):
        try:
            self.no_quote_forward_menu_handle = quantahut.utilities.register_message_menu_item(
                text=get_string("no_quote_forward", "NoQuote forward"),
                option_id=9999,
                icon_res=R_tg.drawable.media_share,
                condition_predicate=lambda m: m is not None and not self._is_service_message(m) and not self._is_failed_message(m) and not self._is_scheduled_message(m),
                on_click=self._on_no_quote_forward_click,
                insert_at_top=True
            )
        except Exception:
            pass

    def _is_service_message(self, message):
        try:
            from org.telegram.tgnet import TLRPC
            return message and hasattr(message, 'messageOwner') and isinstance(message.messageOwner, TLRPC.TL_messageService)
        except Exception:
            return False
    
    def _is_failed_message(self, message):
        try:
            if not message or not hasattr(message, 'messageOwner') or not message.messageOwner:
                return False
            
            message_owner = message.messageOwner
            return (hasattr(message_owner, 'send_state') and message_owner.send_state == 2) or \
                   (hasattr(message_owner, 'id') and message_owner.id < 0)
        except Exception:
            return False
    
    def _is_scheduled_message(self, message):
        try:
            return message and hasattr(message, 'scheduled') and message.scheduled
        except Exception:
            return False

    def _remove_no_quote_forward_menu_item(self):
        try:
            if hasattr(self, 'no_quote_forward_menu_handle') and self.no_quote_forward_menu_handle:
                quantahut.utilities.unregister_message_menu_item(self.no_quote_forward_menu_handle)
                self.no_quote_forward_menu_handle = None
        except Exception:
            pass

    def _update_no_quote_forward_menu_item(self):
        if self.get_setting("enable_no_quote_forward", False):
            if not hasattr(self, 'no_quote_forward_menu_handle') or not self.no_quote_forward_menu_handle:
                self._add_no_quote_forward_menu_item()
        else:
            self._remove_no_quote_forward_menu_item()

    def _on_no_quote_forward_click(self, chat_activity, message):
        self.current_mode = "no_quote"
        
        if not chat_activity:
            return
            
        from java.util import ArrayList
        messages_to_forward = ArrayList()
        
        if message and hasattr(message, 'getGroupId') and message.getGroupId() != 0:
            group_id = message.getGroupId()
            
            try:
                messagesDict = get_private_field(chat_activity, "messagesDict")
                if messagesDict is not None and len(messagesDict) > 0:
                    for a in range(len(messagesDict)):
                        if messagesDict[a] is None:
                            continue
                        msg_dict = messagesDict[a]
                        
                        keys_to_check = []
                        try:
                            size = msg_dict.size()
                            for idx in range(size):
                                keys_to_check.append(msg_dict.keyAt(idx))
                        except:
                            pass
                        
                        for key in keys_to_check:
                            try:
                                msg = msg_dict.get(key)
                                if msg and hasattr(msg, 'getGroupId') and msg.getGroupId() == group_id:
                                    messages_to_forward.add(msg)
                            except:
                                pass
                else:
                    messages_to_forward.add(message)
            except:
                messages_to_forward.add(message)
        else:
            if message:
                messages_to_forward.add(message)
        
        if messages_to_forward.size() == 0 and hasattr(chat_activity, 'selectedObjects') and chat_activity.selectedObjects:
            for obj in chat_activity.selectedObjects:
                messages_to_forward.add(obj)
        
        if messages_to_forward.size() == 0 and message:
            messages_to_forward.add(message)
        
        if not messages_to_forward or messages_to_forward.size() == 0:
            return
        
        if hasattr(chat_activity, 'getCurrentChat') and chat_activity.getCurrentChat():
            current_chat = chat_activity.getCurrentChat()
            if chat_activity.getMessagesController().isChatNoForwards(current_chat):
                return
        
        from android.os import Bundle
        
        args = Bundle()
        args.putBoolean("onlySelect", True)
        args.putBoolean("canSelectTopics", True)
        args.putInt("dialogsType", 3)
        
        dialogs_fragment = DialogsActivity(args)
        
        from java import dynamic_proxy
        
        class NoQuoteForwardDelegate(dynamic_proxy(DialogsActivity.DialogsActivityDelegate)):
            def __init__(self, messages, chat_activity, plugin_instance):
                super().__init__()
                self.messages = messages
                self.chat_activity = chat_activity
                self.plugin_ref = weakref.ref(plugin_instance)
            
            def didSelectDialogs(self, fragment1, dids, message_text, param, notify, scheduleDate, topicsFragment):
                plugin = self.plugin_ref()
                if plugin is None:
                    return
                    
                if dids.size() > 1 or dids.get(0).dialogId == self.chat_activity.getUserConfig().getClientUserId() or message_text:
                    for i in range(dids.size()):
                        dialog = dids.get(i)
                        did = dialog.dialogId
                        topic_id = dialog.topicId if hasattr(dialog, 'topicId') and dialog.topicId else 0
                        
                        send_helper = self.chat_activity.getSendMessagesHelper()
                        if send_helper:
                            send_helper.sendMessage(self.messages, did, True, False, True, topic_id, 0)
                    
                    fragment1.finishFragment()
                    
                    if dids.size() > 1:
                        from org.telegram.messenger import LocaleController, AndroidUtilities
                        messages_count = self.messages.size() if self.messages else 1
                        if messages_count <= 1:
                            text = AndroidUtilities.replaceTags(LocaleController.formatPluralString("FwdMessageToManyChats", dids.size()))
                        else:
                            text = AndroidUtilities.replaceTags(LocaleController.formatPluralString("FwdMessagesToManyChats", dids.size()))
                        from ui.bulletin import BulletinHelper
                        from org.telegram.messenger import R as R_tg
                        BulletinHelper.show_simple(text, R_tg.raw.forward, self.chat_activity)
                    
                else:
                    did = dids.get(0).dialogId
                    args1 = Bundle()

                    args1.putBoolean("scrollToTopOnResume", True)
                    
                    if DialogObject.isEncryptedDialog(did):
                        args1.putInt("enc_id", DialogObject.getEncryptedChatId(did))
                    elif DialogObject.isUserDialog(did):
                        args1.putLong("user_id", did)
                    else:
                        args1.putLong("chat_id", -did)
                    
                    if not self.chat_activity.getMessagesController().checkCanOpenChat(args1, fragment1):
                        return True
                    
                    self.chat_activity.getNotificationCenter().postNotificationName(NotificationCenter.closeChats)
                    
                    new_chat_activity = ChatActivity(args1)
                    
                    ForumUtilities = plugin._get_class("org.telegram.ui.Components.Forum.ForumUtilities")
                    if ForumUtilities:
                        ForumUtilities.applyTopic(new_chat_activity, dids.get(0))
                    
                    fragment1.presentFragment(new_chat_activity, True)

                    new_chat_activity.showFieldPanelForForward(True, self.messages)
                    params = get_private_field(new_chat_activity, "messagePreviewParams")
                    if params is not None:
                        try:
                            set_private_field(params, "hideForwardSendersName", True)
                        except:
                            pass
                
                return True
            
            def canSelectStories(self):
                return False
        
        delegate = NoQuoteForwardDelegate(messages_to_forward, chat_activity, self)
        dialogs_fragment.setDelegate(delegate)
        
        chat_activity.presentFragment(dialogs_fragment)

        self.current_mode = "forward"
        log("[UiTweaks]current_mode reset to 'forward'")

    def _collect_selected_messages(self, chat_activity):
        try:
            from java.util import ArrayList
            selectedIds = get_private_field(chat_activity, "selectedMessagesIds")
            messagesDict = get_private_field(chat_activity, "messagesDict")
            arr = ArrayList()
            if selectedIds is not None and messagesDict is not None:
                for a in range(2):
                    ids = selectedIds[a]
                    if ids is None:
                        continue
                    size = ids.size()
                    keys = []
                    for idx in range(size):
                        keys.append(ids.keyAt(idx))
                    try:
                        keys.sort()
                    except Exception:
                        pass
                    for key in keys:
                        msg = messagesDict[a].get(key)
                        if msg is not None:
                            arr.add(msg)
            return arr
        except Exception:
            return None


    def _can_use_repeat(self, message):
        try:
            if not message or not message.messageOwner:
                return True
            
            from client_utils import get_messages_controller
            mc = get_messages_controller()
            if not mc:
                return True
            
            if mc.isChatNoForwards(message.getChatId()):
                return False
            
            if message.messageOwner.noforwards:
                return False
            
            chat_id = message.getChatId()
            if chat_id != 0:
                chat = mc.getChat(chat_id)
                if chat:
                    ChatObject = find_class("org.telegram.messenger.ChatObject")
                    if ChatObject.isChannel(chat) and not ChatObject.isMegagroup(chat):
                        return ChatObject.canPost(chat)
            return True
        except Exception:
            return True

    def _add_message_repeat_menu_item(self):
        try:
            self.repeat_menu_handle = quantahut.utilities.register_message_menu_item(
                text=get_string("message_repeat", "Repeat"),
                option_id=2035,
                icon_res=R_tg.drawable.msg_addbot_solar,
                condition_predicate=lambda m: (
                    m is not None and 
                    not self._is_service_message(m) and 
                    not self._is_failed_message(m) and 
                    not self._is_scheduled_message(m) and
                    self._can_use_repeat(m)
                ),
                on_click=self._on_message_repeat_click,
                insert_at_top=False
            )
        except Exception:
            pass

    def _remove_message_repeat_menu_item(self):
        try:
            if hasattr(self, 'repeat_menu_handle') and self.repeat_menu_handle:
                quantahut.utilities.unregister_message_menu_item(self.repeat_menu_handle)
                self.repeat_menu_handle = None
        except Exception:
            pass

    def _update_message_repeat_menu_item(self):
        if self.get_setting("enable_message_repeat", False):
            if not hasattr(self, 'repeat_menu_handle') or not self.repeat_menu_handle:
                self._add_message_repeat_menu_item()
        else:
            self._remove_message_repeat_menu_item()

    def _on_message_repeat_click(self, chat_activity, message, grouped_messages=None):
        try:
            if not message or not chat_activity:
                return
            
            current_account = get_account_instance().getCurrentAccount()
            send_helper = SendMessagesHelper.getInstance(current_account)
            account_instance = AccountInstance.getInstance(current_account)
            
            try:
                dialog_id = chat_activity.getDialogId()
            except Exception:
                return
            
            topic_id = 0
            try:
                current_fragment = get_last_fragment()
                if current_fragment and hasattr(current_fragment, 'getTopicId'):
                    topic_id = current_fragment.getTopicId()
            except Exception:
                pass
            
            reply_to_msg = None
            if topic_id != 0:
                try:
                    topic = account_instance.getMessagesController().getTopicsController().findTopic(-dialog_id, topic_id)
                    if topic and topic.topicStartMessage:
                        reply_to_msg = MessageObject(current_account, topic.topicStartMessage, False, False)
                        reply_to_msg.isTopicMainMessage = True
                except Exception:
                    pass
            
            from java.util import ArrayList
            messages_to_forward = ArrayList()
            
            if grouped_messages and not grouped_messages.isDocuments:
                for msg in grouped_messages.messages:
                    messages_to_forward.add(msg)
            else:
                messages_to_forward.add(message)
            
            send_helper.sendMessage(
                messages_to_forward,
                dialog_id,
                False,
                False,
                True,
                0,
                reply_to_msg,
                topic_id,
                0,
                0,
                None
            )
        except Exception:
            pass

    
    def _hook_actions_buttons_layout(self):
        try:
            ChatActivityActionsButtonsLayoutClass = self._get_class(
                "org.telegram.ui.Components.chat.layouts.ChatActivityActionsButtonsLayout"
            )
            
            if ChatActivityActionsButtonsLayoutClass is None:
                return
            
            ContextClass = self._get_class("android.content.Context")
            ResourcesProviderClass = self._get_class("org.telegram.ui.ActionBar.Theme$ResourcesProvider")
            ColorProviderClass = self._get_class("org.telegram.ui.Components.blur3.drawable.color.BlurredBackgroundColorProvider")
            BlurredBackgroundDrawableViewFactoryClass = self._get_class("org.telegram.ui.Components.blur3.BlurredBackgroundDrawableViewFactory")
            
            constructor = ChatActivityActionsButtonsLayoutClass.getClass().getDeclaredConstructor(
                ContextClass,
                ResourcesProviderClass,
                ColorProviderClass,
                BlurredBackgroundDrawableViewFactoryClass
            )
            constructor.setAccessible(True)
            
            class LayoutConstructorHook:
                def __init__(hook_self):
                    hook_self.plugin = self
                
                def after_hooked_method(hook_self, param):
                    try:
                        layout = param.thisObject
                        hook_self.plugin._setup_forward_button(layout)
                        hook_self.plugin._hook_add_to_selected_messages(layout)
                    except Exception as e:
                        pass
            
            self._unhook_layout = self.hook_method(constructor, LayoutConstructorHook())
            
        except Exception as e:
            pass
    
    def _setup_forward_button(self, layout):
        try:
            ViewOnClickListenerClass = self._get_class("android.view.View$OnClickListener")
            setForwardButtonMethod = layout.getClass().getDeclaredMethod(
                "setForwardButtonOnClickListener",
                ViewOnClickListenerClass
            )
            setForwardButtonMethod.setAccessible(True)
            
            plugin_ref = self
            
            class SetForwardListenerHook:
                def __init__(hook_self):
                    hook_self.plugin = plugin_ref
                    hook_self.layout = layout
                
                def before_hooked_method(hook_self, param):
                    try:
                        original_listener = param.args[0]
                        
                        def open_old_share_sheet():
                            try:
                                from client_utils import get_last_fragment
                                from java.lang import Boolean
                                chat_activity = get_last_fragment()
                                if chat_activity:
                                    openForwardMethod = chat_activity.getClass().getDeclaredMethod("openForward", Boolean.TYPE)
                                    openForwardMethod.setAccessible(True)
                                    openForwardMethod.invoke(chat_activity, True)
                            except Exception as e:
                                pass
                        
                        def wrapped_click(view):
                            try:
                                use_old_share_sheet = hook_self.plugin.get_setting("enable_old_forward", False)
                                
                                if use_old_share_sheet:
                                    open_old_share_sheet()
                                else:
                                    if original_listener is not None:
                                        original_listener.onClick(view)
                            except Exception as e:
                                if original_listener is not None:
                                    original_listener.onClick(view)
                        
                        param.args[0] = OnClickListener(wrapped_click)
                    except Exception as e:
                        pass
            
            self.hook_method(setForwardButtonMethod, SetForwardListenerHook())
            
            forward_button = layout.getForwardButton()
            
            if forward_button is None:
                return
            
            def on_forward_long_click(view):
                try:
                    plugin_ref._perform_haptic(layout)
                    plugin_ref._show_mode_selector_dialog(view, layout)
                    return True
                except Exception as e:
                    return False
            
            forward_button.setOnLongClickListener(OnLongClickListener(on_forward_long_click))
            self._update_forward_button_text(layout)
            
        except Exception as e:
            pass
    
    def _hook_add_to_selected_messages(self, layout):
        try:
            addToSelectedMessagesMethod = layout.getClass().getDeclaredMethod(
                "addToSelectedMessages",
                find_class("org.telegram.messenger.MessageObject")
            )
            addToSelectedMessagesMethod.setAccessible(True)
            
            plugin_ref = self
            
            class AddToSelectedMessagesHook:
                def __init__(hook_self):
                    hook_self.plugin = plugin_ref
                
                def before_hooked_method(hook_self, param):
                    try:
                        message = param.args[0]
                        if message is None:
                            hook_self.plugin.current_mode = "forward"
                    except Exception:
                        pass
            
            self.hook_method(addToSelectedMessagesMethod, AddToSelectedMessagesHook())
        except Exception as e:
            pass
    
    def _show_mode_selector_dialog(self, button_view, layout):
        def show_dialog():
            try:
                from android.widget import LinearLayout
                from org.telegram.ui.ActionBar import AlertDialog, Theme
                from org.telegram.messenger import AndroidUtilities
                
                self.current_mode = self.get_setting("forward_mode", "forward")
                
                context = button_view.getContext()
                
                builder = AlertDialog.Builder(context)
                builder.setTitle(get_string("forward_mode", "Forward Mode"))
                
                linear_layout = LinearLayout(context)
                linear_layout.setOrientation(LinearLayout.VERTICAL)
                builder.setView(linear_layout)
                
                options = [get_string("forward_option", "Forward"), get_string("no_quote_option", "No Quote"), get_string("hide_caption_option", "Hide Caption")]
                current_index = 0 if self.current_mode == "forward" else (1 if self.current_mode == "no_quote" else 2)
                
                RadioColorCellClass = find_class("org.telegram.ui.Cells.RadioColorCell")
                
                for i in range(len(options)):
                    cell = RadioColorCellClass(context)
                    cell.setPadding(AndroidUtilities.dp(4), 0, AndroidUtilities.dp(4), 0)
                    cell.setTag(i)
                    cell.setCheckColor(
                        Theme.getColor(Theme.key_radioBackground),
                        Theme.getColor(Theme.key_dialogRadioBackgroundChecked)
                    )
                    cell.setTextAndValue(options[i], i == current_index)
                    cell.setBackground(Theme.getSelectorDrawable(False))
                    linear_layout.addView(cell)
                    
                    plugin_ref = self
                    layout_ref = layout
                    
                    def create_click_listener(index):
                        def on_click(v):
                            try:
                                if index == 0:
                                    plugin_ref.current_mode = "forward"
                                elif index == 1:
                                    plugin_ref.current_mode = "no_quote"
                                elif index == 2:
                                    plugin_ref.current_mode = "hide_caption"
                                
                                plugin_ref.set_setting("forward_mode", plugin_ref.current_mode)
                                plugin_ref._update_forward_button_text(layout_ref)
                                builder.getDismissRunnable().run()
                            except Exception as e:
                                pass
                        return on_click
                    
                    cell.setOnClickListener(OnClickListener(create_click_listener(i)))
                
                builder.setNegativeButton("Cancel", None)
                builder.show()
                
            except Exception as e:
                pass
        
        run_on_ui_thread(show_dialog)
    
    def _update_forward_button_text(self, layout):
        def update_text():
            try:
                forwardButton_field = layout.getClass().getDeclaredField("forwardButton")
                forwardButton_field.setAccessible(True)
                button_holder = forwardButton_field.get(layout)
                
                if button_holder is None:
                    return
                
                textView_field = button_holder.getClass().getDeclaredField("textView")
                textView_field.setAccessible(True)
                text_view = textView_field.get(button_holder)
                
                if text_view is None:
                    return
                
                if self.current_mode == "no_quote":
                    text_view.setText(get_string("no_quote_option", "No Quote"))
                elif self.current_mode == "hide_caption":
                    text_view.setText(get_string("hide_caption_option", "Hide Caption"))
                else:
                    text_view.setText(get_string("forward_option", "Forward"))
                
            except Exception as e:
                pass
        
        run_on_ui_thread(update_text)
    
    def _hook_add_to_folder_all_tabs(self):
        try:
            DialogsActivityClass = self._get_class("org.telegram.ui.DialogsActivity")
            if not DialogsActivityClass:
                return
            
            try:
                BooleanTYPE = self._get_class("java.lang.Boolean").TYPE
                updateCountersMethod = DialogsActivityClass.getClass().getDeclaredMethod("updateCounters", BooleanTYPE)
            except:
                try:
                    updateCountersMethod = DialogsActivityClass.getClass().getDeclaredMethod("updateCounters")
                except:
                    IntegerTYPE = self._get_class("java.lang.Integer").TYPE
                    updateCountersMethod = DialogsActivityClass.getClass().getDeclaredMethod("updateCounters", IntegerTYPE)
            
            updateCountersMethod.setAccessible(True)
            
            self.hook_add_to_folder_all_tabs_ref = self.hook_method(
                updateCountersMethod,
                AddToFolderAllTabsHook(self),
                priority=0
            )
            
        except Exception:
            pass
    
    def _hook_unread_count(self):
        try:
            MessagesStorageClass = self._get_class("org.telegram.messenger.MessagesStorage")
            if not MessagesStorageClass:
                return

            BooleanTYPE = self._get_class("java.lang.Boolean").TYPE
            calcUnreadCountersMethod = MessagesStorageClass.getClass().getDeclaredMethod("calcUnreadCounters", BooleanTYPE)
            calcUnreadCountersMethod.setAccessible(True)

            self.hook_unread_count_ref = self.hook_method(calcUnreadCountersMethod, UnreadCountHook(self), priority=0)

            if self.get_setting("exclude_archived_from_count", False):
                try:
                    from org.telegram.messenger import UserConfig
                    current_account = UserConfig.selectedAccount
                    messages_storage = MessagesStorageClass.getInstance(current_account)
                    calcUnreadCountersMethod.invoke(messages_storage, True)
                except Exception:
                    pass

        except Exception:
            pass
    
    def _hook_contact_status_in_profile(self):
        try:
            ProfileActivity = self._get_class("org.telegram.ui.ProfileActivity")
            if not ProfileActivity:
                return

            java_class = ProfileActivity.getClass()

            try:
                update_rows = java_class.getDeclaredMethod("updateRowsIds")
                update_rows.setAccessible(True)
                self.contact_status_update_rows_hook = self.hook_method(
                    update_rows,
                    ContactStatusUpdateRowsIdsHook(self),
                    priority=0,
                )
            except Exception:
                pass

            ListAdapter = self._get_class("org.telegram.ui.ProfileActivity$ListAdapter")
            if not ListAdapter:
                return

            try:
                int_type = jclass("java.lang.Integer").TYPE
                view_group = jclass("android.view.ViewGroup")
                view_holder = jclass("androidx.recyclerview.widget.RecyclerView$ViewHolder")

                list_adapter_class = ListAdapter.getClass()

                get_item_view_type = list_adapter_class.getDeclaredMethod("getItemViewType", int_type)
                get_item_view_type.setAccessible(True)
                self.contact_status_get_item_view_type_hook = self.hook_method(
                    get_item_view_type,
                    ContactStatusListAdapterGetItemViewTypeHook(self),
                    priority=0,
                )

                on_create_view_holder = list_adapter_class.getDeclaredMethod(
                    "onCreateViewHolder",
                    view_group,
                    int_type,
                )
                on_create_view_holder.setAccessible(True)
                self.contact_status_create_view_holder_hook = self.hook_method(
                    on_create_view_holder,
                    ContactStatusListAdapterCreateViewHolderHook(self),
                    priority=0,
                )

                on_bind_view_holder = list_adapter_class.getDeclaredMethod(
                    "onBindViewHolder",
                    view_holder,
                    int_type,
                )
                on_bind_view_holder.setAccessible(True)
                self.contact_status_bind_view_holder_hook = self.hook_method(
                    on_bind_view_holder,
                    ContactStatusListAdapterBindViewHolderHook(self),
                    priority=0,
                )
            except Exception:
                pass

        except Exception:
            pass
    
    def _hook_unify_username_behavior(self):
        try:
            ProfileActivityClass = self._get_class("org.telegram.ui.ProfileActivity")
            if not ProfileActivityClass:
                return
            
            ViewClass = self._get_class("android.view.View")
            from java.lang import Integer, Float, Boolean
            
            try:
                process_click_method = ProfileActivityClass.getClass().getDeclaredMethod(
                    "processOnClickOrPress",
                    Integer.TYPE,
                    ViewClass,
                    Float.TYPE,
                    Float.TYPE,
                    Boolean.TYPE
                )
                process_click_method.setAccessible(True)
                self.hook_unify_username_behavior_process_click_ref = self.hook_method(
                    process_click_method,
                    UnifyUsernameProcessClickHook()
                )
            except Exception:
                pass
            
            ListAdapterClass = self._get_class("org.telegram.ui.ProfileActivity$ListAdapter")
            if not ListAdapterClass:
                return
            
            RecyclerViewHolder = self._get_class("androidx.recyclerview.widget.RecyclerView$ViewHolder")
            from java.lang import Integer
            
            try:
                bind_method = ListAdapterClass.getClass().getDeclaredMethod(
                    "onBindViewHolder",
                    RecyclerViewHolder,
                    Integer.TYPE
                )
                bind_method.setAccessible(True)
                self.hook_unify_username_behavior_bind_ref = self.hook_method(
                    bind_method,
                    UnifyUsernameBindViewHook(self)
                )
            except Exception:
                pass
        
        except Exception:
            pass
    
    def _hook_edit_file_name(self):
        try:
            from org.telegram.ui import MessageSendPreview
            from org.telegram.ui.Components import ItemOptions
            
            set_item_options_method = MessageSendPreview.getClass().getDeclaredMethod("setItemOptions", ItemOptions)
            
            handler = EditFileNameSetItemOptionsHook(self)
            self.hook_edit_file_name_ref = self.hook_method(set_item_options_method, handler)
            
        except Exception:
            pass
    
    def _hook_send_comments_after_forward(self):
        try:
            self.hook_send_comments_after_forward_ref = self.add_hook("TL_messages_forwardMessages")
        except Exception:
            pass
    
    def _has_document_selected(self):
        try:
            from org.telegram.ui import ChatActivity
            
            fragment = get_last_fragment()
            if fragment is None or not isinstance(fragment, ChatActivity):
                return False
            
            chat_attach_alert = get_private_field(fragment, "chatAttachAlert")
            if chat_attach_alert is None:
                return False
            
            current_layout = get_private_field(chat_attach_alert, "currentAttachLayout")
            if current_layout is None:
                return False
            
            document_layout_class = find_class("org.telegram.ui.Components.ChatAttachAlertDocumentLayout")
            if document_layout_class and isinstance(current_layout, document_layout_class):
                selected_files = get_private_field(current_layout, "selectedFilesOrder")
                return selected_files is not None and not selected_files.isEmpty()
            
            audio_layout_class = find_class("org.telegram.ui.Components.ChatAttachAlertAudioLayout")
            if audio_layout_class and isinstance(current_layout, audio_layout_class):
                selected_audios = get_private_field(current_layout, "selectedAudiosOrder")
                return selected_audios is not None and not selected_audios.isEmpty()
            
            return False
            
        except Exception:
            return False
    
    def _on_edit_filename_click(self, options_instance, message_send_preview=None):
        try:
            if message_send_preview is not None:
                try:
                    message_send_preview.dismiss()
                except Exception:
                    pass
            
            from org.telegram.ui import ChatActivity
            fragment = get_last_fragment()
            
            if fragment is None or not isinstance(fragment, ChatActivity):
                return
            
            chat_attach_alert = get_private_field(fragment, "chatAttachAlert")
            if chat_attach_alert is None:
                return
            
            current_layout = get_private_field(chat_attach_alert, "currentAttachLayout")
            if current_layout is None:
                return
            
            file_path = None
            
            document_layout_class = find_class("org.telegram.ui.Components.ChatAttachAlertDocumentLayout")
            if document_layout_class and isinstance(current_layout, document_layout_class):
                selected_files_order = get_private_field(current_layout, "selectedFilesOrder")
                if selected_files_order is not None and not selected_files_order.isEmpty():
                    file_path = selected_files_order.get(0)
            
            if file_path is None:
                audio_layout_class = find_class("org.telegram.ui.Components.ChatAttachAlertAudioLayout")
                if audio_layout_class and isinstance(current_layout, audio_layout_class):
                    selected_audios_order = get_private_field(current_layout, "selectedAudiosOrder")
                    if selected_audios_order is not None and not selected_audios_order.isEmpty():
                        audio_entry = selected_audios_order.get(0)
                        if audio_entry is not None:
                            file_path = audio_entry.path
            
            if file_path is None:
                return
            
            import os
            filename = os.path.basename(file_path)
            
            def show_dialog():
                self._show_filename_edit_dialog(filename, file_path, current_layout)
            
            run_on_ui_thread(show_dialog)
            
        except Exception:
            pass
    
    def _show_filename_edit_dialog(self, original_filename, file_path, document_layout):
        from ui.alert import AlertDialogBuilder
        from client_utils import get_last_fragment
        from org.telegram.ui.Components import EditTextBoldCursor
        from org.telegram.ui.ActionBar import Theme
        from org.telegram.messenger import AndroidUtilities
        from android.text import InputType
        from android.util import TypedValue
        from android.widget import FrameLayout
        from android.view import Gravity
        from android_utils import run_on_ui_thread
        
        fragment = get_last_fragment()
        if fragment is None:
            return
        
        activity = fragment.getParentActivity()
        if activity is None:
            return

        edit_text = EditTextBoldCursor(activity)
        edit_text.setHint(get_string("file_name", "File Name"))
        edit_text.setText(original_filename)
        edit_text.setInputType(InputType.TYPE_CLASS_TEXT)
        edit_text.setMaxLines(1)
        edit_text.setSingleLine(True)
        edit_text.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 18)
        edit_text.setTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteBlackText))
        edit_text.setHintTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteHintText))
        edit_text.setBackground(Theme.createEditTextDrawable(activity, True))
        edit_text.setCursorColor(Theme.getColor(Theme.key_windowBackgroundWhiteBlueHeader))
        edit_text.setCursorSize(AndroidUtilities.dp(20))
        edit_text.setCursorWidth(1.5)
        edit_text.setPadding(0, 0, 0, 0)
        edit_text.setFocusable(True)
        
        builder = AlertDialogBuilder(activity)
        builder.set_title(get_string("edit_file_name", "Edit File Name"))
        builder.set_message(get_string("enter_new_file_name", "Enter the new file name"))
        builder.set_view(edit_text)
        
        plugin_ref = self
        
        def on_save(dialog, which):
            input_text = str(edit_text.getText()).strip()
            plugin_ref._apply_filename_change(
                input_text,
                file_path,
                document_layout,
                dialog
            )
        
        def on_cancel_click(dialog, which):
            try:
                AndroidUtilities.hideKeyboard(edit_text)
            except Exception:
                pass
            dialog.dismiss()
        
        builder.set_positive_button(get_string("swipe_save", "Save"), on_save)
        builder.set_negative_button(get_string("cancel", "Cancel"), on_cancel_click)
        
        dialog = builder.show()
        
        def apply_layout_params():
            try:
                layout_params = edit_text.getLayoutParams()
                if layout_params is not None:
                    if isinstance(layout_params, FrameLayout.LayoutParams):
                        layout_params.gravity = Gravity.CENTER_HORIZONTAL
                    
                    if hasattr(layout_params, 'rightMargin'):
                        layout_params.rightMargin = AndroidUtilities.dp(24)
                        layout_params.leftMargin = AndroidUtilities.dp(24)
                        layout_params.height = AndroidUtilities.dp(36)
                        layout_params.bottomMargin = AndroidUtilities.dp(15)
                    edit_text.setLayoutParams(layout_params)
                
                edit_text.requestFocus()
                text_length = edit_text.getText().length() if edit_text.getText() else 0
                edit_text.setSelection(0, text_length)
            except Exception:
                pass
        
        run_on_ui_thread(apply_layout_params, 100)
    
    def _apply_filename_change(self, new_filename, old_path, current_layout, dialog):
        try:
            if not new_filename or len(new_filename.strip()) == 0:
                dialog.dismiss()
                return
            
            new_filename = new_filename.strip()
            
            import os
            import shutil
            
            document_layout_class = find_class("org.telegram.ui.Components.ChatAttachAlertDocumentLayout")
            audio_layout_class = find_class("org.telegram.ui.Components.ChatAttachAlertAudioLayout")
            
            if document_layout_class and isinstance(current_layout, document_layout_class):
                old_dir = os.path.dirname(old_path)
                new_path = os.path.join(old_dir, new_filename)
                
                if os.path.exists(old_path):
                    shutil.copy2(old_path, new_path)
                    
                    selected_files_order = get_private_field(current_layout, "selectedFilesOrder")
                    selected_files = get_private_field(current_layout, "selectedFiles")
                    
                    if selected_files_order and selected_files:
                        selected_files_order.set(0, new_path)
                        
                        old_list_item = selected_files.get(old_path)
                        if old_list_item:
                            selected_files.remove(old_path)
                            
                            from java.io import File
                            new_file = File(new_path)
                            old_list_item.file = new_file
                            old_list_item.title = new_filename
                            
                            selected_files.put(new_path, old_list_item)
                            
                            def refresh_list():
                                try:
                                    list_adapter = get_private_field(current_layout, "listAdapter")
                                    if list_adapter:
                                        list_adapter.notifyDataSetChanged()
                                except Exception:
                                    pass
                            
                            run_on_ui_thread(refresh_list)
            
            elif audio_layout_class and isinstance(current_layout, audio_layout_class):

                # Fuck android storage access restrictions (we must copy the file to cache dir for renaming)
                
                from file_utils import get_cache_dir, ensure_dir_exists
                
                cache_dir = get_cache_dir()
                temp_dir = os.path.join(cache_dir, "renamed_files")
                ensure_dir_exists(temp_dir)
                new_path = os.path.join(temp_dir, new_filename)
                
                if os.path.exists(old_path):
                    shutil.copy2(old_path, new_path)
                    
                    selected_audios_order = get_private_field(current_layout, "selectedAudiosOrder")
                    
                    if selected_audios_order and not selected_audios_order.isEmpty():
                        audio_entry = selected_audios_order.get(0)
                        
                        if audio_entry:
                            audio_entry.path = new_path
                            audio_entry.title = new_filename
                            
                            msg_obj = audio_entry.messageObject
                            if msg_obj:
                                msg = msg_obj.messageOwner
                                if msg:
                                    msg.attachPath = new_path
                                    
                                    if msg.media and msg.media.document and msg.media.document.attributes:
                                        attrs = msg.media.document.attributes
                                        for i in range(attrs.size()):
                                            attr = attrs.get(i)
                                            attr_class_name = type(attr).__name__
                                            
                                            if "TL_documentAttributeFilename" in attr_class_name:
                                                attr.file_name = new_filename
                                            
                                            if "TL_documentAttributeAudio" in attr_class_name:
                                                name_without_ext = new_filename
                                                if "." in name_without_ext:
                                                    name_without_ext = name_without_ext.rsplit(".", 1)[0]
                                                attr.title = name_without_ext
                            
                            def refresh_list():
                                try:
                                    list_adapter = get_private_field(current_layout, "listAdapter")
                                    if list_adapter:
                                        list_adapter.notifyDataSetChanged()
                                except Exception:
                                    pass
                            
                            run_on_ui_thread(refresh_list)
            
            dialog.dismiss()
            
        except Exception:
            pass
    
    def _hook_safe_mode(self):
        try:
            LaunchActivityClass = self._get_class("org.telegram.ui.LaunchActivity")
            if not LaunchActivityClass:
                return
            
            methods = LaunchActivityClass.getClass().getDeclaredMethods()
            dispatch_method = None
            for method in methods:
                if method.getName() == "dispatchKeyEvent":
                    dispatch_method = method
                    break
            
            if not dispatch_method:
                return
            
            dispatch_method.setAccessible(True)
            self.safe_mode_hook_ref = self.hook_method(dispatch_method, SafeModeHook(self))
        except Exception:
            pass
    
    def _on_safe_mode_detected(self):
        try:
            run_on_ui_thread(self._enable_safe_mode)
        except Exception:
            pass
    
    def _enable_safe_mode(self):
        try:
            from com.exteragram.messenger import ExteraConfig
            from com.exteragram.messenger.plugins import PluginsController
            from android.content import Context
            from org.telegram.messenger import ApplicationLoader
            
            ExteraConfig.pluginsSafeMode = True
            editor = ExteraConfig.editor
            editor.putBoolean("pluginsSafeMode", True).apply()
            
            context = ApplicationLoader.applicationContext
            plugin_prefs = context.getSharedPreferences("plugin_settings", Context.MODE_PRIVATE)
            plugin_prefs.edit().putBoolean("had_crash", True).putString("crashed_plugin_id", "manual!").apply()
            
            PluginsController.getInstance().restart()
            
            try:
                SafeModeBottomSheet = self._get_class("com.exteragram.messenger.plugins.ui.components.SafeModeBottomSheet")
                fragment = get_last_fragment()
                if fragment and SafeModeBottomSheet:
                    SafeModeBottomSheet(fragment).show()
            except Exception:
                pass
        except Exception:
            pass
    
  
    def _load_hidden_folders(self):
        try:
            data_str = self.get_setting("hidefolders_data", "{}")
            self.hidden_folders_data = json.loads(data_str)
            
            all_chats_str = self.get_setting("hidefolders_allchats", "{}")
            self.hide_all_chats_folder = json.loads(all_chats_str)
        except Exception:
            self.hidden_folders_data = {}
            self.hide_all_chats_folder = {}
    
    def _save_hidden_folders(self):
        try:
            self.set_setting("hidefolders_data", json.dumps(self.hidden_folders_data))
            self.set_setting("hidefolders_allchats", json.dumps(self.hide_all_chats_folder))
        except Exception:
            pass
    
    def _get_account_key(self):
        try:
            user_id = UserConfig.getInstance(UserConfig.selectedAccount).getClientUserId()
            return f"_{user_id}"
        except Exception:
            return "_default"
    
    def _get_hidden_folders_for_account(self):
        key = self._get_account_key()
        if key not in self.hidden_folders_data:
            self.hidden_folders_data[key] = []
        return self.hidden_folders_data[key]
    
    def _is_folder_hidden(self, filter_id):
        hidden_folders = self._get_hidden_folders_for_account()
        return filter_id in hidden_folders
    
    def _is_all_chats_hidden(self):
        key = self._get_account_key()
        return self.hide_all_chats_folder.get(key, False)
    
    def _show_folder_selector(self):
        try:
            controller = MessagesController.getInstance(UserConfig.selectedAccount)
            filters_field = controller.getClass().getDeclaredField("dialogFilters")
            filters_field.setAccessible(True)
            filters = filters_field.get(controller)

            if filters is None:
                filters = controller.getDialogFilters()

            hidden_folders = self._get_hidden_folders_for_account()

            items = []
            keys = []
            key_to_folder = {}

            for i in range(filters.size()):
                filter_obj = filters.get(i)
                if filter_obj.isDefault():
                    continue

                key = f"hidefolders_folder_{filter_obj.id}"
                keys.append(key)
                items.append(str(filter_obj.name))
                key_to_folder[key] = filter_obj.id

            if not items:
                return

            for key in keys:
                folder_id = key_to_folder[key]
                self.set_setting(key, folder_id in hidden_folders)

            def on_selection_change(selected_keys):
                try:
                    account_key = self._get_account_key()
                    new_hidden = [key_to_folder[key] for key in selected_keys if key in key_to_folder]
                    self.hidden_folders_data[account_key] = new_hidden
                    self._save_hidden_folders()
                    self._hook_folder_visibility(post_notification=True)
                    return False
                except Exception:
                    return False

            showmultiselector(
                items=items,
                title=get_string("hide_folders_title", "Hide Folders"),
                subtitle=get_string("hide_folders_subtitle", "Select folders to hide"),
                setting_keys=keys,
                plugin_instance=self,
                on_selection_change=on_selection_change,
                action_text=get_string("apply", "Apply")
            )
        except Exception:
            pass
    
    def _toggle_hide_folders(self, enabled):
        self.set_setting("hidefolders_enabled", enabled)
        self._hook_folder_visibility(post_notification=True)
    
    def _post_update_notification(self):
        try:
            from android.os import Handler, Looper
            from android_utils import R
            
            def post_update():
                try:
                    NotificationCenter.getInstance(UserConfig.selectedAccount).postNotificationName(
                        NotificationCenter.dialogFiltersUpdated
                    )
                except:
                    pass
            
            Handler(Looper.getMainLooper()).post(R(post_update))
        except Exception:
            pass
    
    def _hook_folder_visibility(self, post_notification=False):
        try:
            if not self.get_setting("hidefolders_enabled", False):
                return
                
            MessagesControllerClass = find_class("org.telegram.messenger.MessagesController")
            if not MessagesControllerClass:
                return
            
            from org.telegram.messenger import UserConfig
            current_account = UserConfig.selectedAccount
            controller = MessagesControllerClass.getInstance(current_account)
            
            hidden_folders = self._get_hidden_folders_for_account()
            hide_all_chats = self._is_all_chats_hidden()
            
            if not hidden_folders and not hide_all_chats:
                frozen_field = controller.getClass().getDeclaredField("frozenDialogFilters")
                frozen_field.setAccessible(True)
                frozen_field.set(controller, None)
                return
            
            dialog_filters_field = controller.getClass().getDeclaredField("dialogFilters")
            dialog_filters_field.setAccessible(True)
            original_filters = dialog_filters_field.get(controller)
            
            if original_filters is None or original_filters.size() == 0:
                return
            
            from java.util import ArrayList
            filtered_list = ArrayList()
            for i in range(original_filters.size()):
                filter_item = original_filters.get(i)
                try:
                    is_default = filter_item.isDefault()
                except:
                    is_default = False
                if is_default and hide_all_chats:
                    continue
                if not is_default and filter_item.id in hidden_folders:
                    continue
                filtered_list.add(filter_item)
            
            frozen_field = controller.getClass().getDeclaredField("frozenDialogFilters")
            frozen_field.setAccessible(True)
            frozen_field.set(controller, filtered_list)
            
            if post_notification:
                self._post_update_notification()
            
        except Exception:
            pass
    
    def _hook_search_by_user_id(self):
        try:
            MentionsAdapterClass = self._get_class("org.telegram.ui.Adapters.MentionsAdapter")
            if not MentionsAdapterClass:
                return
            
            IntegerClass = self._get_class("java.lang.Integer")
            BooleanClass = self._get_class("java.lang.Boolean")
            
            java_class = MentionsAdapterClass.getClass()
            search_method = java_class.getDeclaredMethod(
                "searchUsernameOrHashtag",
                self._get_class("java.lang.CharSequence"),
                IntegerClass.TYPE,
                self._get_class("java.util.ArrayList"),
                BooleanClass.TYPE,
                BooleanClass.TYPE
            )
            search_method.setAccessible(True)
            
            class SearchHook:
                def __init__(self, plugin):
                    self.plugin = plugin
                
                def before_hooked_method(self, param):
                    try:
                        if not hasattr(self, 'pending_user'):
                            self.pending_user = None
                        if not hasattr(self, 'pending_chat'):
                            self.pending_chat = None
                        
                        char_sequence = param.args[0]
                        for_search = param.args[4] if len(param.args) > 4 else False
                        
                        if not for_search or char_sequence is None:
                            self.pending_user = None
                            self.pending_chat = None
                            return
                        
                        if isinstance(char_sequence, str):
                            text = char_sequence.strip()
                        else:
                            text = str(char_sequence).strip()
                        
                        if text.startswith("@"):
                            text = text[1:]
                        
                        if text and text.isdigit() and len(text) <= 20:
                            try:
                                user_id = int(text)
                                current_account = UserConfig.selectedAccount
                                user = MessagesController.getInstance(current_account).getUser(user_id)
                                chat = MessagesController.getInstance(current_account).getChat(user_id)
                                
                                if chat is None and text.startswith("100") and len(text) > 10:
                                    chat_id = int(text[3:])
                                    chat = MessagesController.getInstance(current_account).getChat(chat_id)
                                
                                if user is not None:
                                    self.pending_user = user
                                elif chat is not None:
                                    self.pending_chat = chat
                                
                            except:
                                pass
                                
                    except:
                        pass
                
                def after_hooked_method(self, param):
                    try:
                        if self.pending_user is None and self.pending_chat is None:
                            return
                        
                        adapter = param.thisObject
                        
                        try:
                            parent_fragment_field = adapter.getClass().getDeclaredField("parentFragment")
                            parent_fragment_field.setAccessible(True)
                            chat_activity = parent_fragment_field.get(adapter)
                            
                            if chat_activity:
                                search_user_method = chat_activity.getClass().getDeclaredMethod(
                                    "searchUserMessages",
                                    self.plugin._get_class("org.telegram.tgnet.TLRPC$User"),
                                    self.plugin._get_class("org.telegram.tgnet.TLRPC$Chat")
                                )
                                search_user_method.setAccessible(True)
                                
                                if self.pending_user:
                                    search_user_method.invoke(chat_activity, self.pending_user, None)
                                elif self.pending_chat:
                                    search_user_method.invoke(chat_activity, None, self.pending_chat)
                                
                        except:
                            pass
                        
                        self.pending_user = None
                        self.pending_chat = None
                                
                    except:
                        pass
            
            self.hook_search_by_user_id_ref = self.hook_method(search_method, SearchHook(self))
            
        except:
            pass
    
    def _hook_ai_role_limit(self):
        try:
            NEW_LIMIT = 9999
            
            CodepointsLengthInputFilterClass = self._get_class("org.telegram.ui.Components.CodepointsLengthInputFilter")
            if not CodepointsLengthInputFilterClass:
                return
            
            class LimitHook:
                def __init__(self, plugin):
                    self.plugin = plugin
                
                def after_hooked_method(self, param):
                    try:
                        obj = param.thisObject
                        obj_class = obj.getClass()
                        superclass = obj_class.getSuperclass()
                        mMax_field = superclass.getDeclaredField("mMax")
                        mMax_field.setAccessible(True)
                        current_max = mMax_field.getInt(obj)
                        
                        if current_max == 1024:
                            from java.lang.reflect import Field, Modifier
                            modifiers_field = Field.getClass().getDeclaredField("accessFlags")
                            modifiers_field.setAccessible(True)
                            modifiers_field.setInt(mMax_field, mMax_field.getModifiers() & ~Modifier.FINAL)
                            mMax_field.setInt(obj, NEW_LIMIT)
                    except:
                        pass
            
            from java.lang import Integer
            java_class = CodepointsLengthInputFilterClass.getClass()
            constructor = java_class.getDeclaredConstructor(Integer.TYPE)
            self.hook_ai_role_limit_constructor_ref = self.hook_method(constructor, LimitHook(self))
            
            class SetTextHook:
                def before_hooked_method(self, param):
                    try:
                        if len(param.args) > 0 and param.args[0]:
                            text = str(param.args[0])
                            if "1024" in text:
                                new_text = text.replace("1024", str(NEW_LIMIT))
                                param.args[0] = new_text
                    except:
                        pass
            
            OutlineTextContainerViewClass = find_class("org.telegram.ui.Components.OutlineTextContainerView")
            if OutlineTextContainerViewClass:
                StringClass = find_class("java.lang.String")
                setText_method = OutlineTextContainerViewClass.getClass().getDeclaredMethod("setText", StringClass)
                self.hook_ai_role_limit_settext_ref = self.hook_method(setText_method, SetTextHook())
                logging.info(f"Hook registered: _hook_ai_role_limit_settext")
            
        except:
            pass
    
    def _hook_sleep_timer(self):
        try:
            AudioPlayerAlert = find_class("org.telegram.ui.Components.AudioPlayerAlert")
            if not AudioPlayerAlert:
                return
            Context = jclass("android.content.Context")
            Theme_ResourcesProvider = jclass("org.telegram.ui.ActionBar.Theme$ResourcesProvider")
            
            constructor = AudioPlayerAlert.getClass().getDeclaredConstructor(Context, Theme_ResourcesProvider)
            constructor.setAccessible(True)
            self.hook_sleep_timer_ref = self.hook_method(constructor, SleepTimerConstructorHook(self))
            
            from java.lang import Integer
            onSubItemClick = AudioPlayerAlert.getClass().getDeclaredMethod("onSubItemClick", Integer.TYPE)
            onSubItemClick.setAccessible(True)
            self.hook_sleep_timer_click_ref = self.hook_method(onSubItemClick, SleepTimerClickHook(self))
        except Exception as e:
            pass
    
    def _hook_adaptive_audio_length(self):
        try:
            ChatMessageCellClass = self._get_class("org.telegram.ui.Cells.ChatMessageCell")
            if not ChatMessageCellClass:
                return
            
            self.hook_adaptive_audio_ref = self.hook_all_methods(
                ChatMessageCellClass,
                "setMessageContent",
                AdaptiveAudioHook(self),
                priority=50
            )
            logging.info(f"Hook registered: _hook_adaptive_audio")
            
        except:
            pass
    
    def _hook_music_speed_control(self):
        try:
            FragmentContextViewClass = self._get_class("org.telegram.ui.Components.FragmentContextView")
            if not FragmentContextViewClass:
                return
            
            methods = FragmentContextViewClass.getClass().getDeclaredMethods()
            for m in methods:
                if m.getName() == "checkPlayer" and len(m.getParameterTypes()) == 1:
                    self.hook_music_speed_control_ref = self.hook_method(m, MusicSpeedControlHook(self))
                    logging.info(f"Hook registered: _hook_music_speed_control")
                    break
        except:
            pass
    
    def _hook_custom_saved_messages(self):
        ChatActivityClass = self._get_class("org.telegram.ui.ChatActivity")
        if not ChatActivityClass:
            return
        
        from java import jclass
        method = ChatActivityClass.getClass().getDeclaredMethod(
            "forwardMessages",
            jclass("java.util.ArrayList"),
            jclass("java.lang.Boolean").TYPE,
            jclass("java.lang.Boolean").TYPE,
            jclass("java.lang.Boolean").TYPE,
            jclass("java.lang.Integer").TYPE,
            jclass("java.lang.Long").TYPE,
            jclass("java.lang.Long").TYPE
        )
        method.setAccessible(True)
        
        plugin_ref = weakref.ref(self)
        
        class CustomSavedMessagesHook:
            def before_hooked_method(self, param):
                plugin = plugin_ref()
                if plugin and len(param.args) >= 6:
                    client_id = param.thisObject.getUserConfig().getClientUserId()
                    if param.args[5] == client_id:
                        custom_id = plugin._get_custom_saved_chat_id()
                        if custom_id != client_id:
                            param.args[5] = custom_id
        
        self.hook_custom_saved_messages_ref = self.hook_method(method, CustomSavedMessagesHook())
    
    def _get_custom_saved_chat_id(self):
        if self.get_setting("enable_custom_saved_messages", False) and self.custom_saved_chat_id:
            return self.custom_saved_chat_id
        return UserConfig.getInstance(UserConfig.selectedAccount).clientUserId
    
    def _handle_forward_mode_change(self, setting_key, enabled):
        if enabled:
            other_key = "enable_share_alert_forward" if setting_key == "enable_old_forward" else "enable_old_forward"
            self.set_setting(other_key, False, reload_settings=True)
        self._apply_hooks()
    
    def _select_custom_saved_chat(self):
        fragment = get_last_fragment()
        if not fragment:
            return
        
        args = Bundle()
        args.putBoolean("onlySelect", True)
        args.putBoolean("allowGlobalSearch", False)
        args.putBoolean("resetDelegate", False)
        args.putBoolean("closeFragment", True)
        
        dialogs_activity = DialogsActivity(args)
        
        from java import dynamic_proxy
        plugin_ref = weakref.ref(self)
        
        class CustomSavedChatDelegate(dynamic_proxy(DialogsActivity.DialogsActivityDelegate)):
            def __init__(self, plugin_instance):
                super().__init__()
                self.plugin_ref = weakref.ref(plugin_instance)
            
            def didSelectDialogs(self, fragment, dids, message, param, notify, scheduleDate, topicsFragment):
                plugin = self.plugin_ref()
                if plugin and dids and dids.size() > 0:
                    plugin.custom_saved_chat_id = dids.get(0).dialogId
                    plugin.set_setting("custom_saved_chat_id", plugin.custom_saved_chat_id, reload_settings=True)
                    fragment.finishFragment(True)
                return True
            
            def canSelectStories(self):
                return False
        
        dialogs_activity.setDelegate(CustomSavedChatDelegate(self))
        fragment.presentFragment(dialogs_activity)
    
    def _get_custom_saved_chat_name(self):
        if not self.custom_saved_chat_id:
            return "Not selected"
        
        mc = MessagesController.getInstance(UserConfig.selectedAccount)
        if self.custom_saved_chat_id < 0:
            chat = mc.getChat(-self.custom_saved_chat_id)
            return getattr(chat, 'title', "Unknown") if chat else "Unknown"
        
        user = mc.getUser(self.custom_saved_chat_id)
        if user:
            return f"{getattr(user, 'first_name', '') or ''} {getattr(user, 'last_name', '') or ''}".strip() or "Unknown"
        return "Unknown"
    
    def _hook_disable_emoji_suggestions(self):
        try:
            SuggestEmojiViewClass = self._get_class("org.telegram.ui.Components.SuggestEmojiView")
            if not SuggestEmojiViewClass:
                return
            
            JavaClass = SuggestEmojiViewClass.getClass()
            
            update_method = JavaClass.getDeclaredMethod("update")
            self.hook_disable_emoji_suggestions_ref = self.hook_method(update_method, DisableEmojiSuggestionsHook())
            
            fire_update_method = JavaClass.getDeclaredMethod("fireUpdate")
            self.hook_method(fire_update_method, DisableFireUpdateHook())
            
            StringClass = self._get_class("java.lang.String")
            searchKeywords_method = JavaClass.getDeclaredMethod("searchKeywords", StringClass)
            self.hook_method(searchKeywords_method, DisableEmojiSuggestionsHook())
            
            searchAnimated_method = JavaClass.getDeclaredMethod("searchAnimated", StringClass)
            self.hook_method(searchAnimated_method, DisableEmojiSuggestionsHook())
        except Exception as e:
            pass
    
    def _hook_message_swipe_action(self):
        try:
            ChatActivityClass = self._get_class("org.telegram.ui.ChatActivity")
            MessageObjectClass = self._get_class("org.telegram.messenger.MessageObject")
            
            show_reply_method = ChatActivityClass.getClass().getDeclaredMethod("showFieldPanelForReply", MessageObjectClass)
            show_reply_method.setAccessible(True)
            
            handler_instance = SwipeReplyHook(self)
            self.hook_message_swipe_action_ref = self.hook_method(show_reply_method, handler_instance, priority=10)
            
            try:
                MotionEventClass = self._get_class("android.view.MotionEvent")
                ViewClass = self._get_class("android.view.View")
                dispatch_touch_method = ViewClass.getClass().getDeclaredMethod("dispatchTouchEvent", MotionEventClass)
                dispatch_touch_method.setAccessible(True)
                
                motion_handler = MotionEventSwipeHook(self)
                self.hook_method(dispatch_touch_method, motion_handler, priority=10)
            except Exception as e:
                pass
            
        except Exception as e:
            pass
    
    def _save_to_saved_messages(self, chat_activity, message_object):
        try:
            current_account = UserConfig.selectedAccount
            saved_messages_id = UserConfig.getInstance(current_account).getClientUserId()
            
            messages_list = jclass("java.util.ArrayList")()
            messages_list.add(message_object)
            
            send_helper = get_send_messages_helper()
            send_helper.sendMessage(messages_list, saved_messages_id, False, False, True, 0, 0)
            
            try:
                BulletinHelper.show_simple(
                    LocaleController.getString("FwdMessageToSavedMessages", R_tg.string.FwdMessageToSavedMessages),
                    R_tg.raw.saved_messages,
                    chat_activity
                )
            except Exception as bulletin_error:
                pass
            
        except Exception as e:
            pass
    
    def _show_translate_alert(self, chat_activity, message_object):
        try:
            message_text = message_object.messageOwner.message
            if not message_text:
                return
            
            current_account = UserConfig.selectedAccount
            from_lang = "auto"
            TranslateAlert2 = jclass("org.telegram.ui.Components.TranslateAlert2")
            to_lang = TranslateAlert2.getToLanguage()
            
            entities_list = jclass("java.util.ArrayList")()
            
            alert = TranslateAlert2.showAlert(
                chat_activity.getParentActivity(),
                chat_activity,
                current_account,
                from_lang,
                to_lang,
                message_text,
                entities_list,
                False,
                None,
                None
            )
            
        except Exception as e:
            pass
    
    def _show_share_alert(self, chat_activity, message_object):
        try:
            current_chat = get_private_field(chat_activity, "currentChat")
            is_channel = ChatObject.isChannel(current_chat) if current_chat else False
            class_guid = get_private_field(chat_activity, "classGuid")
            
            messages_list = jclass("java.util.ArrayList")()
            messages_list.add(message_object)
            
            ShareAlert = jclass("org.telegram.ui.Components.ShareAlert")
            share_alert = ShareAlert(
                chat_activity.getParentActivity(),
                messages_list,
                None,
                is_channel,
                None,
                False
            )
            
            chat_activity.showDialog(share_alert)
            
            AndroidUtilities.setAdjustResizeToNothing(chat_activity.getParentActivity(), class_guid)
            chat_activity.getFragmentView().requestLayout()
            
        except Exception as e:
            pass
    
    def _hook_remove_https_from_links(self):
        try:
            ClipboardManagerClass = find_class("android.content.ClipboardManager")
            ClipDataClass = find_class("android.content.ClipData")
            set_primary_clip_method = ClipboardManagerClass.getClass().getDeclaredMethod("setPrimaryClip", ClipDataClass)
            self.hook_remove_https_from_links_ref = self.hook_method(set_primary_clip_method, RemoveHttpsHook())
        except Exception as e:
            pass
    
    def _hook_join_request_direct_profile(self):
        try:
            delegate_class = find_class("org.telegram.ui.Delegates.MemberRequestsDelegate")
            
            if not delegate_class:
                return
            
            view_class = find_class("android.view.View")
            int_type = jclass("java.lang.Integer").TYPE
            
            method = delegate_class.getClass().getDeclaredMethod(
                "onItemClick",
                view_class,
                int_type
            )
            
            if not method:
                return
                
            self.hook_join_request_direct_profile_ref = self.hook_method(method, DirectProfileHook(self))
            
        except Exception:
            pass
    
    def _on_notification_sound_change(self, value):
        self._play_preview(value)
        self._apply_hooks()
    
    def _on_vibration_change(self, value):
        self._vibrate_preview(value)
        self._apply_hooks()
    
    def _ensure_ios_sound(self):
        try:
            from file_utils import get_files_dir
            files_dir = get_files_dir()
            self.ios_sound_path = os.path.join(files_dir, "custom_received.mp3")
            
            if not os.path.exists(self.ios_sound_path):
                branch_index = self.get_setting("update_branch", 0)
                branch = "main" if branch_index == 0 else "Beta"
                IOS_SOUND_URL = f"https://raw.githubusercontent.com/luvztroy/UiTweaks/{branch}/Assets/Audio/Custom%20received.mp3"
                urllib.request.urlretrieve(IOS_SOUND_URL, self.ios_sound_path)
        except Exception as e:
            pass
    
    def _hook_play_in_chat_sound(self):
        try:
            NotificationsController = self._get_class("org.telegram.messenger.NotificationsController")
            if not NotificationsController:
                return
            
            java_class = NotificationsController.getClass()
            method = java_class.getDeclaredMethod("playInChatSound")
            method.setAccessible(True)
            
            self.hook_play_sound_ref = self.hook_method(method, PlaySoundHook(self))
        except Exception as e:
            pass
    
    def _hook_soundpool_load(self):
        try:
            SoundPool = jclass("android.media.SoundPool")
            java_class = SoundPool.getClass()
            
            Context = jclass("android.content.Context")
            int_type = jclass("java.lang.Integer").TYPE
            
            method = java_class.getDeclaredMethod("load", Context, int_type, int_type)
            method.setAccessible(True)
            
            self.hook_soundpool_load_ref = self.hook_method(method, SoundPoolLoadHook(self))
        except Exception as e:
            pass
    
    def _vibrate_preview(self, vibrate_type):
        try:
            if vibrate_type == 0:
                return
            
            Vibrator = jclass("android.os.Vibrator")
            ApplicationLoader = self._get_class("org.telegram.messenger.ApplicationLoader")
            context = ApplicationLoader.applicationContext
            vibrator = context.getSystemService("vibrator")
            
            if vibrate_type == 1:
                vibrator.vibrate(30)
            elif vibrate_type == 2:
                vibrator.vibrate(50)
            elif vibrate_type == 3:
                pattern = [0, 50, 50, 50]
                vibrator.vibrate(pattern, -1)
            elif vibrate_type == 4:
                vibrator.vibrate(200)
        except Exception as e:
            pass
    
    def _play_preview(self, sound_type):
        try:
            if sound_type == 0:
                return
            
            from android.media import MediaPlayer
            ApplicationLoader = find_class("org.telegram.messenger.ApplicationLoader")
            context = ApplicationLoader.applicationContext
            
            mp = None
            
            if sound_type == 1:
                R = find_class("org.telegram.messenger.R")
                mp = MediaPlayer.create(context, R.raw.sound_in)
            elif sound_type == 2:
                if os.path.exists(self.ios_sound_path):
                    mp = MediaPlayer()
                    mp.setDataSource(self.ios_sound_path)
                    mp.prepare()
            
            if mp:
                mp.start()
        except Exception as e:
            pass
    
    def play_ios_sound(self, soundpool):
        try:
            if not os.path.exists(self.ios_sound_path):
                return
            
            if self.soundpool_instance != soundpool or self.ios_sound_id is None:
                self.soundpool_instance = soundpool
                self.ios_sound_id = soundpool.load(self.ios_sound_path, 1)
            
            if self.ios_sound_id:
                AudioManager = find_class("android.media.AudioManager")
                ApplicationLoader = find_class("org.telegram.messenger.ApplicationLoader")
                context = ApplicationLoader.applicationContext
                audio_manager = context.getSystemService("audio")
                
                max_volume = audio_manager.getStreamMaxVolume(AudioManager.STREAM_NOTIFICATION)
                current_volume = audio_manager.getStreamVolume(AudioManager.STREAM_NOTIFICATION)
                volume_ratio = float(current_volume) / float(max_volume) if max_volume > 0 else 1.0
                
                soundpool.play(self.ios_sound_id, volume_ratio, volume_ratio, 1, 0, 1.0)
        except Exception as e:
            pass
    
    def _open_pinned_reactions_settings_ui(self, view=None):
        try:
            from client_utils import get_last_fragment
            from com.exteragram.messenger.plugins.ui.components.templates import UniversalFragment
            
            fragment = get_last_fragment()
            if fragment is None:
                return
            
            delegate = PinnedReactionsDelegate(self)
            custom_fragment = UniversalFragment(delegate)
            fragment.presentFragment(custom_fragment)
            
        except Exception:
            pass
    
    def _normalize_emoji(self, emoji_str):
        normalized = emoji_str.replace("\uFE0F", "")
        
        skin_tones = ["\U0001F3FB", "\U0001F3FC", "\U0001F3FD", "\U0001F3FE", "\U0001F3FF"]
        for tone in skin_tones:
            normalized = normalized.replace(tone, "")
        
        return normalized
    
    def _hook_pinned_reactions(self):
        try:
            ReactionsContainerLayoutClass = jclass("org.telegram.ui.Components.ReactionsContainerLayout")
            
            Boolean = jclass("java.lang.Boolean")
            
            setVisibleReactionsList = ReactionsContainerLayoutClass.getClass().getDeclaredMethod(
                "setVisibleReactionsList",
                jclass("java.util.List"),
                Boolean.TYPE
            )
            setVisibleReactionsList.setAccessible(True)
            
            self.hook_reactions_container_ref = self.hook_method(setVisibleReactionsList, SetVisibleReactionsListHook(self))
        except Exception:
            pass
    
    def get_pinned_reactions(self, is_channel):
        if is_channel:
            if self.get_setting("pinned_reactions_enabled_channels", "true") != "true":
                return []
            reactions_json = self.get_setting("pinned_reactions_channels", "[]")
        else:
            if self.get_setting("pinned_reactions_enabled_chats", "true") != "true":
                return []
            reactions_json = self.get_setting("pinned_reactions_chats", "[]")
        
        try:
            reactions_data = json.loads(reactions_json)
            return self._json_to_visible_reactions(reactions_data)
        except Exception:
            return []
    
    def save_pinned_reactions(self, is_channel, reactions_list):
        normalized_reactions = []
        for reaction in reactions_list[:7]:
            if "emoticon" in reaction:
                normalized_reactions.append({
                    "emoticon": self._normalize_emoji(reaction["emoticon"])
                })
            else:
                normalized_reactions.append(reaction)
        
        reactions_json = json.dumps(normalized_reactions)
        
        if is_channel:
            self.set_setting("pinned_reactions_channels", reactions_json)
        else:
            self.set_setting("pinned_reactions_chats", reactions_json)
    
    def _json_to_visible_reactions(self, reactions_data):
        VisibleReaction = jclass("org.telegram.ui.Components.Reactions.ReactionsLayoutInBubble$VisibleReaction")
        String = jclass("java.lang.String")
        visible_reactions = []
        
        for reaction_dict in reactions_data:
            try:
                reaction = VisibleReaction()
                
                if "emoticon" in reaction_dict:
                    normalized_emoji = self._normalize_emoji(reaction_dict["emoticon"])
                    reaction.emojicon = normalized_emoji
                    java_string = String(normalized_emoji)
                    reaction.hash = java_string.hashCode()
                elif "document_id" in reaction_dict:
                    reaction.documentId = reaction_dict["document_id"]
                    reaction.hash = reaction.documentId
                else:
                    continue
                
                visible_reactions.append(reaction)
            except Exception:
                continue
        
        return visible_reactions
    
    def _hook_share_alert_forward(self):
        try:
            ChatActivity = find_class("org.telegram.ui.ChatActivity")
            activity_class = ChatActivity.getClass()
            
            method1 = activity_class.getDeclaredMethod("openForward", jclass("java.lang.Boolean").TYPE)
            method1.setAccessible(True)
            self.hook_share_alert_forward_open_ref = self.hook_method(method1, OpenForwardHook())
            
            method2 = activity_class.getDeclaredMethod("processSelectedOption", jclass("java.lang.Integer").TYPE)
            method2.setAccessible(True)
            self.hook_share_alert_forward_process_ref = self.hook_method(method2, ProcessSelectedOptionHook())
        except Exception:
            pass
    
    def _hook_disable_link_preview(self):
        try:
            self._hook_chat_activity_search_links()
            self._hook_chat_activity_enter_view_constructor()
            self._hook_send_message_params_init()
        except Exception as e:
            pass
    
    def _hook_chat_activity_search_links(self):
        try:
            ChatActivity = find_class("org.telegram.ui.ChatActivity")
            if not ChatActivity:
                return
            
            CharSequence = jclass("java.lang.CharSequence")
            boolean_type = jclass("java.lang.Boolean").TYPE
            
            search_links_method = ChatActivity.getClass().getDeclaredMethod(
                "searchLinks", 
                CharSequence, 
                boolean_type
            )
            search_links_method.setAccessible(True)
            
            self.hook_search_links_ref = self.hook_method(search_links_method, SearchLinksReplacement(self))
            
        except Exception as e:
            pass
    
    def _hook_chat_activity_enter_view_constructor(self):
        try:
            ChatActivityEnterView = self._get_class("org.telegram.ui.Components.ChatActivityEnterView")
            if not ChatActivityEnterView:
                return
            
            constructors = ChatActivityEnterView.getClass().getDeclaredConstructors()
            for constructor in constructors:
                try:
                    constructor.setAccessible(True)
                    self.hook_enter_view_constructor_ref = self.hook_method(constructor, EnterViewConstructorHook())
                except:
                    continue
                    
        except Exception as e:
            pass
    
    def _hook_send_message_params_init(self):
        try:
            SendMessagesHelper = self._get_class("org.telegram.messenger.SendMessagesHelper")
            if not SendMessagesHelper:
                return
            
            inner_classes = SendMessagesHelper.getClass().getDeclaredClasses()
            SendMessageParams = None
            for inner_class in inner_classes:
                if inner_class.getSimpleName() == "SendMessageParams":
                    SendMessageParams = inner_class
                    break
            
            if not SendMessageParams:
                return
            
            methods = SendMessageParams.getDeclaredMethods()
            for method in methods:
                try:
                    if method.getName() == "of" and method.getReturnType() == SendMessageParams:
                        method.setAccessible(True)
                        self.hook_send_message_params_ref = self.hook_method(method, SendMessageParamsHook())
                except:
                    continue
                    
        except Exception as e:
            pass
    
    def _hook_search_filter(self):
        try:
            ChatActivityClass = self._get_class("org.telegram.ui.ChatActivity")
            if not ChatActivityClass:
                return
            
            String_class = jclass("java.lang.String")
            open_search_method = ChatActivityClass.getClass().getDeclaredMethod(
                "openSearchWithText",
                String_class
            )
            
            if open_search_method:
                self.hook_search_filter_open_search_ref = self.hook_method(open_search_method, SearchFilterOpenSearchHook(self))
            
            ConnectionsManagerClass = self._get_class("org.telegram.tgnet.ConnectionsManager")
            if ConnectionsManagerClass:
                TLObject_class = self._get_class("org.telegram.tgnet.TLObject")
                RequestDelegate_class = self._get_class("org.telegram.tgnet.RequestDelegate")
                int_type = jclass("java.lang.Integer").TYPE
                
                try:
                    send_request_method = ConnectionsManagerClass.getClass().getDeclaredMethod(
                        "sendRequest",
                        TLObject_class, RequestDelegate_class, int_type
                    )
                    
                    if send_request_method:
                        self.hook_search_filter_send_request_ref = self.hook_method(send_request_method, SearchFilterSendRequestHook(self))
                except:
                    pass
                
        except:
            pass
    
    def _create_search_filter_button(self, chat_activity):
        try:
            activity_id = id(chat_activity)
            if activity_id in self.search_filter_buttons:
                return
            
            context = chat_activity.getParentActivity()
            if not context:
                return
            
            search_container = get_private_field(chat_activity, "searchContainer")
            
            if not search_container:
                return
            
            search_filter_button = ImageView(context)
            search_filter_button.setScaleType(ImageView.ScaleType.CENTER)
            search_filter_button.setImageResource(R_tg.drawable.menu_tag_filter_solar)
            
            color = Theme.getColor(Theme.key_chat_searchPanelIcons)
            from android.graphics import PorterDuff, PorterDuffColorFilter
            search_filter_button.setColorFilter(PorterDuffColorFilter(color, PorterDuff.Mode.MULTIPLY))
            
            selector_color = Theme.getColor(Theme.key_actionBarActionModeDefaultSelector)
            search_filter_button.setBackgroundDrawable(Theme.createSelectorDrawable(selector_color, 1))
            
            search_filter_button.setOnClickListener(OnClickListener(lambda v: self._show_search_filter_selector(chat_activity)))
            
            left_margin = 48
            try:
                search_user_button = get_private_field(chat_activity, "searchUserButton")
                if search_user_button:
                    left_margin = 96
                    self._hook_user_search_button_for_filter(search_user_button, search_filter_button, chat_activity)
            except:
                pass
            
            search_container.addView(
                search_filter_button,
                LayoutHelper.createFrame(48, 48, Gravity.LEFT | Gravity.TOP, left_margin, 0, 0, 0)
            )
            
            self.search_filter_buttons[activity_id] = search_filter_button
            
            try:
                search_count_text = get_private_field(chat_activity, "searchCountText")
                if search_count_text:
                    current_padding_left = search_count_text.getPaddingLeft()
                    new_padding_left = current_padding_left + AndroidUtilities.dp(48)
                    search_count_text.setPadding(
                        new_padding_left,
                        search_count_text.getPaddingTop(),
                        search_count_text.getPaddingRight(),
                        search_count_text.getPaddingBottom()
                    )
            except:
                pass
            
        except:
            pass
    
    def _hook_user_search_button_for_filter(self, user_button, filter_button, chat_activity):
        try:
            from android.view import View
            
            original_listener = None
            try:
                ViewClass = find_class("android.view.View")
                mListenerInfoField = ViewClass.getClass().getDeclaredField("mListenerInfo")
                mListenerInfoField.setAccessible(True)
                listenerInfo = mListenerInfoField.get(user_button)
                
                if listenerInfo:
                    ListenerInfoClass = find_class("android.view.View$ListenerInfo")
                    mOnClickListenerField = ListenerInfoClass.getClass().getDeclaredField("mOnClickListener")
                    mOnClickListenerField.setAccessible(True)
                    original_listener = mOnClickListenerField.get(listenerInfo)
            except:
                pass
            
            plugin_ref = self
            
            def on_user_button_click(v):
                try:
                    plugin_ref.search_filter_current = SEARCH_FILTER_NONE
                    plugin_ref.set_setting("messages_search_filter", SEARCH_FILTER_NONE)
                    
                    if filter_button:
                        filter_button.setVisibility(View.GONE)
                    
                    if original_listener:
                        original_listener.onClick(v)
                except:
                    pass
            
            user_button.setOnClickListener(OnClickListener(on_user_button_click))
        except:
            pass
    
    def _show_search_filter_selector(self, chat_activity):
        try:
            activity = chat_activity.getParentActivity()
            if not activity:
                return
            
            filter_names = [
                get_string("search_filter_none", "None"),
                get_string("search_filter_photos", "Photos"),
                get_string("search_filter_videos", "Videos"),
                get_string("search_filter_voice_messages", "Voice Messages"),
                get_string("search_filter_video_messages", "Video Messages"),
                get_string("search_filter_files", "Files"),
                get_string("search_filter_music", "Music"),
                get_string("search_filter_gifs", "GIFs"),
                get_string("search_filter_geolocation", "Geolocation"),
                get_string("search_filter_contacts", "Contacts"),
                get_string("search_filter_my_mentions", "My Mentions")
            ]
            
            filter_values = [
                SEARCH_FILTER_NONE, SEARCH_FILTER_PHOTOS, SEARCH_FILTER_VIDEOS, SEARCH_FILTER_VOICE_MESSAGES,
                SEARCH_FILTER_VIDEO_MESSAGES, SEARCH_FILTER_FILES, SEARCH_FILTER_MUSIC, SEARCH_FILTER_GIFS,
                SEARCH_FILTER_GEO, SEARCH_FILTER_CONTACTS, SEARCH_FILTER_MENTIONS
            ]
            
            current_index = filter_values.index(self.search_filter_current) if self.search_filter_current in filter_values else 0
            
            builder = AlertDialogBuilder(activity)
            builder.set_title(get_string("search_filter", "Search Filter"))
            
            linear_layout = LinearLayout(activity)
            linear_layout.setOrientation(LinearLayout.VERTICAL)
            builder.set_view(linear_layout)
            
            RadioColorCellClass = find_class("org.telegram.ui.Cells.RadioColorCell")
            
            dialog_ref = [None]
            
            for i in range(len(filter_names)):
                cell = RadioColorCellClass(activity)
                cell.setPadding(AndroidUtilities.dp(4), 0, AndroidUtilities.dp(4), 0)
                cell.setTag(i)
                cell.setCheckColor(
                    Theme.getColor(Theme.key_radioBackground),
                    Theme.getColor(Theme.key_dialogRadioBackgroundChecked)
                )
                cell.setTextAndValue(filter_names[i], i == current_index)
                cell.setBackground(Theme.getSelectorDrawable(False))
                linear_layout.addView(cell)
                
                plugin_ref = self
                
                def create_click_listener(index):
                    def on_click(v):
                        try:
                            selected_filter = filter_values[index]
                            plugin_ref.search_filter_current = selected_filter
                            plugin_ref.set_setting("messages_search_filter", selected_filter)
                            
                            chat_activity.openSearchWithText(None)
                            
                            def jump_to_first():
                                try:
                                    from org.telegram.messenger import AccountInstance
                                    account_num = chat_activity.getCurrentAccount()
                                    account = AccountInstance.getInstance(account_num)
                                    media_data_controller = account.getMediaDataController()
                                    
                                    guid = chat_activity.getClassGuid()
                                    media_data_controller.jumpToSearchedMessage(guid, 0)
                                except:
                                    pass
                            
                            from android_utils import R
                            AndroidUtilities.runOnUIThread(R(jump_to_first), 500)
                            
                            if dialog_ref[0]:
                                dialog_ref[0].dismiss()
                        except:
                            pass
                    return on_click
                
                cell.setOnClickListener(OnClickListener(create_click_listener(i)))
            
            builder.set_negative_button(get_string("cancel", "Cancel"), None)
            dialog_ref[0] = builder.show()
            
        except:
            pass
    
    def _get_search_filter_type(self):
        try:
            if self.search_filter_current == SEARCH_FILTER_PHOTOS:
                return TLRPC.TL_inputMessagesFilterPhotos()
            elif self.search_filter_current == SEARCH_FILTER_VIDEOS:
                return TLRPC.TL_inputMessagesFilterVideo()
            elif self.search_filter_current == SEARCH_FILTER_VOICE_MESSAGES:
                return TLRPC.TL_inputMessagesFilterVoice()
            elif self.search_filter_current == SEARCH_FILTER_VIDEO_MESSAGES:
                return TLRPC.TL_inputMessagesFilterRoundVideo()
            elif self.search_filter_current == SEARCH_FILTER_FILES:
                return TLRPC.TL_inputMessagesFilterDocument()
            elif self.search_filter_current == SEARCH_FILTER_MUSIC:
                return TLRPC.TL_inputMessagesFilterMusic()
            elif self.search_filter_current == SEARCH_FILTER_GIFS:
                return TLRPC.TL_inputMessagesFilterGif()
            elif self.search_filter_current == SEARCH_FILTER_GEO:
                return TLRPC.TL_inputMessagesFilterGeo()
            elif self.search_filter_current == SEARCH_FILTER_CONTACTS:
                return TLRPC.TL_inputMessagesFilterContacts()
            elif self.search_filter_current == SEARCH_FILTER_MENTIONS:
                return TLRPC.TL_inputMessagesFilterMyMentions()
            else:
                return TLRPC.TL_inputMessagesFilterEmpty()
        except:
            return TLRPC.TL_inputMessagesFilterEmpty()
    
    def _hook_remove_greeting_sticker(self):
        try:
            ChatActivityClass = self._get_class("org.telegram.ui.ChatActivity")
            if not ChatActivityClass:
                return
            
            BooleanTYPE = self._get_class("java.lang.Boolean").TYPE
            create_empty_view_method = ChatActivityClass.getClass().getDeclaredMethod(
                "createEmptyView",
                BooleanTYPE
            )
            create_empty_view_method.setAccessible(True)
            
            self.hook_remove_greeting_sticker_ref = self.hook_method(create_empty_view_method, RemoveGreetingStickerHook())
        except Exception as e:
            pass
    
    def _hook_select_all_media(self):
        try:
            SharedMediaLayoutClass = self._get_class("org.telegram.ui.Components.SharedMediaLayout")
            if not SharedMediaLayoutClass:
                return
            
            plugin_ref = weakref.ref(self)
            
            class SharedMediaLayoutHook:
                def after_hooked_method(self, param):
                    try:
                        plugin = plugin_ref()
                        if plugin:
                            plugin._add_select_all_button(param.thisObject)
                    except:
                        pass
            
            for constructor in SharedMediaLayoutClass.getClass().getDeclaredConstructors():
                if len(constructor.getParameterTypes()) >= 5:
                    constructor.setAccessible(True)
                    self.hook_select_all_media_ref = self.hook_method(constructor, SharedMediaLayoutHook())
                    break
        except:
            pass
    
    def _add_select_all_button(self, shared_media_layout):
        try:
            action_mode_layout = get_private_field(shared_media_layout, "actionModeLayout")
            action_mode_views = get_private_field(shared_media_layout, "actionModeViews")
            if not action_mode_layout or action_mode_views is None:
                return
            
            select_all_item = ActionBarMenuItem(
                action_mode_layout.getContext(), None,
                Theme.getColor(Theme.key_actionBarActionModeDefaultSelector),
                Theme.getColor(Theme.key_actionBarActionModeDefaultIcon), False
            )
            select_all_item.setIcon(R_tg.drawable.msg_select_between_solar)
            select_all_item.setContentDescription("Select All")
            select_all_item.setDuplicateParentStateEnabled(False)
            select_all_item.setOnClickListener(OnClickListener(lambda v: self._select_all_media(shared_media_layout)))
            
            action_mode_layout.addView(select_all_item, 2, LinearLayout.LayoutParams(AndroidUtilities.dp(54), LinearLayout.LayoutParams.MATCH_PARENT))
            action_mode_views.add(2, select_all_item)
        except:
            pass
    
    def _scroll_and_select(self, shared_media_layout, current_page, selected_files, dialog_id, shared_media_data, media_type):
        try:
            list_view = get_private_field(current_page, "listView")
            if not list_view:
                return
            
            messages = get_private_field(shared_media_data[media_type], "messages")
            total_count = get_private_field(shared_media_data[media_type], "totalCount")
            
            state = {"index": 0, "count": messages.size() if messages else 0, "load_attempts": 0}
            BATCH_SIZE = 20
            MAX_LOAD_ATTEMPTS = 5
            MAX_SELECTION = 100
            
            plugin_ref = weakref.ref(self)
            shared_media_ref = weakref.ref(shared_media_layout)
            
            def step():
                try:
                    plugin = plugin_ref()
                    shared_media = shared_media_ref()
                    if not plugin or not shared_media:
                        return
                    
                    messages_now = get_private_field(shared_media_data[media_type], "messages")
                    if not messages_now:
                        return
                    
                    done = False
                    for _ in range(BATCH_SIZE):
                        i = state["index"]
                        if i >= state["count"]:
                            if state["count"] < total_count and state["count"] < MAX_SELECTION:
                                def attempt_load():
                                    try:
                                        pos = max(0, state["count"] - 1)
                                        list_view.scrollToPosition(pos)
                                        
                                        def check_new_count():
                                            try:
                                                new_messages = get_private_field(shared_media_data[media_type], "messages")
                                                new_count = new_messages.size() if new_messages else 0
                                                if new_count > state["count"]:
                                                    state["count"] = new_count
                                                    state["load_attempts"] = 0
                                                    run_on_ui_thread(step)
                                                else:
                                                    state["load_attempts"] += 1
                                                    if state["load_attempts"] < MAX_LOAD_ATTEMPTS:
                                                        run_on_ui_thread(attempt_load, 300)
                                            except:
                                                pass
                                        run_on_ui_thread(check_new_count, 300)
                                    except:
                                        pass
                                attempt_load()
                            else:
                                def scroll_to_start():
                                    try:
                                        list_view.scrollToPosition(0)
                                    except:
                                        pass
                                run_on_ui_thread(scroll_to_start, 200)
                            return
                        
                        if selected_files[0].size() + selected_files[1].size() >= MAX_SELECTION:
                            def scroll_to_start():
                                try:
                                    list_view.scrollToPosition(0)
                                except:
                                    pass
                            run_on_ui_thread(scroll_to_start, 200)
                            return
                        
                        try:
                            message_obj = messages_now.get(i)
                            state["index"] = i + 1
                            if message_obj:
                                load_index = 0 if message_obj.getDialogId() == dialog_id else 1
                                if selected_files[load_index].indexOfKey(message_obj.getId()) < 0:
                                    selected_files[load_index].put(message_obj.getId(), message_obj)
                        except:
                            pass
                    
                    selected_messages_count_text_view = get_private_field(shared_media, "selectedMessagesCountTextView")
                    if selected_messages_count_text_view:
                        selected_messages_count_text_view.setNumber(selected_files[0].size() + selected_files[1].size(), True)
                    
                    adapter = list_view.getAdapter()
                    if adapter:
                        adapter.notifyDataSetChanged()
                    
                    run_on_ui_thread(step)
                except:
                    pass
            
            run_on_ui_thread(step)
        except:
            pass
    
    def _select_all_media(self, shared_media_layout):
        try:
            media_pages = get_private_field(shared_media_layout, "mediaPages")
            if not media_pages:
                return
            
            scroll_sliding_tab = get_private_field(shared_media_layout, "scrollSlidingTextTabStrip")
            current_tab_id = scroll_sliding_tab.getCurrentTabId() if scroll_sliding_tab else 0
            
            current_page = None
            for page in media_pages:
                if page and get_private_field(page, "selectedType") == current_tab_id:
                    current_page = page
                    break
            
            if not current_page:
                return
            
            list_view = get_private_field(current_page, "listView")
            selected_files = get_private_field(shared_media_layout, "selectedFiles")
            dialog_id = get_private_field(shared_media_layout, "dialog_id")
            shared_media_data = get_private_field(shared_media_layout, "sharedMediaData")
            
            if not list_view or not selected_files or not shared_media_data:
                return
            
            media_type = get_private_field(current_page, "selectedType")
            if media_type >= len(shared_media_data):
                return
            
            messages = get_private_field(shared_media_data[media_type], "messages")
            if not messages:
                return
            
            total_count = get_private_field(shared_media_data[media_type], "totalCount")
            
            self._scroll_and_select(shared_media_layout, current_page, selected_files, dialog_id, shared_media_data, media_type)
        except:
            pass
    
    def _hook_always_visible_schedule_button(self):
        try:
            ChatActivityEnterViewClass = find_class("org.telegram.ui.Components.ChatActivityEnterView")
            if not ChatActivityEnterViewClass:
                return
            
            update_schedule_button_method = ChatActivityEnterViewClass.getClass().getDeclaredMethod(
                "updateScheduleButton",
                find_class("java.lang.Boolean").TYPE
            )
            update_schedule_button_method.setAccessible(True)
            self.hook_always_visible_schedule_button_ref = self.hook_method(update_schedule_button_method, AlwaysVisibleScheduleButtonHook(self))
            
            check_send_button_method = ChatActivityEnterViewClass.getClass().getDeclaredMethod(
                "checkSendButton",
                find_class("java.lang.Boolean").TYPE
            )
            check_send_button_method.setAccessible(True)
            self.hook_check_send_button_ref = self.hook_method(check_send_button_method, CheckSendButtonHook(self))
            
        except Exception as e:
            self.log(f"Error hooking always visible schedule button: {e}")
    
    def _hook_gift_drawer(self):
        try:
            DrawerLayoutAdapter = jclass("org.telegram.ui.Adapters.DrawerLayoutAdapter")
            resetItems_method = DrawerLayoutAdapter.getClass().getDeclaredMethod("resetItems")
            resetItems_method.setAccessible(True)
            
            class DrawerResetHook:
                def __init__(self, plugin):
                    self.plugin = plugin
                
                def after_hooked_method(self, param):
                    try:
                        adapter = param.thisObject
                        items_field = adapter.getClass().getDeclaredField("items")
                        items_field.setAccessible(True)
                        items = items_field.get(adapter)
                        
                        if items is None:
                            return
                        
                        insert_position = -1
                        found_bots = False
                        
                        for i in range(items.size()):
                            item = items.get(i)
                            if item is not None:
                                try:
                                    bot_field = item.getClass().getDeclaredField("bot")
                                    bot_field.setAccessible(True)
                                    bot = bot_field.get(item)
                                    if bot is not None:
                                        found_bots = True
                                except:
                                    pass
                            elif found_bots and item is None:
                                insert_position = i
                                break
                        
                        if insert_position == -1:
                            insert_position = 0
                        
                        current_account = UserConfig.selectedAccount
                        if not UserConfig.getInstance(current_account).isClientActivated():
                            return
                        
                        Item = jclass("org.telegram.ui.Adapters.DrawerLayoutAdapter$Item")
                        gift_icon = R_tg.drawable.menu_gift
                        gift_text = LocaleController.getString(R_tg.string.Gift2TitleSelf1)
                        gift_item = Item(1003, gift_text, gift_icon)
                        items.add(insert_position, gift_item)
                        
                    except Exception:
                        pass
            
            self.hook_gift_drawer_reset_ref = self.hook_method(resetItems_method, DrawerResetHook(self))
            self._hook_gift_drawer_click()
            self._hook_gift_drawer_cell()
            
        except Exception:
            pass
    
    def _hook_gift_drawer_click(self):
        try:
            DrawerLayoutAdapter = jclass("org.telegram.ui.Adapters.DrawerLayoutAdapter")
            click_method = DrawerLayoutAdapter.getClass().getDeclaredMethod("click", 
                jclass("android.view.View"), 
                jclass("java.lang.Integer").TYPE)
            click_method.setAccessible(True)
            
            class DrawerClickHook:
                def __init__(self, plugin):
                    self.plugin = plugin
                
                def before_hooked_method(self, param):
                    try:
                        adapter = param.thisObject
                        position = int(param.args[1])
                        
                        getId_method = adapter.getClass().getDeclaredMethod("getId", jclass("java.lang.Integer").TYPE)
                        getId_method.setAccessible(True)
                        
                        from java.lang import Integer
                        item_id = getId_method.invoke(adapter, Integer(position))
                        
                        if item_id == 1003:
                            self._open_gift_sheet()
                            param.setResult(True)
                            
                    except Exception:
                        pass
                
                def _open_gift_sheet(self):
                    try:
                        def open_sheet():
                            try:
                                current_account = UserConfig.selectedAccount
                                client_user_id = UserConfig.getInstance(current_account).getClientUserId()
                                
                                if not hasattr(LaunchActivity, 'instance') or LaunchActivity.instance is None:
                                    return
                                
                                launch_activity = LaunchActivity.instance
                                
                                getSafeLastFragment_method = launch_activity.getClass().getDeclaredMethod("getSafeLastFragment")
                                getSafeLastFragment_method.setAccessible(True)
                                last_fragment = getSafeLastFragment_method.invoke(launch_activity)
                                
                                if last_fragment is None or last_fragment.getContext() is None:
                                    return
                                
                                GiftSheet = jclass("org.telegram.ui.Gifts.GiftSheet")
                                gift_sheet = GiftSheet(
                                    last_fragment.getContext(),
                                    current_account,
                                    client_user_id,
                                    None,
                                    None
                                )
                                gift_sheet.show()
                                
                            except Exception:
                                pass
                        
                        run_on_ui_thread(open_sheet)
                        
                    except Exception:
                        pass
            
            self.hook_gift_drawer_click_ref = self.hook_method(click_method, DrawerClickHook(self))
            
        except Exception:
            pass
    
    def _hook_gift_drawer_cell(self):
        try:
            DrawerActionCell = jclass("org.telegram.ui.Cells.DrawerActionCell")
            onDraw_method = DrawerActionCell.getClass().getDeclaredMethod("onDraw", jclass("android.graphics.Canvas"))
            onDraw_method.setAccessible(True)
            
            class DrawerCellDrawHook:
                def __init__(self, plugin):
                    self.plugin = plugin
                
                def after_hooked_method(self, param):
                    try:
                        cell = param.thisObject
                        canvas = param.args[0]
                        
                        currentId_field = cell.getClass().getDeclaredField("currentId")
                        currentId_field.setAccessible(True)
                        current_id = currentId_field.getInt(cell)
                        
                        if current_id != 1003:
                            return
                        
                        from org.telegram.ui.Stars import StarsController
                        from android.graphics import RectF
                        
                        current_account = UserConfig.selectedAccount
                        balance = StarsController.getInstance(current_account).getBalance()
                        if balance is None:
                            return
                        
                        counter = balance.amount
                        text = str(counter)
                        
                        star_drawable = cell.getContext().getResources().getDrawable(R_tg.drawable.star_small_inner).mutate()
                        star_size = AndroidUtilities.dp(17)
                        
                        countTop = AndroidUtilities.dp(12.5)
                        textWidth = int(Theme.dialogs_countTextPaint.measureText(text))
                        countWidth = max(AndroidUtilities.dp(10), textWidth + star_size + AndroidUtilities.dp(4))
                        countLeft = cell.getMeasuredWidth() - countWidth - AndroidUtilities.dp(25)
                        
                        x = countLeft - AndroidUtilities.dp(5.5)
                        
                        rect = RectF()
                        rect.set(x, countTop, x + countWidth + AndroidUtilities.dp(14), countTop + AndroidUtilities.dp(23))
                        
                        canvas.drawRoundRect(rect, 11.5 * AndroidUtilities.density, 11.5 * AndroidUtilities.density, Theme.dialogs_countGrayPaint)
                        
                        text_x = rect.left + (rect.width() - textWidth - star_size - AndroidUtilities.dp(4)) / 2
                        canvas.drawText(text, text_x, countTop + AndroidUtilities.dp(16), Theme.dialogs_countTextPaint)
                        
                        star_x = int(text_x + textWidth + AndroidUtilities.dp(4))
                        star_y = int(countTop + (AndroidUtilities.dp(23) - star_size) / 2)
                        star_drawable.setBounds(star_x, star_y, star_x + star_size, star_y + star_size)
                        star_drawable.draw(canvas)
                        
                    except Exception:
                        pass
            
            self.hook_gift_drawer_cell_ref = self.hook_method(onDraw_method, DrawerCellDrawHook(self))
            
        except Exception:
            pass
    
    def pre_request_hook(self, request_name: str, account: int, request):
        if request_name == "TL_messages_forwardMessages" and self.current_mode == "no_quote" and hasattr(request, 'drop_author'):
            request.drop_author = True
            self.current_mode = "forward"
            return HookResult(strategy=HookStrategy.MODIFY, request=request)
        
        if request_name == "TL_messages_forwardMessages" and self.current_mode == "hide_caption" and hasattr(request, 'drop_media_captions'):
            request.drop_media_captions = True
            request.drop_author = True
            self.current_mode = "forward"
            return HookResult(strategy=HookStrategy.MODIFY, request=request)
        
        if request_name == "TL_messages_forwardMessages" and self.get_setting("send_comments_after_forward", False):
            if not hasattr(request, "to_peer") or request.to_peer is None:
                return HookResult()
            try:
                peer = DialogObject.getPeerDialogId(request.to_peer)
            except Exception:
                return HookResult()
            if not peer:
                return HookResult()
            entry = self._send_comments_pending.pop(peer, None)
            if entry is not None:
                params, acc = entry
                def after_forward():
                    def send_on_main_thread():
                        self._send_comments_bypass = True
                        try:
                            SendMessagesHelper.getInstance(acc).sendMessage(params)
                        except Exception:
                            pass
                        finally:
                            self._send_comments_bypass = False
                    run_on_ui_thread(send_on_main_thread)
                run_on_queue(after_forward, PLUGINS_QUEUE, 400)
            return HookResult()
        
        return HookResult()
    
    def on_send_message_hook(self, account: int, params: any):
        from base_plugin import HookResult, HookStrategy
        message = getattr(params, "message", "")
        
        if not isinstance(message, str) or not message:
            return HookResult()
        
        if self.get_setting("send_comments_after_forward", False) and not self._send_comments_bypass:
            if not hasattr(params, "message") or not isinstance(params.message, str):
                return HookResult()
            if not params.message:
                return HookResult()
            if not hasattr(params, "peer") or not params.peer:
                return HookResult()
            try:
                LaunchActivity = jclass("org.telegram.ui.LaunchActivity")
                ChatActivity = jclass("org.telegram.ui.ChatActivity")
                DialogsActivity = jclass("org.telegram.ui.DialogsActivity")
                ShareAlert = jclass("org.telegram.ui.Components.ShareAlert")
                fragment = LaunchActivity.getLastFragment()
            except Exception:
                return HookResult()
            if fragment is None:
                return HookResult()
            should_intercept = False
            try:
                if isinstance(fragment, ChatActivity):
                    preview = get_private_field(fragment, "messagePreviewParams")
                    if preview is not None:
                        forward = getattr(preview, "forwardMessages", None)
                        if forward is not None:
                            messages = getattr(forward, "messages", None)
                            try:
                                has_forward = messages is not None and not messages.isEmpty()
                            except Exception:
                                has_forward = False
                            if has_forward:
                                should_intercept = True
                    
                    visibleDialog = get_private_field(fragment, "visibleDialog")
                    if visibleDialog is not None and isinstance(visibleDialog, ShareAlert):
                        sendingMessageObjects = get_private_field(visibleDialog, "sendingMessageObjects")
                        if sendingMessageObjects is not None and not sendingMessageObjects.isEmpty():
                            should_intercept = True
                
                elif isinstance(fragment, DialogsActivity):
                    dialogs_type = get_private_field(fragment, "dialogsType")
                    forward_type = getattr(DialogsActivity, "DIALOGS_TYPE_FORWARD", None)
                    if dialogs_type == forward_type:
                        should_intercept = True
            
            except Exception:
                should_intercept = False
            
            if not should_intercept:
                return HookResult()
            
            peer = params.peer
            self._send_comments_pending[peer] = (params, account)
            return HookResult(strategy=HookStrategy.CANCEL)
        
        return HookResult()

    def _show_performance_warning(self):
        try:
            client_name = "AyuGram"
            try:
                ctx = ApplicationLoader.applicationContext
                pkg = ctx.getPackageName()
                if pkg == "com.exteragram.messenger":
                    client_name = "exteraGram"
            except Exception:
                pass
            
            description_template = get_string("performance_warning_description", 
                "UiTweaks adds advanced features in {client_name} but may impact device performance over time.")
            description_text = description_template.replace("{client_name}", client_name)

            memory_warning_enabled = self.get_setting("enable_memory_warning", True)
            button_text = get_string("disable_memory_warning", "Disable Memory Warning") if memory_warning_enabled else get_string("enable_memory_warning", "Enable Memory Warning")

            def on_button_click():
                current_setting = self.get_setting("enable_memory_warning", True)
                self.set_setting("enable_memory_warning", not current_setting)
                self._apply_hooks()

            def on_sticker_long_click(bottom_sheet_instance=None):
                self._perform_haptic()
                current_debug_setting = self.get_setting("show_logs", False)
                new_debug_setting = not current_debug_setting
                self.set_setting("show_logs", new_debug_setting)
                
                if bottom_sheet_instance and hasattr(bottom_sheet_instance, 'update_status'):
                    enabled_text = get_string("enabled", "Enabled")
                    disabled_text = get_string("disabled", "Disabled")
                    debug_logging_text = get_string("debug_logging", "Debug logging")
                    status_text = f"{debug_logging_text}: {enabled_text if new_debug_setting else disabled_text}"
                    bottom_sheet_instance.update_status(status_text)

            showupdatebottomsheet(
                title=get_string("performance_warning", "Performance Warning"),
                subtitle=get_string("performance_warning_subtitle", "Important Information"),
                description=description_text,
                github_url=None,
                plugin_name="UiTweaks_PerformanceInfo",
                sticker_pack="lidreron",
                sticker_index=26,
                button_text=button_text,
                on_button_click=on_button_click,
                on_sticker_long_click=on_sticker_long_click,
                bottom_text=get_string("performance_warning_footer", 
                    "For optimal performance, consider reviewing your enabled features regularly and keeping only what you need active."),
                show_user_avatar=False,
                description_centered=True
            )
        except Exception as e:
            self.log(f"Error showing performance warning: {e}")

    def _show_confirmation_selector(self):
        confirmation_items = [
            get_string("item_stickers", "Stickers"),
            get_string("item_voice_messages", "Voice Messages"), 
            get_string("item_bot_commands", "Bot Commands"),
            get_string("item_video_messages", "Video Messages"),
            get_string("item_video_files", "Video Files"),
            get_string("item_photos", "Photos"),
            get_string("item_documents", "Documents"),
            get_string("item_gifs", "GIFs"),
            get_string("item_forward", "Forward"),
            get_string("item_join_chat", "Join Chat"),
            get_string("item_external_links", "External Links")
        ]
        
        confirmation_keys = [
            "confirm_stickers", "confirm_voice", "confirm_commands", "confirm_round_video",
            "confirm_video_file", "confirm_photo", "confirm_document", "confirm_gif", 
            "confirm_forward", "confirm_join_chat", "confirm_external_links"
        ]
        
        showmultiselector(
            items=confirmation_items,
            title=get_string("confirmation_settings", "Confirmation Settings"),
            subtitle=get_string("select_items", "Select which actions require confirmation"),
            setting_keys=confirmation_keys,
            plugin_instance=self,
            action_text=get_string("apply", "Apply")
        )

    def _show_star_reaction_selector(self):
        star_reaction_items = [
            get_string("item_reaction_menu", "Reaction Menu"),
            get_string("item_message_cells", "Message Cells")
        ]
        
        star_reaction_keys = [
            "star_reaction_hide_menu", "star_reaction_hide_cells"
        ]
        
        showmultiselector(
            items=star_reaction_items,
            title=get_string("star_reaction_hide_location", "Hide Star Reactions From"),
            subtitle=get_string("select_items", "Select where to hide star reactions"),
            setting_keys=star_reaction_keys,
            plugin_instance=self,
            action_text=get_string("apply", "Apply")
        )

    def _show_progress_timestamp_selector(self):
        progress_timestamp_items = [
            get_string("progress_timestamp_voice", "Voice Messages"),
            get_string("progress_timestamp_video", "Video Messages")
        ]
        
        progress_timestamp_keys = [
            "voice_message_time_display", "round_video_time_display"
        ]
        
        showmultiselector(
            items=progress_timestamp_items,
            title=get_string("progress_timestamp_types", "Message Types"),
            subtitle=get_string("progress_timestamp_subtitle", "Select message types"),
            setting_keys=progress_timestamp_keys,
            plugin_instance=self,
            action_text=get_string("apply", "Apply")
        )

    def _handle_long_click_with_enable(self, setting_key, selector_callback):
        if not self.get_setting(setting_key, False):
            self.set_setting(setting_key, True, reload_settings=True)
        selector_callback()

    def _show_dont_auto_play_selector(self):
        dont_auto_play_items = [
            get_string("dont_auto_play_voice", "Voice Messages"),
            get_string("dont_auto_play_video", "Video Messages")
        ]
        
        dont_auto_play_keys = [
            "dont_auto_play_next_voice", "dont_auto_play_next_video"
        ]
        
        showmultiselector(
            items=dont_auto_play_items,
            title=get_string("dont_auto_play_types", "Message Types"),
            subtitle=get_string("dont_auto_play_subtitle", "Select message types"),
            setting_keys=dont_auto_play_keys,
            plugin_instance=self,
            action_text=get_string("apply", "Apply")
        )

    def _setup_confirmation_hooks(self):
        try:
            send_helper_instance = get_send_messages_helper()
            if not send_helper_instance:
                pass
                return
            send_helper_class = send_helper_instance.getClass()

            send_params_class = jclass("org.telegram.messenger.SendMessagesHelper$SendMessageParams")

            send_message_method = send_helper_class.getDeclaredMethod("sendMessage", send_params_class)
            send_message_method.setAccessible(True)

            self.unhook_send_message = self.hook_method(send_message_method, self.hook_handler)
            pass
            
            chat_enter_view_class = self._get_class("org.telegram.ui.Components.ChatActivityEnterView")
            set_command_method = chat_enter_view_class.getClass().getDeclaredMethod("setCommand", 
                self._get_class("org.telegram.messenger.MessageObject").getClass(),
                self._get_class("java.lang.String").getClass(),
                self._get_class("java.lang.Boolean").TYPE,
                self._get_class("java.lang.Boolean").TYPE)
            set_command_method.setAccessible(True)
            
            self.unhook_set_command = self.hook_method(set_command_method, SetCommandHook(self))
            
        except Exception as e:
            pass

    def _setup_deeplink_hooks(self):
        try:
            if self.get_setting("confirm_deeplinks", False) or self.get_setting("confirm_ayugram_deeplinks", False):
                launch_activity_cls = self._get_class("org.telegram.ui.LaunchActivity")
                
                method = launch_activity_cls.getClass().getDeclaredMethod("handleIntent", 
                    self._get_class("android.content.Intent").getClass(),
                    self._get_class("java.lang.Boolean").TYPE,
                    self._get_class("java.lang.Boolean").TYPE,
                    self._get_class("java.lang.Boolean").TYPE,
                    self._get_class("org.telegram.messenger.browser.Browser$Progress").getClass(),
                    self._get_class("java.lang.Boolean").TYPE,
                    self._get_class("java.lang.Boolean").TYPE)
                method.setAccessible(True)
                
                self.unhook_deeplink = self.hook_method(method, DeepLinkHook(self))
                pass
                
        except Exception as e:
            pass


    def _hook_dialogs_activity(self):
        try:
            cls = self._get_class("org.telegram.ui.DialogsActivity")
            method = cls.getClass().getDeclaredMethod("onResume")
            ref = self.hook_method(method, DialogsActivityHook(self))
            self.hook_dialogs_ref = ref
            
            try:
                destroy_method = cls.getClass().getDeclaredMethod("onDestroy")
                destroy_ref = self.hook_method(destroy_method, DialogsActivityDestroyHook(self))
                self.hook_dialogs_destroy_ref = destroy_ref
            except Exception:
                pass
                
        except Exception as e:
            pass

    def _hook_dialog_cell(self):
        try:
            cls = self._get_class("org.telegram.ui.Cells.DialogCell")
            boolean_class = self._get_class("java.lang.Boolean").TYPE
            method = cls.getClass().getDeclaredMethod("setOpenBotButton", boolean_class)
            if method is not None:
                ref = self.hook_method(method, DialogCellHook(self))
                self.hook_dialog_cell_ref = ref
            pass
        except Exception as e:
            pass

    def _hook_photo_cell(self):
        try:
            if self.get_setting("hide_hd_icon", False):
                hook_instance = SendImageWithHighQualityByDefault(self)
                hook_instance.onHook()
        except Exception as e:
            pass





    def _hook_swipe_prevention(self):
        try:
            cls = self._get_class("org.telegram.ui.ChatActivity")
            if cls:
                method = cls.getClass().getDeclaredMethod("isSwipeBackEnabled", 
                    self._get_class("android.view.MotionEvent").getClass())
                method.setAccessible(True)
                ref = self.hook_method(method, SwipePreventionHook(self))
                self.hook_swipe_prevention_ref = ref
            pass
        except Exception as e:
            pass

    def _setup_fab_settings_listener(self, dialogs_activity):
        try:
            large_btn = get_private_field(dialogs_activity, "floatingButtonContainer")
            if large_btn is None:
                return
            
            if hasattr(large_btn, '_uitweaks_listener_set'):
                return
            
            def handle_fab_long_press(*args):
                try:
                    try:
                        root = dialogs_activity.getParentActivity().getWindow().getDecorView()
                        flags = HapticFeedbackConstants.FLAG_IGNORE_VIEW_SETTING | HapticFeedbackConstants.FLAG_IGNORE_GLOBAL_SETTING
                        root.performHapticFeedback(HapticFeedbackConstants.KEYBOARD_TAP, flags)
                    except:
                        pass
                    
                    action = self.get_setting("fab_action_selector", 0)
                    
                    if self.get_setting("hide_archived_chats", False) and not self.get_setting("hide_archived_from_drawer", False):
                        action = 0
                    
                    if action == 0:
                        java_plugin = PluginsController.getInstance().plugins.get(__id__)
                        if java_plugin:
                            dialogs_activity.presentFragment(PluginSettingsActivity(java_plugin))
                    elif action == 1:
                        self._open_archived_chats_from_fab(dialogs_activity)
                except Exception as e:
                    pass
            
            large_btn.setOnLongClickListener(OnLongClickListener(handle_fab_long_press))
            large_btn._uitweaks_listener_set = True
        except Exception as e:
            pass

    def _hook_article_viewer(self):
        try:
            from android.view import MotionEvent
            cls = find_class("org.telegram.ui.ArticleViewer$WindowView")
            method = cls.getClass().getDeclaredMethod("handleTouchEvent", MotionEvent)
            method.setAccessible(True)
            ref = self.hook_method(method, ArticleViewerFixHook(self))
            self.hook_article_viewer_ref = ref
            pass
        except Exception as e:
            pass

    def _hook_webapp_swipe_prevention(self):
        try:
            swipe_cls = self._get_class("org.telegram.ui.bots.ChatAttachAlertBotWebViewLayout$WebViewSwipeContainer")
            context_class = jclass("android.content.Context")
            method = swipe_cls.getClass().getDeclaredConstructor(context_class)
            ref = self.hook_method(method, WebAppSwipePreventionHook(self))
            self.hook_webapp_swipe_prevention_ref = ref
        except Exception as e:
            pass

    def _hook_download_manager(self):
        try:
            from java import jclass
            cls = jclass("org.telegram.messenger.DownloadController")
            method = cls.getClass().getDeclaredMethod("hasUnviewedDownloads")
            ref = self.hook_method(method, DownloadManagerHook(self))
            self.hook_download_manager_ref = ref
            pass
        except Exception as e:
            pass

    def _hook_birthday_alert(self):
        try:
            DialogsActivityClass = self._get_class("org.telegram.ui.DialogsActivity")
            if not DialogsActivityClass:
                return
            
            updateDialogsHintMethod = DialogsActivityClass.getClass().getDeclaredMethod("updateDialogsHint")
            updateDialogsHintMethod.setAccessible(True)
            
            ref = self.hook_method(updateDialogsHintMethod, BirthdayAlertHook(self))
            self.hook_birthday_alert_ref = ref
        except Exception as e:
            pass

    def _hook_proxy_button(self):
        try:
            from java import jclass
            cls = jclass("org.telegram.ui.DialogsActivity")
            method = cls.getClass().getDeclaredMethod("updateProxyButton", jclass("java.lang.Boolean").TYPE, jclass("java.lang.Boolean").TYPE)
            ref = self.hook_method(method, ProxyButtonHook(self))
            self.hook_proxy_button_ref = ref
            pass
        except Exception as e:
            pass

    def _hook_star_reaction_menu(self):
        try:
            reaction_menu_class = self._get_class("org.telegram.ui.Components.ReactionsContainerLayout")
            method = reaction_menu_class.getClass().getDeclaredMethod("setMessage", 
                self._get_class("org.telegram.messenger.MessageObject").getClass(),
                self._get_class("org.telegram.tgnet.TLRPC$ChatFull").getClass(),
                self._get_class("java.lang.Boolean").TYPE)
            method.setAccessible(True)
            ref = self.hook_method(method, StarReactionMenuHook(self))
            self.hook_star_reaction_menu_ref = ref
            
            method2 = reaction_menu_class.getClass().getDeclaredMethod("setVisibleReactionsList", 
                self._get_class("java.util.List").getClass(),
                self._get_class("java.lang.Boolean").TYPE)
            method2.setAccessible(True)
            ref2 = self.hook_method(method2, StarReactionVisibleListHook(self))
            self.hook_star_reaction_visible_list_ref = ref2
            
            method3 = reaction_menu_class.getClass().getDeclaredMethod("dispatchDraw", 
                self._get_class("android.graphics.Canvas").getClass())
            method3.setAccessible(True)
            ref3 = self.hook_method(method3, StarReactionGradientHook(self))
            self.hook_star_reaction_gradient_ref = ref3
            pass
            
        except Exception as e:
            pass

    def _hook_star_reaction_layout(self):
        try:
            reactions_layout_class = self._get_class("org.telegram.ui.Components.Reactions.ReactionsLayoutInBubble")
            set_message_method = reactions_layout_class.getClass().getDeclaredMethod("setMessage", 
                self._get_class("org.telegram.messenger.MessageObject").getClass(),
                self._get_class("java.lang.Boolean").TYPE,
                self._get_class("java.lang.Boolean").TYPE,
                self._get_class("org.telegram.ui.ActionBar.Theme$ResourcesProvider").getClass())
            set_message_method.setAccessible(True)
            ref = self.hook_method(set_message_method, StarReactionLayoutDrawHook(self))
            self.hook_star_reaction_layout_draw_ref = ref
        except Exception as e:
            pass

    def _remove_star_reaction_hooks(self):
        for ref_attr in ("hook_star_reaction_menu_ref", "hook_star_reaction_visible_list_ref", "hook_star_reaction_gradient_ref", "hook_star_reaction_layout_draw_ref"):
            ref = getattr(self, ref_attr, None)
            if ref:
                self.unhook_method(ref)
                setattr(self, ref_attr, None)


    def _hide_elements_on_start(self):
        try:
            fragment = get_last_fragment()
            
            if fragment is not None and fragment.getClass().getSimpleName() == "DialogsActivity":
                action_bar_field = fragment.getClass().getSuperclass().getDeclaredField("actionBar")
                action_bar_field.setAccessible(True)
                action_bar = action_bar_field.get(fragment)
                
                if action_bar is not None:
                    pass
        except Exception as e:
            pass


    def _hide_bot_open_buttons_on_resume(self, dialogs_activity):
        try:
            pass
        except Exception as e:
            pass






    def _setup_open_link_internally_hook(self):
        try:
            chat_activity_class = self._get_class("org.telegram.ui.ChatActivity")
            chat_message_cell_class = self._get_class("org.telegram.ui.Cells.ChatMessageCell")
            character_style_class = self._get_class("android.text.style.CharacterStyle")
            
            string_class = self._get_class("java.lang.String")
            int_class = self._get_class("java.lang.Integer").TYPE
            
            try:
                method = chat_activity_class.getClass().getDeclaredMethod(
                    "openLinkInternally",
                    string_class.getClass(),
                    chat_message_cell_class.getClass(),
                    character_style_class.getClass(),
                    int_class,
                    int_class
                )
                method.setAccessible(True)
                self.hook_open_link_internally_ref = self.hook_method(method, OpenLinkInternallyHook(self))
                pass
            except Exception as e:
                pass
                
        except Exception as e:
            pass

    def _setup_browser_open_url_hook(self):
        try:
            browser_class = self._get_class("org.telegram.messenger.browser.Browser")
            context_class = self._get_class("android.content.Context")
            uri_class = self._get_class("android.net.Uri")
            progress_class = self._get_class("org.telegram.messenger.browser.Browser$Progress")
            method = browser_class.getClass().getDeclaredMethod(
                "openUrl",
                context_class.getClass(),
                uri_class.getClass(),
                bool,
                bool,
                bool,
                progress_class.getClass(),
                str,
                bool,
                bool,
                bool
            )
            method.setAccessible(True)
            self.hook_browser_open_url_ref = self.hook_method(method, BrowserOpenUrlHook(self))
            pass
        except Exception as e:
            pass


    def _setup_open_profile_hooks(self):

        pass

    def _hook_phone_number(self):
        try:
            PhoneFormat = jclass("org.telegram.PhoneFormat.PhoneFormat")
            method = PhoneFormat.getClass().getDeclaredMethod("format", jclass("java.lang.String"))
            method.setAccessible(True)
            self.hook_phone_number_ref = self.hook_method(method, PhoneFormatHook(self))
        except:
            pass

    def _hook_messages_controller(self):
        try:
            from java import jclass
            
            method = jclass("org.telegram.messenger.MessagesController").getClass().getDeclaredMethod("getDialogs", jclass("java.lang.Integer").TYPE)
            method.setAccessible(True)
            ref = self.hook_method(method, MessagesControllerGetDialogsHook(self))
            
            self.hook_messages_controller_ref = ref
            pass

                
        except Exception as e:
            pass

    def _hook_chat_utils_has_archived(self):
        try:
            from java import jclass
            
            chat_utils_class = jclass("com.exteragram.messenger.utils.ChatUtils")
            method = chat_utils_class.getClass().getDeclaredMethod("hasArchivedChats")
            method.setAccessible(True)
            ref = self.hook_method(method, ChatUtilsHasArchivedHook(self))
            
            self.hook_chat_utils_has_archived_ref = ref
        except Exception as e:
            pass

    def _hook_extera_config_archived(self):
        try:
            from java import jclass
            
            extera_config_class = jclass("com.exteragram.messenger.ExteraConfig")
            method = extera_config_class.getClass().getDeclaredMethod("setObj", jclass("java.lang.String"), jclass("java.lang.Boolean").TYPE)
            method.setAccessible(True)
            ref = self.hook_method(method, ExteraConfigArchivedHook(self))
            
            self.hook_extera_config_archived_ref = ref
        except Exception as e:
            pass

    def _hook_send_typing_method(self):
        try:
            from java import jclass
            from java.lang import Long, Integer, String as JString
            
            method = jclass("org.telegram.messenger.MessagesController").getClass().getDeclaredMethod(
                "sendTyping", 
                Long.TYPE, Long.TYPE, Integer.TYPE, JString, Integer.TYPE
            )
            method.setAccessible(True)
            ref = self.hook_method(method, MessagesControllerSendTypingHook(self))
            
            if not hasattr(self, 'hook_send_typing_refs'):
                self.hook_send_typing_refs = []
            self.hook_send_typing_refs.append(ref)
        except Exception:
            pass

    def _hook_update_bot_button(self):
        try:
            ChatActivityEnterView = find_class("org.telegram.ui.Components.ChatActivityEnterView")
            boolean_class = find_class("java.lang.Boolean").TYPE
            method = ChatActivityEnterView.getClass().getDeclaredMethod("updateBotButton", boolean_class)
            method.setAccessible(True)
            self.hook_update_bot_button_ref = self.hook_method(method, UpdateBotButtonHook(self))
            pass
        except Exception as e:
            pass



    def _hook_voice_message_control(self):
        try:
            MediaControllerClass = jclass("org.telegram.messenger.MediaController")
            java_class = MediaControllerClass.getClass()
            
            method = java_class.getDeclaredMethod(
                "cleanupPlayer", 
                jclass("java.lang.Boolean").TYPE,
                jclass("java.lang.Boolean").TYPE,
                jclass("java.lang.Boolean").TYPE,
                jclass("java.lang.Boolean").TYPE
            )
            method.setAccessible(True)
            self.hook_voice_message_control_ref = self.hook_method(method, VoiceMessageControlHook(self))
            pass
            
        except Exception as e:
            pass

    def _hook_video_message_control(self):
        try:
            MediaControllerClass = jclass("org.telegram.messenger.MediaController")
            java_class = MediaControllerClass.getClass()
            
            method = java_class.getDeclaredMethod(
                "cleanupPlayer", 
                jclass("java.lang.Boolean").TYPE,
                jclass("java.lang.Boolean").TYPE,
                jclass("java.lang.Boolean").TYPE,
                jclass("java.lang.Boolean").TYPE
            )
            method.setAccessible(True)
            self.hook_video_message_control_ref = self.hook_method(method, VideoMessageControlHook(self))
            pass
            
        except Exception as e:
            pass

    def _apply_delete_with_duration_hooks(self):
        if hasattr(self, 'delete_with_duration_fillitems_ref') and self.delete_with_duration_fillitems_ref:
            self.unhook_method(self.delete_with_duration_fillitems_ref)
            self.delete_with_duration_fillitems_ref = None
        if hasattr(self, 'delete_with_duration_onclick_ref') and self.delete_with_duration_onclick_ref:
            self.unhook_method(self.delete_with_duration_onclick_ref)
            self.delete_with_duration_onclick_ref = None
        
        if self.get_setting("enable_delete_with_duration", False):
            self._hook_delete_with_duration()

    def _hook_delete_with_duration(self):
        try:
            DeleteMessagesBottomSheet = self._get_class("org.telegram.ui.Components.DeleteMessagesBottomSheet")
            ArrayList = self._get_class("java.util.ArrayList")
            UniversalAdapter = self._get_class("org.telegram.ui.Components.UniversalAdapter")
            UItem = self._get_class("org.telegram.ui.Components.UItem")
            View = self._get_class("android.view.View")
            Integer = self._get_class("java.lang.Integer")
            Float = self._get_class("java.lang.Float")
            
            if not DeleteMessagesBottomSheet:
                self.log("Failed to find DeleteMessagesBottomSheet class")
                return
            
            fillItems_method = DeleteMessagesBottomSheet.getClass().getDeclaredMethod("fillItems", ArrayList.getClass(), UniversalAdapter.getClass())
            fillItems_method.setAccessible(True)
            
            onClick_method = DeleteMessagesBottomSheet.getClass().getDeclaredMethod("onClick", UItem.getClass(), View.getClass(), Integer.TYPE, Float.TYPE, Float.TYPE)
            onClick_method.setAccessible(True)
            
            self.delete_with_duration_fillitems_ref = self.hook_method(fillItems_method, DeleteWithDurationFillItemsHook(self))
            self.delete_with_duration_onclick_ref = self.hook_method(onClick_method, DeleteWithDurationOnClickHook(self))
            
        except Exception as e:
            self.log(f"Failed to hook delete with duration: {e}")
            import traceback
            traceback.print_exc()

    def _hook_voice_message_time_display(self):
        try:
            ChatMessageCellClass = jclass("org.telegram.ui.Cells.ChatMessageCell")
            updatePlayingMessageProgressMethod = ChatMessageCellClass.getClass().getDeclaredMethod("updatePlayingMessageProgress")
            updatePlayingMessageProgressMethod.setAccessible(True)
            
            self.hook_voice_message_time_display_ref = self.hook_method(updatePlayingMessageProgressMethod, VoiceMessageTimeDisplayHook(self))
        except Exception as e:
            pass

    def _hook_unread_badge(self):
        try:
            ChatActivityClass = self._get_class("org.telegram.ui.ChatActivity")
            if not ChatActivityClass:
                return
            
            ContextClass = self._get_class("android.content.Context")
            create_view_method = ChatActivityClass.getClass().getDeclaredMethod(
                "createView", 
                ContextClass
            )
            create_view_method.setAccessible(True)
            self.create_view_hook_ref = self.hook_method(
                create_view_method,
                CreateViewHook(self)
            )
            
            destroy_method = ChatActivityClass.getClass().getDeclaredMethod("onFragmentDestroy")
            destroy_method.setAccessible(True)
            self.destroy_hook_ref = self.hook_method(
                destroy_method,
                FragmentDestroyHook(self)
            )
            
        except Exception as e:
            pass

    def _hook_gif_spoiler(self):
        try:
            SHOW_SHEET_RUNNABLE = self._get_class("org.telegram.ui.ContentPreviewViewer$1")
            method = SHOW_SHEET_RUNNABLE.getClass().getDeclaredMethod("run")
            method.setAccessible(True)
            self.hook_gif_spoiler_ref = self.hook_method(method, GifSpoilerHook(self))
            
            ContentPreviewViewer = find_class("org.telegram.ui.ContentPreviewViewer")
            dismiss_method = ContentPreviewViewer.getClass().getDeclaredMethod("dismissPopupWindow")
            dismiss_method.setAccessible(True)
            self.hook_gif_dismiss_ref = self.hook_method(dismiss_method, GifDismissHook(self))
            self.log("GIF Menu: Hooked both show and dismiss methods")
        except Exception as e:
            self.log(f"GIF Menu: Error hooking GIF methods: {e}")
            pass

    def _hook_process_external_url(self):
        try:
            ChatActivityClass = self._get_class("org.telegram.ui.ChatActivity")
            method = ChatActivityClass.getClass().getDeclaredMethod(
                "processExternalUrl", 
                self._get_class("java.lang.Integer").TYPE,
                self._get_class("java.lang.String").getClass(),
                self._get_class("android.text.style.CharacterStyle").getClass(),
                self._get_class("org.telegram.ui.Cells.ChatMessageCell").getClass(),
                self._get_class("java.lang.Boolean").TYPE,
                self._get_class("java.lang.Boolean").TYPE
            )
            method.setAccessible(True)
            self.hook_process_external_url_ref = self.hook_method(method, ProcessExternalUrlHook(self))
        except Exception as e:
            pass


    def _hook_forward_confirmation(self):
        try:
            if getattr(self, 'hook_forward_confirmation_ref', None):
                return
            chat_cls = self._get_class("org.telegram.ui.ChatActivity")
            method = chat_cls.getClass().getDeclaredMethod(
                "forwardMessages",
                self._get_class("java.util.ArrayList").getClass(),
                self._get_class("java.lang.Boolean").TYPE,
                self._get_class("java.lang.Boolean").TYPE,
                self._get_class("java.lang.Boolean").TYPE,
                self._get_class("java.lang.Integer").TYPE,
                self._get_class("java.lang.Long").TYPE
            )
            method.setAccessible(True)
            self.hook_forward_confirmation_ref = self.hook_method(method, ForwardConfirmationHook(self, method))
            pass
        except Exception as e:
            pass

    def _hook_join_confirmation(self):
        try:
            if getattr(self, 'hook_join_confirmation_ref', None):
                return
            chat_activity_class = self._get_class("org.telegram.ui.ChatActivity")
            context_class = self._get_class("android.content.Context")
            
            if not chat_activity_class or not context_class:
                return

            create_view_method = chat_activity_class.getClass().getDeclaredMethod("createView", context_class)
            self.hook_join_confirmation_ref = self.hook_method(create_view_method, JoinConfirmationHook(self))
            
        except Exception as e:
            pass

    def _hook_code_formatting(self):
        try:
            ChatActivity = self._get_class("org.telegram.ui.ChatActivity")
            EditTextCaption = self._get_class("org.telegram.ui.Components.EditTextCaption")
            
            if ChatActivity is None or EditTextCaption is None:
                return
            
            boolean_type = self._get_class("java.lang.Boolean").TYPE
            fillActionModeMenu_method = None
            
            try:
                fillActionModeMenu_method = ChatActivity.getClass().getDeclaredMethod("fillActionModeMenu", 
                    self._get_class("android.view.Menu"), 
                    jclass("org.telegram.tgnet.TLRPC$EncryptedChat"), 
                    boolean_type,
                    boolean_type)
            except Exception:
                try:
                    fillActionModeMenu_method = ChatActivity.getClass().getDeclaredMethod("fillActionModeMenu", 
                        self._get_class("android.view.Menu"), 
                        jclass("org.telegram.tgnet.TLRPC$EncryptedChat"), 
                        boolean_type)
                except Exception:
                    pass

            if fillActionModeMenu_method:
                fillActionModeMenu_method.setAccessible(True)
                self.hook_fill_action_mode_menu_ref = self.hook_method(fillActionModeMenu_method, FillActionModeMenuHook(self))
            
            performMenuAction_method = EditTextCaption.getClass().getDeclaredMethod("performMenuAction", 
                self._get_class("java.lang.Integer").TYPE)
            performMenuAction_method.setAccessible(True)
            
            self.hook_perform_menu_action_ref = self.hook_method(performMenuAction_method, PerformMenuActionHook(self))
            
        except Exception as e:
            traceback.print_exc()

    def _make_selected_code(self, edit_text):
        try:
            start = edit_text.getSelectionStart()
            end = edit_text.getSelectionEnd()
            
            if start < 0 or end < 0 or start == end:
                return
            
            context = edit_text.getContext()
            
            language_edit_text = EditTextBoldCursor(context)
            language_edit_text.setHint(get_string("Language", "Language"))
            language_edit_text.setInputType(InputType.TYPE_CLASS_TEXT)
            language_edit_text.setMaxLines(1)
            language_edit_text.setSingleLine(True)
            language_edit_text.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 18)
            language_edit_text.setTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteBlackText))
            language_edit_text.setHintTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteHintText))
            language_edit_text.setBackground(Theme.createEditTextDrawable(context, True))
            language_edit_text.setCursorColor(Theme.getColor(Theme.key_windowBackgroundWhiteBlueHeader))
            language_edit_text.setCursorSize(AndroidUtilities.dp(20))
            language_edit_text.setCursorWidth(1.5)
            language_edit_text.setPadding(0, 0, 0, 0)
            language_edit_text.setFocusable(True)
            
            try:
                text = edit_text.getText()
                if text:
                    code_spans = text.getSpans(start, end, CodeHighlighting.Span)
                    if code_spans:
                        for span in code_spans:
                            if span.lng:
                                language_edit_text.setText(span.lng)
                                break
            except:
                pass
            
            def on_ok_click(dialog, which):
                try:
                    AndroidUtilities.hideKeyboard(language_edit_text)
                    language = language_edit_text.getText().toString()
                    self._apply_code_formatting(edit_text, start, end, language)
                except Exception:
                    pass
                dialog.dismiss()
            
            def on_cancel_click(dialog, which):
                try:
                    AndroidUtilities.hideKeyboard(language_edit_text)
                except Exception:
                    pass
                dialog.dismiss()
            
            builder = AlertDialogBuilder(context)
            builder.set_title(get_string("create_code_dialog_title", "Create Code"))
            builder.set_view(language_edit_text)
            builder.set_negative_button(get_string("cancel", "Cancel"), on_cancel_click)
            builder.set_positive_button(get_string("ok", "OK"), on_ok_click)
            
            dialog = builder.show()
            
            def apply_layout_params():
                try:
                    layout_params = language_edit_text.getLayoutParams()
                    if layout_params is not None:
                        if isinstance(layout_params, FrameLayout.LayoutParams):
                            layout_params.gravity = Gravity.CENTER_HORIZONTAL
                        
                        if hasattr(layout_params, 'rightMargin'):
                            layout_params.rightMargin = AndroidUtilities.dp(24)
                            layout_params.leftMargin = AndroidUtilities.dp(24)
                            layout_params.height = AndroidUtilities.dp(36)
                            layout_params.bottomMargin = AndroidUtilities.dp(15)
                        language_edit_text.setLayoutParams(layout_params)
                    
                    language_edit_text.requestFocus()
                    text_length = language_edit_text.getText().length() if language_edit_text.getText() else 0
                    language_edit_text.setSelection(0, text_length)
                    AndroidUtilities.showKeyboard(language_edit_text)
                except Exception:
                    pass
            
            run_on_ui_thread(apply_layout_params, delay=100)
            
        except Exception as e:
            traceback.print_exc()
    
    def _apply_code_formatting(self, edit_text, start, end, language):
        try:
            editable = edit_text.getText()
            if editable is None:
                return
            
            try:
                code_spans = editable.getSpans(start, end, CodeHighlighting.Span)
                if code_spans:
                    for span in code_spans:
                        editable.removeSpan(span)
            except:
                pass
            
            code_span = CodeHighlighting.Span(True, 0, None, language, editable.subSequence(start, end).toString())
            editable.setSpan(code_span, start, end, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE)
            
            try:
                delegate = get_private_field(edit_text, "delegate")
                if delegate and hasattr(delegate, 'onSpansChanged'):
                    delegate.onSpansChanged()
            except:
                pass
            
        except Exception as e:
            traceback.print_exc()
    
    def _make_selected_mention(self, edit_text):
        try:
            start = edit_text.getSelectionStart()
            end = edit_text.getSelectionEnd()
            
            if start < 0 or end < 0 or start == end:
                return
            
            context = edit_text.getContext()
            
            mention_edit_text = EditTextBoldCursor(context)
            mention_edit_text.setHint(get_string("id_hint", "ID"))
            mention_edit_text.setInputType(InputType.TYPE_CLASS_TEXT)
            mention_edit_text.setMaxLines(1)
            mention_edit_text.setSingleLine(True)
            mention_edit_text.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 18)
            mention_edit_text.setTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteBlackText))
            mention_edit_text.setHintTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteHintText))
            mention_edit_text.setBackground(Theme.createEditTextDrawable(context, True))
            mention_edit_text.setCursorColor(Theme.getColor(Theme.key_windowBackgroundWhiteBlueHeader))
            mention_edit_text.setCursorSize(AndroidUtilities.dp(20))
            mention_edit_text.setCursorWidth(1.5)
            mention_edit_text.setPadding(0, 0, 0, 0)
            mention_edit_text.setFocusable(True)
            
            try:
                text = edit_text.getText()
                if text:
                    mention_spans = text.getSpans(start, end, URLSpanUserMention)
                    if mention_spans:
                        for span in mention_spans:
                            if span.getURL():
                                mention_edit_text.setText(span.getURL())
                                break
            except:
                pass
            
            def on_ok_click(dialog, which):
                try:
                    AndroidUtilities.hideKeyboard(mention_edit_text)
                    mention_id = mention_edit_text.getText().toString()
                    self._apply_mention_formatting(edit_text, start, end, mention_id)
                except Exception:
                    pass
                dialog.dismiss()
            
            def on_cancel_click(dialog, which):
                try:
                    AndroidUtilities.hideKeyboard(mention_edit_text)
                except Exception:
                    pass
                dialog.dismiss()
            
            builder = AlertDialogBuilder(context)
            builder.set_title(get_string("create_mention_dialog_title", "Create Mention"))
            builder.set_view(mention_edit_text)
            builder.set_negative_button(get_string("cancel", "Cancel"), on_cancel_click)
            builder.set_positive_button(get_string("ok", "OK"), on_ok_click)
            
            dialog = builder.show()
            
            def apply_layout_params():
                try:
                    layout_params = mention_edit_text.getLayoutParams()
                    if layout_params is not None:
                        if isinstance(layout_params, FrameLayout.LayoutParams):
                            layout_params.gravity = Gravity.CENTER_HORIZONTAL
                        
                        if hasattr(layout_params, 'rightMargin'):
                            layout_params.rightMargin = AndroidUtilities.dp(24)
                            layout_params.leftMargin = AndroidUtilities.dp(24)
                            layout_params.height = AndroidUtilities.dp(36)
                            layout_params.bottomMargin = AndroidUtilities.dp(15)
                        mention_edit_text.setLayoutParams(layout_params)
                    
                    mention_edit_text.requestFocus()
                    text_length = mention_edit_text.getText().length() if mention_edit_text.getText() else 0
                    mention_edit_text.setSelection(0, text_length)
                    AndroidUtilities.showKeyboard(mention_edit_text)
                except Exception:
                    pass
            
            run_on_ui_thread(apply_layout_params, delay=100)
            
        except Exception as e:
            traceback.print_exc()
    
    def _apply_mention_formatting(self, edit_text, start, end, mention_id):
        try:
            editable = edit_text.getText()
            if editable is None:
                return
            
            try:
                character_spans = editable.getSpans(start, end, CharacterStyle)
                if character_spans:
                    for span in character_spans:
                        span_start = editable.getSpanStart(span)
                        span_end = editable.getSpanEnd(span)
                        editable.removeSpan(span)
                        if span_start < start:
                            editable.setSpan(span, span_start, start, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE)
                        if span_end > end:
                            editable.setSpan(span, end, span_end, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE)
            except:
                pass
            
            try:
                mention_span = URLSpanUserMention(mention_id, 3)
                editable.setSpan(mention_span, start, end, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE)
            except:
                pass
            
            try:
                delegate = get_private_field(edit_text, "delegate")
                if delegate and hasattr(delegate, 'onSpansChanged'):
                    delegate.onSpansChanged()
            except:
                pass
            
        except Exception as e:
            traceback.print_exc()



    def _hook_message_preview_view(self):
        try:
            if getattr(self, 'hook_message_preview_view_ref', None):
                return
                
            cls = self._get_class("org.telegram.ui.Components.MessagePreviewView")
            context_class = jclass("android.content.Context")
            chat_activity_class = self._get_class("org.telegram.ui.ChatActivity")
            params_class = self._get_class("org.telegram.messenger.MessagePreviewParams")
            user_class = self._get_class("org.telegram.tgnet.TLRPC$User")
            chat_class = self._get_class("org.telegram.tgnet.TLRPC$Chat")
            int_class = jclass("java.lang.Integer").TYPE
            boolean_class = jclass("java.lang.Boolean").TYPE
            resources_class = self._get_class("org.telegram.ui.Components.MessagePreviewView$ResourcesDelegate")
            
            method = cls.getClass().getDeclaredConstructor(
                context_class, chat_activity_class, params_class, user_class, 
                chat_class, int_class, resources_class, int_class, boolean_class
            )
            self.hook_message_preview_view_ref = self.hook_method(method, MessagePreviewViewHook(self))
        except:
            pass

    def _add_send_media_button(self, preview_view):
        try:
            message_preview_params = get_private_field(preview_view, "messagePreviewParams")
            if not message_preview_params or not message_preview_params.webpage:
                return

            webpage = message_preview_params.webpage
            if not (webpage.photo or webpage.document):
                return

            context = preview_view.getContext()
            resources_provider = get_private_field(preview_view, "resourcesProvider")
            
            ActionBarMenuSubItem = jclass("org.telegram.ui.ActionBar.ActionBarMenuSubItem")
            send_button = ActionBarMenuSubItem(context, False, False, resources_provider)
            
            R = jclass("org.telegram.messenger.R")
            
            if webpage.document:
                if hasattr(message_preview_params, 'isVideo') and message_preview_params.isVideo:
                    text = get_string("send_video", "Send Video")
                else:
                    text = get_string("send_file", "Send File")
            else:
                text = get_string("send_photo", "Send Photo")
            
            send_button.setTextAndIcon(text, R.drawable.msg_send)
            send_button.setVisibility(1 if (webpage.document or webpage.photo) else 8)
            
            def send_media(view=None):
                run_on_ui_thread(lambda: self._send_media(preview_view, webpage))
            
            send_button.setOnClickListener(OnClickListener(send_media))
            
            menu = self._find_send_media_menu(preview_view)
            if menu and hasattr(menu, 'addView'):
                LayoutHelper = jclass("org.telegram.ui.Components.LayoutHelper")
                menu.addView(send_button, LayoutHelper.createLinear(-1, 48))
                self.added_send_media_buttons.add(preview_view)
        except:
            pass

    def _find_send_media_menu(self, view):
        try:
            if hasattr(view, 'getChildCount'):
                for i in range(view.getChildCount()):
                    child = view.getChildAt(i)
                    if child:
                        if "ActionBarPopupWindowLayout" in child.getClass().getSimpleName() and hasattr(child, 'addView'):
                            return child
                        menu = self._find_send_media_menu(child)
                        if menu:
                            return menu
            return None
        except:
            return None

    def _create_send_message_params_document(self, document, dialog_id, user_reply_to_msg, topic_reply_to_msg, caption, parent, has_spoiler):
        try:
            return SendMessagesHelper.SendMessageParams.of(
                document, None, None, dialog_id, 
                user_reply_to_msg, 
                topic_reply_to_msg, 
                caption,
                None, None, None, True, 0, 0, 
                0,
                parent, 
                None, 
                False, 
                has_spoiler
            )
        except:
            return SendMessagesHelper.SendMessageParams.of(
                document, None, None, dialog_id, 
                user_reply_to_msg, 
                topic_reply_to_msg, 
                caption,
                None, None, None, True, 0, 0, 
                parent, 
                None, 
                False, 
                has_spoiler
            )

    def _create_send_message_params_photo(self, photo, dialog_id, user_reply_to_msg, topic_reply_to_msg, caption, parent, has_spoiler):
        try:
            return SendMessagesHelper.SendMessageParams.of(
                photo, None, dialog_id, 
                user_reply_to_msg, 
                topic_reply_to_msg, 
                caption,
                None, None, None, True, 0, 0, 
                0,
                parent, 
                False, 
                has_spoiler
            )
        except:
            return SendMessagesHelper.SendMessageParams.of(
                photo, None, dialog_id, 
                user_reply_to_msg, 
                topic_reply_to_msg, 
                caption,
                None, None, None, True, 0, 0, 
                parent, 
                False, 
                has_spoiler
            )

    def _send_media(self, preview_view, webpage):
        try:
            from client_utils import get_last_fragment
            current_fragment = get_last_fragment()
            if not current_fragment:
                return

            dialog_id_field = current_fragment.getClass().getDeclaredField("dialog_id")
            dialog_id_field.setAccessible(True)
            dialog_id = dialog_id_field.getLong(current_fragment)
            if not dialog_id:
                return

            message_preview_params = get_private_field(preview_view, "messagePreviewParams")
            is_video = False
            if message_preview_params and hasattr(message_preview_params, 'isVideo'):
                is_video = message_preview_params.isVideo

            if is_video and webpage.document:
                params = self._create_send_message_params_document(
                    webpage.document, dialog_id, None, None, None, webpage, False
                )
            elif webpage.photo:
                params = self._create_send_message_params_photo(
                    webpage.photo, dialog_id, None, None, None, webpage, False
                )
            elif webpage.document:
                params = self._create_send_message_params_document(
                    webpage.document, dialog_id, None, None, None, webpage, False
                )
            else:
                return

            send_helper = get_send_messages_helper()
            if send_helper:
                send_helper.sendMessage(params)
                try:
                    if hasattr(preview_view, 'dismiss'):
                        preview_view.dismiss(True)
                except:
                    pass

        except:
            pass

    def show_goto_message_dialog(self, chat_activity):
        try:
            if not chat_activity:
                return
                
            fragment = self._resolve_target_fragment(chat_activity)
            if not fragment:
                return
                
            activity = fragment.getParentActivity()
            if not activity:
                return
            
            current_activity = chat_activity
            
            message_id_edit_text = EditTextBoldCursor(activity)
            message_id_edit_text.setHint(get_string("id_hint", "ID"))
            message_id_edit_text.setInputType(InputType.TYPE_CLASS_NUMBER)
            message_id_edit_text.setMaxLines(1)
            message_id_edit_text.setSingleLine(True)
            message_id_edit_text.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 18)
            message_id_edit_text.setTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteBlackText))
            message_id_edit_text.setHintTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteHintText))
            message_id_edit_text.setBackground(Theme.createEditTextDrawable(activity, True))
            message_id_edit_text.setCursorColor(Theme.getColor(Theme.key_windowBackgroundWhiteBlueHeader))
            message_id_edit_text.setCursorSize(AndroidUtilities.dp(20))
            message_id_edit_text.setCursorWidth(1.5)
            message_id_edit_text.setPadding(0, 0, 0, 0)
            message_id_edit_text.setFocusable(True)
            
            def close_dialog_and_menu(dialog, message_id=None):
                try:
                    AndroidUtilities.hideKeyboard(message_id_edit_text)
                except Exception:
                    pass
                dialog.dismiss()
                try:
                    if current_activity:
                        header_item = self.header_item_field.get(current_activity) if self.header_item_field else None
                        if header_item:
                            header_item.closeSubMenu()
                except Exception:
                    pass
                if message_id:
                    target_fragment = self._resolve_target_fragment(current_activity) if current_activity else fragment
                    if target_fragment:
                        run_on_ui_thread(lambda: self.scroll_to_message(target_fragment, message_id))
            
            def on_search_click(dialog, which):
                try:
                    AndroidUtilities.hideKeyboard(message_id_edit_text)
                    
                    editable = message_id_edit_text.getText()
                    if editable is not None:
                        message_id_text = editable.toString().strip()
                        numeric_only = ''.join(c for c in message_id_text if c.isdigit())
                        if numeric_only:
                            message_id = self._validate_message_id(numeric_only)
                            if message_id:
                                close_dialog_and_menu(dialog, message_id)
                                return
                except Exception as e:
                    uitweaks_log(f"Error in on_search_click: {e}")
                close_dialog_and_menu(dialog)
            
            def on_cancel_click(dialog, which):
                try:
                    AndroidUtilities.hideKeyboard(message_id_edit_text)
                except Exception:
                    pass
                close_dialog_and_menu(dialog)
            
            builder = AlertDialogBuilder(activity)
            builder.set_title(get_string("search_messages", "Search Messages"))
            builder.set_view(message_id_edit_text)
            builder.set_negative_button(get_string("cancel", "Cancel"), on_cancel_click)
            builder.set_positive_button(get_string("search", "Search"), on_search_click)
            
            dialog = builder.show()
            
            def apply_layout_params():
                try:
                    layout_params = message_id_edit_text.getLayoutParams()
                    if layout_params is not None:
                        if isinstance(layout_params, FrameLayout.LayoutParams):
                            layout_params.gravity = Gravity.CENTER_HORIZONTAL
                        
                        if hasattr(layout_params, 'rightMargin'):
                            layout_params.rightMargin = AndroidUtilities.dp(24)
                            layout_params.leftMargin = AndroidUtilities.dp(24)
                            layout_params.height = AndroidUtilities.dp(36)
                            layout_params.bottomMargin = AndroidUtilities.dp(15)
                        message_id_edit_text.setLayoutParams(layout_params)
                    
                    message_id_edit_text.requestFocus()
                    text_length = message_id_edit_text.getText().length() if message_id_edit_text.getText() else 0
                    message_id_edit_text.setSelection(0, text_length)
                    AndroidUtilities.showKeyboard(message_id_edit_text)
                except Exception as e:
                    uitweaks_log(f"Error applying layout params: {e}")
            
            run_on_ui_thread(apply_layout_params, delay=100)
            
        except Exception as e:
            uitweaks_log(f"Error in show_goto_message_dialog: {e}")
    
    def scroll_to_message(self, chat_activity, message_id):
        try:
            if not message_id or message_id <= 0 or not chat_activity:
                return
            chat_activity.scrollToMessageId(message_id, 0, False, 0, False, 0)
        except Exception as e:
            uitweaks_log(f"Error in scroll_to_message: {e}")
    
    def _resolve_target_fragment(self, chat_activity):
        if not chat_activity:
            return get_last_fragment()
        if hasattr(chat_activity, 'fragment') and chat_activity.fragment:
            return chat_activity.fragment
        elif hasattr(chat_activity, 'getParentActivity'):
            return chat_activity
        return get_last_fragment()
    
    def _validate_message_id(self, message_id_text):
        if not message_id_text or not message_id_text.strip():
            return None
        try:
            message_id = int(message_id_text.strip())
            return message_id if message_id > 0 else None
        except ValueError:
            return None

    def _update_goto_message_menu_item(self):
        try:
            self._goto_items_added.clear()
            self._add_goto_message_plugin_subitem()
        except Exception as e:
            uitweaks_log(f"Error in _update_goto_message_menu_item: {e}")
    
    def cleanup_activity_references(self, activity_id):
        try:
            sets_to_check = [
                '_goto_items_added',
                'hooked_activities',
                'added_send_media_buttons',
                '_no_quote_buttons_created',
                '_select_all_added_modes',
                'ai_summarize_hooked_activities',
                'chat_action_bar_hooked_activities',
            ]
            for set_name in sets_to_check:
                if hasattr(self, set_name):
                    s = getattr(self, set_name)
                    if s and activity_id in s:
                        s.discard(activity_id)
            
            dicts_to_check = [
                '_no_quote_button_cache',
                'search_filter_buttons',
                'contact_status_activity_state',
            ]
            for dict_name in dicts_to_check:
                if hasattr(self, dict_name):
                    d = getattr(self, dict_name)
                    if d and activity_id in d:
                        del d[activity_id]
        except Exception as e:
            self.log(f"Error in cleanup_activity_references: {e}")

    
    def _create_summarizer_role(self):
        try:
            from com.exteragram.messenger.ai import AiController
            from com.exteragram.messenger.ai.data import Role
            
            controller = AiController.getInstance()
            
            role_name = "Quanta!"
            existing_role = None
            
            roles_list = controller.getRoles()
            if roles_list:
                for i in range(roles_list.size()):
                    role = roles_list.get(i)
                    if role and role.getName() == role_name:
                        existing_role = role
                        break
            
            if existing_role is None:
                default_prompt = """You are an expert at summarizing chat conversations. Analyze the messages and create a concise summary using paragraphs with bold headings for different topics. Do not use bullet points. Keep it clear and organized, highlighting key points, decisions, and action items. Mention important participants when relevant. Keep the summary within 3-5 paragraphs."""
                
                new_role = Role(role_name, default_prompt)
                controller.addRole(new_role)
        except:
            pass
    
    def _hook_ai_summarize(self):
        self._create_summarizer_role()
        self._hook_chat_action_bar_items()
    
    def _hook_goto_message(self):
        self._hook_chat_action_bar_items()
    
    def _hook_chat_action_bar_items(self):
        if hasattr(self, 'hook_ai_summarize_create_view_ref') and self.hook_ai_summarize_create_view_ref:
            self.chat_action_bar_hooked_activities.clear()
            return
        
        try:
            ChatActivity = find_class("org.telegram.ui.ChatActivity")
            if not ChatActivity:
                return
            
            createViewMethod = ChatActivity.getClass().getDeclaredMethod("createView", jclass("android.content.Context"))
            createViewMethod.setAccessible(True)
            self.hook_ai_summarize_create_view_ref = self.hook_method(createViewMethod, ChatActionBarItemsHook(self))
        except Exception as e:
            self.log(f"Error hooking Chat Action Bar Items: {e}")

    def _hook_disable_auto_web_login(self):
        try:
            BrowserClass = self._get_class("org.telegram.messenger.browser.Browser")
            if not BrowserClass:
                return

            java_browser_class = BrowserClass.getClass()
            
            try:
                method = java_browser_class.getDeclaredMethod("openUrl",
                    self._get_class("android.content.Context").getClass(),
                    self._get_class("android.net.Uri").getClass(),
                    self._get_class("java.lang.Boolean").TYPE,
                    self._get_class("java.lang.Boolean").TYPE,
                    self._get_class("java.lang.Boolean").TYPE,
                    self._get_class("org.telegram.messenger.browser.Browser$Progress").getClass(),
                    self._get_class("java.lang.String").getClass(),
                    self._get_class("java.lang.Boolean").TYPE,
                    self._get_class("java.lang.Boolean").TYPE,
                    self._get_class("java.lang.Boolean").TYPE)
                method.setAccessible(True)
                self.hook_disable_auto_web_login_ref = self.hook_method(method, DisableAutoWebLoginHook(self))
            except Exception as e:
                pass
                
        except Exception as e:
            pass

    def _hook_do_not_share_phone_number(self):
        try:
            self.do_not_share_hook = DoNotSharePhoneNumberHook(self)
            self.do_not_share_hook.setup()
        except Exception:
            self.do_not_share_hook = None

    def _hook_prefer_common_groups_tab(self):
        try:
            SharedMediaLayoutClass = self._get_class("org.telegram.ui.Components.SharedMediaLayout")
            if not SharedMediaLayoutClass:
                return

            java_class = SharedMediaLayoutClass.getClass()
            
            try:
                method = java_class.getDeclaredMethod("setUserInfo", 
                    self._get_class("org.telegram.tgnet.TLRPC$UserFull").getClass())
                method.setAccessible(True)
                self.hook_prefer_common_groups_tab_ref = self.hook_method(method, PreferCommonGroupsTabHook(self))
            except Exception as e:
                pass
                
        except Exception as e:
            pass

    def _hook_sender_select_popup(self):
        try:
            SenderSelectPopupClass = self._get_class("org.telegram.ui.Components.SenderSelectPopup")
            if not SenderSelectPopupClass:
                return

            constructor = SenderSelectPopupClass.getClass().getDeclaredConstructor(
                jclass("android.content.Context"),
                jclass("org.telegram.ui.ChatActivity"),
                jclass("org.telegram.messenger.MessagesController"),
                jclass("org.telegram.tgnet.TLRPC$ChatFull"),
                jclass("org.telegram.tgnet.TLRPC$TL_channels_sendAsPeers"),
                jclass("org.telegram.ui.Components.SenderSelectPopup$OnSelectCallback")
            )
            constructor.setAccessible(True)
            self.hook_method(constructor, SendAsPopupHook(self))

            MessagesControllerClass = self._get_class("org.telegram.messenger.MessagesController")
            method = MessagesControllerClass.getClass().getDeclaredMethod("setDefaultSendAs", jclass("java.lang.Long").TYPE, jclass("java.lang.Long").TYPE)
            method.setAccessible(True)
            self.hook_method(method, SetDefaultSendAsHook(self))

        except Exception:
            pass

    def _hook_swipe_disable(self):
        try:
            SwipeGestureSettingsViewClass = self._get_class("org.telegram.ui.Components.SwipeGestureSettingsView")
            if not SwipeGestureSettingsViewClass:
                return

            try:
                SharedConfigClass = self._get_class("org.telegram.messenger.SharedConfig")
                if SharedConfigClass:
                    getSwipeMethod = SharedConfigClass.getClass().getDeclaredMethod(
                        "getChatSwipeAction",
                        jclass("java.lang.Integer").TYPE
                    )
                    getSwipeMethod.setAccessible(True)

                    class GetSwipeActionHook:
                        def __init__(self, plugin_instance):
                            self.plugin = plugin_instance

                        def after_hooked_method(self, param):
                            try:
                                currentAccount = param.args[0] if param.args else 0
                                result = param.getResult()
                                if result == 5:
                                    MessagesController = jclass("org.telegram.messenger.MessagesController")
                                    if MessagesController.getInstance(currentAccount).dialogFilters.isEmpty():
                                        param.setResult(6)
                            except Exception:
                                pass

                    self.hook_swipe_disable_ref = self.hook_method(getSwipeMethod, GetSwipeActionHook(self))
            except Exception:
                pass
            
            constructor = SwipeGestureSettingsViewClass.getClass().getDeclaredConstructor(
                jclass("android.content.Context"),
                jclass("java.lang.Integer").TYPE
            )
            constructor.setAccessible(True)
            
            class SwipeGestureSettingsViewHook:
                def __init__(self, plugin_instance):
                    self.plugin = plugin_instance
                
                def after_hooked_method(self, param):
                    instance = param.thisObject
                    if instance is None:
                        return
                    
                    try:
                        strings = get_private_field(instance, "strings")
                        backgroundKeys = get_private_field(instance, "backgroundKeys")
                        icons = get_private_field(instance, "icons")

                        Array = jclass("java.lang.reflect.Array")
                        System = jclass("java.lang.System")

                        stringsComponentType = strings.getClass().getComponentType() if strings else None
                        bgComponentType = backgroundKeys.getClass().getComponentType() if backgroundKeys else None
                        iconsComponentType = icons.getClass().getComponentType() if icons else None

                        if strings and Array.getLength(strings) == 6 and stringsComponentType:
                            new_strings = Array.newInstance(stringsComponentType, 7)
                            System.arraycopy(strings, 0, new_strings, 0, 6)
                            try:
                                Array.set(new_strings, 6, get_string("disable", "Disable"))
                            except Exception:
                                pass
                            set_private_field(instance, "strings", new_strings)
                            strings = new_strings

                        if backgroundKeys and Array.getLength(backgroundKeys) == 6 and bgComponentType:
                            new_background_keys = Array.newInstance(bgComponentType, 7)
                            System.arraycopy(backgroundKeys, 0, new_background_keys, 0, 6)
                            try:
                                first_key = Array.get(backgroundKeys, 5)
                                Array.set(new_background_keys, 6, first_key)
                            except Exception:
                                pass
                            set_private_field(instance, "backgroundKeys", new_background_keys)
                            backgroundKeys = new_background_keys

                        if icons and Array.getLength(icons) == 6 and iconsComponentType:
                            new_icons = Array.newInstance(iconsComponentType, 7)
                            System.arraycopy(icons, 0, new_icons, 0, 6)
                            set_private_field(instance, "icons", new_icons)
                            icons = new_icons

                        picker = get_private_field(instance, "picker")
                        if picker:
                            hasTabs = get_private_field(instance, "hasTabs")
                            try:
                                picker.setWrapSelectorWheel(True)
                                if hasTabs:
                                    picker.setMaxValue(6)
                                    picker.setAllItemsCount(7)
                                else:
                                    if strings and Array.getLength(strings) >= 6:
                                        Array.set(strings, 5, get_string("disable", "Disable"))
                                    picker.setMaxValue(5)
                                    picker.setAllItemsCount(6)
                                SharedConfig = jclass("org.telegram.messenger.SharedConfig")
                                acc = param.args[1] if param.args and len(param.args) >= 2 else get_private_field(instance, "currentAccount") or 0
                                val = SharedConfig.getChatSwipeAction(acc or 0)
                                picker.setValue(5 if not hasTabs and val == 6 else val)
                            except Exception:
                                pass
                    except Exception:
                        pass
            
            hook_handler = SwipeGestureSettingsViewHook(self)
            self.hook_swipe_disable_ref = self.hook_method(constructor, hook_handler)

            try:
                SwipeControllerClass = find_class("org.telegram.ui.DialogsActivity$SwipeController")
                getMovementFlagsMethod = SwipeControllerClass.getClass().getDeclaredMethod(
                    "getMovementFlags",
                    jclass("androidx.recyclerview.widget.RecyclerView"),
                    jclass("androidx.recyclerview.widget.RecyclerView$ViewHolder")
                )
                getMovementFlagsMethod.setAccessible(True)

                class GetMovementFlagsHook:
                    def __init__(self, plugin_instance):
                        self.plugin = plugin_instance

                    def after_hooked_method(self, param):
                        try:
                            dialogsActivity = get_private_field(param.thisObject, "this$0")
                            if not dialogsActivity:
                                return
                            
                            currentAccount = get_private_field(dialogsActivity, "currentAccount") if dialogsActivity else 0
                            SharedConfig = jclass("org.telegram.messenger.SharedConfig")
                            
                            if SharedConfig.getChatSwipeAction(currentAccount) == 6:
                                actionBar = get_private_field(dialogsActivity, "actionBar")
                                if actionBar and actionBar.isActionModeShowed(None):
                                    return
                                
                                param.setResult(jclass("java.lang.Integer")(0))
                        except Exception:
                            pass

                self.hook_swipe_disable_ref = self.hook_method(getMovementFlagsMethod, GetMovementFlagsHook(self))
            except Exception:
                pass
        except Exception:
            pass

    def _hook_share_sheet_folders(self):
        try:
            share_alert_class = self._get_class("org.telegram.ui.Components.ShareAlert")
            if not share_alert_class:
                return
            
            bottom_sheet_class = self._get_class("org.telegram.ui.ActionBar.BottomSheet")
            if not bottom_sheet_class:
                return
                
            show_method = bottom_sheet_class.getClass().getDeclaredMethod("show")
            show_method.setAccessible(True)
            
            class ShareAlertShowHook:
                def __init__(self, plugin):
                    self.plugin = plugin
                    self.processed_instances = set()
                
                def after_hooked_method(self, param):
                    try:
                        bottom_sheet_instance = param.thisObject
                        
                        if share_alert_class.getClass().isInstance(bottom_sheet_instance):
                            instance_id = id(bottom_sheet_instance)
                            if instance_id in self.processed_instances:
                                return
                            self.processed_instances.add(instance_id)
                            
                            self.plugin._add_folder_tabs_to_share_alert(bottom_sheet_instance)
                    except:
                        pass
            
            hook = self.hook_method(show_method, ShareAlertShowHook(self))
            if hook:
                self.hook_share_sheet_folders_ref = hook
        except:
            pass

    def _add_folder_tabs_to_share_alert(self, share_alert):
        try:
            search_field = get_private_field(share_alert, "searchView")
            if not search_field or hasattr(search_field, '_folders_added'):
                return
            
            current_account = get_private_field(share_alert, "currentAccount")
            if current_account is None:
                return
            
            folders = MessagesController.getInstance(current_account).getDialogFilters()
            folder_count = folders.size() if folders else 0
            
            has_archived = self._has_archived_chats(current_account)
            total_tabs = folder_count + (1 if has_archived else 0)
            
            if total_tabs <= 1:
                return
            
            context = search_field.getContext()
            
            filter_tabs_view = LinearLayout(context)
            filter_tabs_view.setOrientation(LinearLayout.HORIZONTAL)
            filter_tabs_view.setBackgroundColor(Theme.getColor(Theme.key_dialogBackground))
            filter_tabs_view.setPadding(AndroidUtilities.dp(8), AndroidUtilities.dp(8), AndroidUtilities.dp(8), AndroidUtilities.dp(8))
            
            scroll_view = HorizontalScrollView(context)
            scroll_view.setHorizontalScrollBarEnabled(False)
            scroll_view.setLayoutParams(ViewGroup.LayoutParams(
                ViewGroup.LayoutParams.MATCH_PARENT,
                AndroidUtilities.dp(40)
            ))
            
            tabs_container = LinearLayout(context)
            tabs_container.setOrientation(LinearLayout.HORIZONTAL)
            tabs_container.setLayoutParams(ViewGroup.LayoutParams(
                ViewGroup.LayoutParams.WRAP_CONTENT,
                AndroidUtilities.dp(40)
            ))

            scroll_view.addView(tabs_container)
            filter_tabs_view.addView(scroll_view)
            
            set_private_field(filter_tabs_view, '_tabs_container', tabs_container)
            
            tab_containers = []
            for i in range(total_tabs):
                if i < folder_count:
                    folder = folders.get(i)
                    tab_text = get_string("all_chats", "All Chats") if folder.isDefault() else (folder.name if hasattr(folder, 'name') else f"Folder {i}")
                    folder_obj = folder
                    is_archived = False
                else:
                    tab_text = get_string("archived", "Archived")
                    folder_obj = None
                    is_archived = True

                tab_container = LinearLayout(context)
                tab_container.setOrientation(LinearLayout.HORIZONTAL)
                tab_container.setGravity(Gravity.CENTER)
                tab_container.setPadding(AndroidUtilities.dp(12), AndroidUtilities.dp(8), AndroidUtilities.dp(12), AndroidUtilities.dp(8))
                tab_container.setLayoutParams(LinearLayout.LayoutParams(
                    LinearLayout.LayoutParams.WRAP_CONTENT,
                    AndroidUtilities.dp(32)
                ))

                tab_bg = GradientDrawable()
                tab_bg.setShape(GradientDrawable.RECTANGLE)
                tab_bg.setCornerRadius(AndroidUtilities.dp(16))
                
                tab_bg.setColor(Theme.getColor(Theme.key_dialogSearchBackground))
                tab_container.setBackground(tab_bg)

                tab_view = TextView(context)
                tab_view.setText(tab_text)
                tab_view.setTextColor(Theme.getColor(Theme.key_actionBarTabActiveText if i == 0 else Theme.key_actionBarTabUnactiveText))
                tab_view.setTextSize(14)
                tab_view.setTypeface(AndroidUtilities.getTypeface("fonts/rmedium.ttf"))
                tab_view.setPadding(AndroidUtilities.dp(4), 0, AndroidUtilities.dp(4), 0)

                def click_handler(*args, folder_index=i, folder=folder_obj, archived=is_archived):
                    self._on_folder_tab_clicked(share_alert, folder_index, folder, tabs_container, archived)
                
                click_listener = OnClickListener(click_handler)
                tab_container.setOnClickListener(click_listener)

                tab_container.addView(tab_view)
                tabs_container.addView(tab_container)
                tab_containers.append(tab_container)
                if i < total_tabs - 1:
                    margin_view = View(context)
                    margin_view.setLayoutParams(LinearLayout.LayoutParams(
                        AndroidUtilities.dp(4),
                        AndroidUtilities.dp(1)
                    ))
                    tabs_container.addView(margin_view)

            
            set_private_field(filter_tabs_view, '_tab_containers', tab_containers)
            
            frame_layout = get_private_field(share_alert, "frameLayout")
            search_view = get_private_field(share_alert, "searchView")
            shadows = get_private_field(share_alert, "shadow")
            
            if not frame_layout or not search_view:
                return

            from android.widget import FrameLayout
            
            frame_layout_params = frame_layout.getLayoutParams()
            if frame_layout_params:
                frame_layout_params.height = AndroidUtilities.dp(106)
                frame_layout.setLayoutParams(frame_layout_params)
            
            search_params = search_view.getLayoutParams()
            if isinstance(search_params, FrameLayout.LayoutParams):
                search_params.height = ViewGroup.LayoutParams.MATCH_PARENT
                search_params.gravity = Gravity.TOP | Gravity.LEFT
                search_view.setLayoutParams(search_params)
            
            search_view.addView(
                filter_tabs_view,
                FrameLayout.LayoutParams(
                    ViewGroup.LayoutParams.MATCH_PARENT, 
                    AndroidUtilities.dp(48),
                    Gravity.BOTTOM
                )
            )
            
            if shadows and len(shadows) > 0 and shadows[0]:
                shadow_params = shadows[0].getLayoutParams()
                if isinstance(shadow_params, FrameLayout.LayoutParams):
                    shadow_params.topMargin = AndroidUtilities.dp(106)
                    shadows[0].setLayoutParams(shadow_params)

            grid_view = get_private_field(share_alert, "gridView")
            if grid_view:
                 grid_params = grid_view.getLayoutParams()
                 if isinstance(grid_params, FrameLayout.LayoutParams):
                     grid_params.topMargin = AndroidUtilities.dp(50)
                     grid_view.setLayoutParams(grid_params)

            search_grid_view = get_private_field(share_alert, "searchGridView")
            if search_grid_view:
                 search_grid_params = search_grid_view.getLayoutParams()
                 if isinstance(search_grid_params, FrameLayout.LayoutParams):
                     search_grid_params.topMargin = AndroidUtilities.dp(50)
                     search_grid_view.setLayoutParams(search_grid_params)

            frame_layout.requestLayout()
            search_view.requestLayout()
            if grid_view:
                grid_view.requestLayout()

            set_private_field(search_view, '_folders_added', True)
            
        except:
            pass
    
    def _get_folders_padding(self):
        return AndroidUtilities.dp(96)
    
    def _update_tab_styles(self, tabs_container, selected_index):
        try:
            tab_containers = []
            child_count = tabs_container.getChildCount()
            for i in range(child_count):
                child = tabs_container.getChildAt(i)
                if isinstance(child, LinearLayout):
                    tab_containers.append(child)
            
            
            for i, tab_container in enumerate(tab_containers):
                text_view = tab_container.getChildAt(0)
                
                tab_bg = GradientDrawable()
                tab_bg.setShape(GradientDrawable.RECTANGLE)
                tab_bg.setCornerRadius(AndroidUtilities.dp(16))
                
                tab_bg.setColor(Theme.getColor(Theme.key_dialogSearchBackground))
                
                text_view.setTextColor(Theme.getColor(Theme.key_actionBarTabActiveText if i == selected_index else Theme.key_actionBarTabUnactiveText))
                
                tab_container.setBackground(tab_bg)
                
        except:
            pass
    
    def _on_folder_tab_clicked(self, share_alert, folder_index, folder, tabs_container, is_archived=False):
        try:
            current_account = get_private_field(share_alert, "currentAccount")
            list_adapter = get_private_field(share_alert, "listAdapter")
            if current_account is None or not list_adapter:
                return

            self._update_tab_styles(tabs_container, folder_index)

            if is_archived:
                self._apply_archived_filter(share_alert, list_adapter, current_account)
            else:
                self._apply_folder_filter(share_alert, list_adapter, folder, current_account)

        except:
            pass
    
    def _apply_folder_filter(self, share_alert, list_adapter, folder, current_account):
        try:
            all_dialogs = MessagesController.getInstance(current_account).getAllDialogs()
            
            dialogs_list = get_private_field(list_adapter, "dialogs")
            dialogs_map = get_private_field(list_adapter, "dialogsMap")
            if not dialogs_list or not dialogs_map:
                return
            
            dialogs_list.clear()
            dialogs_map.clear()
            
            dialog_count = all_dialogs.size()
            for i in range(dialog_count):
                dialog = all_dialogs.get(i)
                if folder.isDefault() or self._dialog_matches_folder(dialog, folder, current_account):
                    if self._can_forward_to_chat(dialog, current_account):
                        dialogs_list.add(dialog)
                        dialogs_map.put(dialog.id, dialog)
            
            list_adapter.notifyDataSetChanged()
            
            self._apply_forced_scroll_offset(share_alert)
                    
        except:
            pass
    
    def _dialog_matches_folder(self, dialog, folder, current_account):
        try:
            if folder.isDefault():
                return True
            
            from org.telegram.messenger import AccountInstance
            return folder.includesDialog(AccountInstance.getInstance(current_account), dialog.id)
            
        except:
            return False
    
    def _has_archived_chats(self, current_account):
        try:
            all_dialogs = MessagesController.getInstance(current_account).getAllDialogs()
            for i in range(all_dialogs.size()):
                if all_dialogs.get(i).folder_id == 1:
                    return True
            return False
        except:
            return False
    
    def _apply_archived_filter(self, share_alert, list_adapter, current_account):
        try:
            all_dialogs = MessagesController.getInstance(current_account).getAllDialogs()
            dialogs_list = get_private_field(list_adapter, "dialogs")
            dialogs_map = get_private_field(list_adapter, "dialogsMap")
            if not dialogs_list or not dialogs_map:
                return
            
            dialogs_list.clear()
            dialogs_map.clear()
            
            for i in range(all_dialogs.size()):
                dialog = all_dialogs.get(i)
                if dialog.folder_id == 1:
                    if self._can_forward_to_chat(dialog, current_account):
                        dialogs_list.add(dialog)
                        dialogs_map.put(dialog.id, dialog)
            
            list_adapter.notifyDataSetChanged()
            
            self._apply_forced_scroll_offset(share_alert)
        except:
            pass
    
    def _can_forward_to_chat(self, dialog, current_account):
        try:
            if not dialog:
                return False
            
            from org.telegram.messenger import DialogObject
            if DialogObject.isEncryptedDialog(dialog.id):
                return True
            
            if DialogObject.isChannel(dialog):
                chat = MessagesController.getInstance(current_account).getChat(-dialog.id)
                if not chat:
                    return False
                
                from org.telegram.messenger import ChatObject
                
                if chat.megagroup:
                    return not chat.gigagroup or ChatObject.hasAdminRights(chat)
                else:
                    return ChatObject.hasAdminRights(chat) and ChatObject.canPost(chat)
            
            return True
        except:
            return False
    
    def _apply_forced_scroll_offset(self, share_alert):
        try:
            grid_view = get_private_field(share_alert, "gridView")
            if not grid_view:
                return
                
            layout_manager = grid_view.getLayoutManager()
            if not layout_manager:
                return
                
            layout_manager.scrollToPositionWithOffset(0, -self.forced_scroll_offset)
        except Exception as e:
            pass

    def _hook_non_clickable_preview(self):
        try:
            BaseFragmentClass = jclass("org.telegram.ui.ActionBar.BaseFragment")
            methods = BaseFragmentClass.getClass().getDeclaredMethods()
            present_method = None
            for m in methods:
                if m.getName() == "presentFragmentAsPreviewWithMenu":
                    present_method = m
                    break
            if present_method is None:
                raise Exception("presentFragmentAsPreviewWithMenu not found on BaseFragment")
            present_method.setAccessible(True)
            self.hook_non_clickable_present_ref = self.hook_method(present_method, NonClickablePreviewPresentFragmentHook())
        except:
            pass

        try:
            ActionBarLayout = jclass("org.telegram.ui.ActionBar.ActionBarLayout")
            methods2 = ActionBarLayout.getClass().getDeclaredMethods()
            present_method2 = None
            for m in methods2:
                if m.getName() == "presentFragmentAsPreviewWithMenu":
                    present_method2 = m
                    break
            if present_method2 is None:
                raise Exception("presentFragmentAsPreviewWithMenu not found on ActionBarLayout")
            present_method2.setAccessible(True)
            self.hook_non_clickable_present_ref2 = self.hook_method(present_method2, NonClickablePreviewPresentFragmentHook())
        except:
            pass

        try:
            ChatActivityClass = jclass("org.telegram.ui.ChatActivity")
            inner_classes = ChatActivityClass.getClass().getDeclaredClasses()
            fragment_view_class = None
            for c in inner_classes:
                if "ChatActivityFragmentView" in c.getSimpleName():
                    fragment_view_class = c
                    break
            if fragment_view_class is None:
                raise Exception("ChatActivityFragmentView not found")
            
            dispatch_method = fragment_view_class.getDeclaredMethod("dispatchTouchEvent", jclass("android.view.MotionEvent"))
            dispatch_method.setAccessible(True)
            self.hook_non_clickable_dispatch_ref = self.hook_method(dispatch_method, NonClickablePreviewDispatchTouchHook())
        except:
            pass

    def _hook_disable_topic_swipe(self):
        try:
            TouchHelperCallbackClass = self._get_class("org.telegram.ui.TopicsFragment$TouchHelperCallback")
            if not TouchHelperCallbackClass:
                return
            
            getMovementFlagsMethod = TouchHelperCallbackClass.getClass().getDeclaredMethod(
                "getMovementFlags",
                jclass("androidx.recyclerview.widget.RecyclerView"),
                jclass("androidx.recyclerview.widget.RecyclerView$ViewHolder")
            )
            getMovementFlagsMethod.setAccessible(True)
            
            class DisableTopicSwipeHook:
                def __init__(self, plugin_instance):
                    self.plugin = plugin_instance
                
                def before_hooked_method(self, param):
                    param.setResult(jclass("java.lang.Integer")(0))
                    param.returnEarly = True
            
            self.hook_disable_topic_swipe_ref = self.hook_method(getMovementFlagsMethod, DisableTopicSwipeHook(self))
            
        except Exception:
            pass

    def _hook_account_visibility(self):
        try:
            self.hidden_accounts = self.load_hidden_accounts()
            
            if drawer_adapter_class := self._get_class("org.telegram.ui.Adapters.DrawerLayoutAdapter"):
                self.hook_drawer_adapter(drawer_adapter_class)
            if profile_cell_class := self._get_class("org.telegram.ui.Cells.DrawerProfileCell"):
                self.hook_profile_cell(profile_cell_class)
        except Exception:
            pass

    def load_hidden_accounts(self):
        try:
            settings = self.get_setting("hidden_accounts", "[]")
            import json
            return json.loads(settings)
        except:
            return []

    def save_hidden_accounts(self):
        import json
        self.set_setting("hidden_accounts", json.dumps(self.hidden_accounts))

    def hook_drawer_adapter(self, drawer_adapter_class):
        try:
            method = drawer_adapter_class.getClass().getDeclaredMethod("notifyDataSetChanged")
            method.setAccessible(True)

            class DrawerAdapterHook:
                def __init__(self, plugin):
                    self.plugin = plugin

                def after_hooked_method(self, param):
                    try:
                        adapter = param.thisObject
                        hidden_accounts = self.plugin.hidden_accounts
                        if not hidden_accounts:
                            return
                        
                        account_numbers = get_private_field(adapter, "accountNumbers")
                        if not account_numbers:
                            return
                        
                        from org.telegram.messenger import UserConfig
                        current_account = UserConfig.selectedAccount
                        iterator = account_numbers.iterator()
                        while iterator.hasNext():
                            account_num = iterator.next()
                            if str(account_num) in hidden_accounts and account_num != current_account:
                                iterator.remove()

                    except:
                        pass

            self.hook_account_visibility_drawer_ref = self.hook_method(method, DrawerAdapterHook(self))
        except:
            pass

    def hook_profile_cell(self, profile_cell_class):
        try:
            constructors = profile_cell_class.getClass().getDeclaredConstructors()
            method = constructors[0]
            method.setAccessible(True)

            class ProfileCellHook:
                def __init__(self, plugin):
                    self.plugin = plugin

                def after_hooked_method(self, param):
                    try:
                        profile_cell = param.thisObject
                        self.plugin.replace_theme_button_listener(profile_cell)
                    except:
                        pass

            self.hook_account_visibility_profile_ref = self.hook_method(method, ProfileCellHook(self))
        except:
            pass

    def replace_theme_button_listener(self, profile_cell):
        try:
            if dark_theme_view := get_private_field(profile_cell, "darkThemeView"):
                def account_visibility_handler(*args):
                    try:
                        self._perform_haptic()
                        self.toggle_all_other_accounts()
                    except:
                        pass
                
                from android_utils import OnLongClickListener
                dark_theme_view.setOnLongClickListener(OnLongClickListener(account_visibility_handler))
        except:
            pass

    def toggle_all_other_accounts(self):
        try:
            accounts = self.get_account_info()
            if len(accounts) <= 1:
                return

            other_accounts = [acc for acc in accounts if not acc['is_current']]
            any_hidden = any(acc['hidden'] for acc in other_accounts)
            
            for account in other_accounts:
                self.toggle_account_visibility(account['number'], not any_hidden)
            
        except:
            pass

    def toggle_account_visibility(self, account_number, hidden):
        account_str = str(account_number)
        if hidden:
            if account_str not in self.hidden_accounts:
                self.hidden_accounts.append(account_str)
        else:
            if account_str in self.hidden_accounts:
                self.hidden_accounts.remove(account_str)
        self.save_hidden_accounts()
        self.refresh_drawer()

    def refresh_drawer(self):
        try:
            from android_utils import run_on_ui_thread
            run_on_ui_thread(self._refresh_drawer_impl, delay=100)
        except:
            pass
    
    def _refresh_drawer_impl(self):
        try:
            from org.telegram.ui import LaunchActivity
            if (hasattr(LaunchActivity, 'instance') and LaunchActivity.instance and 
                (drawer_adapter := get_private_field(LaunchActivity.instance, "drawerLayoutAdapter")) and
                hasattr(drawer_adapter, 'notifyDataSetChanged')):
                drawer_adapter.notifyDataSetChanged()
                return
        except:
            pass
    
    def get_account_info(self):
        accounts = []
        try:
            from org.telegram.messenger import UserConfig
            current_account = UserConfig.selectedAccount
            
            for account_id in range(UserConfig.MAX_ACCOUNT_COUNT):
                try:
                    if (config := UserConfig.getInstance(account_id)).isClientActivated():
                        if user := config.getCurrentUser():
                            first_name = getattr(user, 'first_name', 'Unknown')
                            last_name = getattr(user, 'last_name', '')
                            name = f"{first_name} {last_name}".strip() or f"Account {account_id}"
                            
                            is_current = (account_id == current_account)
                            if is_current:
                                name += " (Current)"
                            
                            accounts.append({
                                'number': account_id,
                                'name': name,
                                'user_id': user.id,
                                'hidden': str(account_id) in self.hidden_accounts,
                                'is_current': is_current
                            })
                except:
                    continue
        except:
            pass
        
        return accounts
    


class SetDefaultSendAsHook:
    def __init__(self, plugin):
        self.plugin = plugin

    def after_hooked_method(self, param):
        try:
            dialog_id, peer_id = param.args[0], param.args[1]
            current_account = UserConfig.selectedAccount
            chat = MessagesController.getInstance(current_account).getChat(-dialog_id)
            
            if not chat or not ChatObject.isMegagroup(chat) or not chat.creator:
                return

            current_user = UserConfig.getInstance(current_account).getCurrentUser()
            if not current_user or not chat.admin_rights:
                return

            self_id = current_user.id
            admin_rights = chat.admin_rights
            admin_rights.anonymous = peer_id != self_id
            rank = MessagesController.getInstance(current_account).getAdminRank(chat.id, self_id)
            MessagesController.getInstance(current_account).setUserAdminRole(
                chat.id, current_user, admin_rights, rank, False, None, False, False, None, None
            )

        except Exception:
            pass


class SendAsPopupHook:
    def __init__(self, plugin):
        self.plugin = plugin

    def after_hooked_method(self, param):
        try:
            send_as_peers, chat_full = param.args[4], param.args[3]
            if not send_as_peers or not chat_full:
                return

            chat_id = chat_full.id
            current_account = UserConfig.selectedAccount
            chat = MessagesController.getInstance(current_account).getChat(chat_id)
            
            if not chat or not ChatObject.isMegagroup(chat) or not chat.creator:
                return

            current_user = UserConfig.getInstance(current_account).getCurrentUser()
            if not current_user:
                return

            self_id = current_user.id
            peers = send_as_peers.peers
            
            for i in range(peers.size()):
                peer = peers.get(i)
                if hasattr(peer, 'peer') and hasattr(peer.peer, 'user_id') and peer.peer.user_id == self_id:
                    return

            personal_peer = TLRPC.TL_sendAsPeer()
            personal_peer.peer = TLRPC.TL_peerUser()
            personal_peer.peer.user_id = self_id
            personal_peer.peer.channel_id = 0
            personal_peer.peer.chat_id = 0
            peers.add(0, personal_peer)

        except Exception:
            pass


class BirthdayAlertHook:
    def __init__(self, plugin):
        self.plugin = plugin
    
    def after_hooked_method(self, param):
        instance = param.thisObject
        if instance is None:
            return
        
        try:
            currentAccount = get_private_field(instance, "currentAccount")
            if currentAccount is None:
                return
            
            MessagesController = jclass("org.telegram.messenger.MessagesController")
            messagesController = MessagesController.getInstance(currentAccount)
            pendingSuggestions = get_private_field(messagesController, "pendingSuggestions")
            
            if pendingSuggestions and pendingSuggestions.contains("BIRTHDAY_SETUP"):
                dialogsHintCell = get_private_field(instance, "dialogsHintCell")
                if dialogsHintCell:
                    dialogsHintCell.setVisibility(8)
        except Exception:
            pass





class ConfirmationHook:
    def __init__(self, plugin: UiTweaksPlugin):
        self.plugin = plugin
        self.pending_params: List[Any] = [] 
        self.pending_group_id: Optional[str] = None 
        self.is_resending = False
        self.pending_sticker_doc = None

    def _reset_pending(self):
        self.pending_params.clear()
        self.pending_group_id = None
        self.pending_sticker_doc = None

    def before_hooked_method(self, param: Any):
        if self.is_resending:
            return

        try:
            send_params = param.args[0]
            if not send_params:
                return

            params_map = getattr(send_params, 'params', None)
            group_id = None
            is_group_final = False
            if params_map is not None:
                group_id = params_map.get("groupId")
                is_group_final = params_map.get("final") == "1"

            msg_text = getattr(send_params, 'message', None)
            is_command = isinstance(msg_text, str) and msg_text.strip().startswith('/')

            is_photo = getattr(send_params, 'photo', None) is not None
            doc = getattr(send_params, 'document', None)

            is_sticker = False
            is_voice = False
            is_round_video = False
            is_video_file = False
            is_gif = False
            is_generic_document = False

            if doc and hasattr(doc, 'attributes'):
                attributes_list = doc.attributes
                has_animated_attr = False
                has_video_attr = False
                has_sticker_attr = False
                
                mime_type = getattr(doc, 'mime_type', '')
                
                for i in range(attributes_list.size()):
                    attr = attributes_list.get(i)
                    if isinstance(attr, TL_documentAttributeSticker):
                        has_sticker_attr = True
                    elif isinstance(attr, TL_documentAttributeAudio) and attr.voice:
                        is_voice = True
                    elif isinstance(attr, TL_documentAttributeAnimated):
                        has_animated_attr = True
                    elif isinstance(attr, TL_documentAttributeVideo):
                        has_video_attr = True
                        if attr.round_message:
                            is_round_video = True
                        else:
                            is_video_file = True
                
                if has_sticker_attr:
                    is_round_video = False
                    is_video_file = False
                    is_sticker = True
                elif has_animated_attr:
                    is_gif = True
                    is_video_file = False
                elif has_video_attr and not is_round_video:
                    is_video_file = True

                if not (is_sticker or is_voice or is_round_video or is_video_file or is_gif):
                    is_generic_document = True

            should_confirm = False
            message_type = ""

            if not self.plugin.get_setting("enable_confirmation_settings", False):
                should_confirm = False
            elif is_command and self.plugin.get_setting("confirm_commands", False):
                if self.plugin.command_from_message_click:
                    should_confirm = True
                    message_type = get_string("message_type_command", "command")
            elif is_photo and self.plugin.get_setting("confirm_photo", False):
                should_confirm = True
                message_type = get_string("message_type_photo", "photo")
            elif is_sticker and self.plugin.get_setting("confirm_stickers", True):
                should_confirm = True
                message_type = get_string("message_type_sticker", "sticker")
                self.pending_sticker_doc = doc
            elif is_voice and self.plugin.get_setting("confirm_voice", True):
                should_confirm = True
                message_type = get_string("message_type_voice_message", "voice message")
            elif is_round_video and self.plugin.get_setting("confirm_round_video", True):
                should_confirm = True
                message_type = get_string("message_type_round_video_message", "round video message")
            elif is_video_file and self.plugin.get_setting("confirm_video_file", False):
                should_confirm = True
                message_type = get_string("message_type_video_file", "video file")
            elif is_gif and self.plugin.get_setting("confirm_gif", False):
                should_confirm = True
                message_type = get_string("message_type_gif", "GIF")
            elif is_generic_document and self.plugin.get_setting("confirm_document", False):
                should_confirm = True
                message_type = get_string("message_type_file", "file")

            if not should_confirm:
                if is_command:
                    self.plugin.command_from_message_click = False
                return 

            if is_command:
                self.pending_params.append(param)
                param.setResult(None)
                
                run_on_ui_thread(lambda: self.show_confirmation_dialog(msg_text.strip()))
                self.plugin.command_from_message_click = False
                return

            if group_id and group_id != "0":
                if self.pending_group_id is None:
                    self.pending_group_id = group_id
                if group_id != self.pending_group_id:
                    return

                self.pending_params.append(param)
                param.setResult(None)

                if is_group_final:
                    count = len(self.pending_params)
                    if count > 1:
                        if is_photo:
                            message_type = get_string("message_type_photo_plural", "photos")
                        elif is_video_file:
                            message_type = get_string("message_type_video_file_plural", "video files")
                        elif is_round_video:
                            message_type = get_string("message_type_round_video_message", "round video messages")
                        elif is_generic_document:
                            message_type = get_string("message_type_file_plural", "files")
                    
                    run_on_ui_thread(lambda: self.show_confirmation_dialog(f"{count} {message_type}"))
                return
            else:
                self.pending_params.append(param)
                param.setResult(None)
                
                run_on_ui_thread(lambda: self.show_confirmation_dialog(message_type, is_sticker, doc if is_sticker else None))

        except Exception as e:
            pass

    def show_confirmation_dialog(self, message_type: str, is_sticker: bool = False, sticker_doc = None):
        fragment = get_last_fragment()
        activity = fragment.getParentActivity() if fragment else None

        if not activity:
            self.proceed_sending(None, 0)
            return

        dialog_ref = None
        
        def cleanup():
            nonlocal dialog_ref
            dialog_ref = None

        builder = AlertDialogBuilder(activity)
        builder.set_title(get_string("confirm_send_title", "Confirm Send"))
        
        confirmation_text = get_string("confirm_send_message", "Do you really want to send this {message_type}?").format(message_type=message_type)

        if is_sticker and sticker_doc:
            try:
                container = LinearLayout(activity)
                container.setOrientation(LinearLayout.VERTICAL)
                container.setPadding(AndroidUtilities.dp(24), AndroidUtilities.dp(16), AndroidUtilities.dp(24), AndroidUtilities.dp(16))

                sticker_view = BackupImageView(activity)
                sticker_view.setRoundRadius(0)
                sticker_size = AndroidUtilities.dp(120)
                sticker_params = LinearLayout.LayoutParams(sticker_size, sticker_size)
                sticker_params.gravity = Gravity.CENTER_HORIZONTAL
                sticker_params.bottomMargin = AndroidUtilities.dp(16)
                sticker_view.setLayoutParams(sticker_params)

                thumb_drawable = None
                if sticker_doc.thumbs and sticker_doc.thumbs.size() > 0:
                    from org.telegram.messenger import ImageLoader
                    for i in range(sticker_doc.thumbs.size()):
                        t = sticker_doc.thumbs.get(i)
                        if hasattr(t, 'bytes') and t.bytes:
                            thumb_drawable = ImageLoader.getStrippedPhotoBitmap(t.bytes, "b")
                            break

                image_location = ImageLocation.getForDocument(sticker_doc)
                if image_location:
                    sticker_view.setImage(image_location, "120_120", thumb_drawable, sticker_doc)

                container.addView(sticker_view)

                builder.set_view(container)
            except Exception:
                builder.set_message(confirmation_text)
        else:
            builder.set_message(confirmation_text)
        
        builder.set_positive_button(get_string("send", "Send"), self.proceed_sending)
        
        builder.set_negative_button(get_string("cancel", "Cancel"), lambda dialog, which: cleanup())
        builder.set_on_cancel_listener(lambda b: (self.cancel_sending(b, 0), cleanup()))
        dialog_ref = builder.show()

    def proceed_sending(self, builder: Optional[AlertDialogBuilder], which: int):
        if builder:
            builder.dismiss()

        if not self.pending_params:
            return

        try:
            for stored_param in self.pending_params:
                original_method = stored_param.method
                arguments = stored_param.args
                instance = stored_param.thisObject
                self.is_resending = True
                original_method.invoke(instance, *arguments)
            
        except Exception as e:
            pass
        finally:
            self.is_resending = False
            self._reset_pending()

    def cancel_sending(self, builder: Optional[AlertDialogBuilder], which: int):
        if builder:
            builder.dismiss()
        
        self._reset_pending()


class DialogsActivityHook:
    def __init__(self, plugin: UiTweaksPlugin):
        self.plugin = plugin

    def after_hooked_method(self, param):
        try:
            dialogs_activity = param.thisObject
            if dialogs_activity is None:
                return
            
            if self.plugin.get_setting("hide_bot_open", False):
                    try:
                        self.plugin._hide_bot_open_buttons_on_resume(dialogs_activity)
                    except Exception as e:
                        pass
            

            
            if self.plugin.get_setting("fab_settings_shortcut", False):
                try:
                    self.plugin._setup_fab_settings_listener(dialogs_activity)
                except Exception as e:
                    pass
        except Exception as e:
            pass


class DialogsActivityDestroyHook:
    def __init__(self, plugin: UiTweaksPlugin):
        self.plugin = plugin

    def before_hooked_method(self, param):
        try:
            dialogs_activity = param.thisObject
            if dialogs_activity is None:
                return
            
            activity_id = id(dialogs_activity)
            self.plugin.cleanup_activity_references(activity_id)
        except Exception:
            pass


class ChatActivityCleanupHook:
    def __init__(self, plugin):
        self.plugin_ref = weakref.ref(plugin)
    
    def after_hooked_method(self, param):
        try:
            plugin = self.plugin_ref()
            if plugin is None:
                return
            chat_activity = param.thisObject
            if chat_activity is None:
                return
            
            activity_id = id(chat_activity)
            plugin.cleanup_activity_references(activity_id)
        except Exception:
            pass


class DialogCellHook:
    def __init__(self, plugin: UiTweaksPlugin):
        self.plugin_ref = weakref.ref(plugin)

    def after_hooked_method(self, param):
        try:
            plugin = self.plugin_ref()
            if plugin is None:
                return
            if plugin.get_setting("hide_bot_open", True):
                cell = param.thisObject
                if cell is not None:
                    try:
                        open_bot_field = cell.getClass().getDeclaredField("openBot")
                        open_bot_field.setAccessible(True)
                        open_bot_value = open_bot_field.get(cell)
                        
                        if open_bot_value:  
                            open_bot_field.set(cell, False)  
                            
                    except Exception as e:
                        pass
        except Exception as e:
            pass

class SendImageWithHighQualityByDefault:
    def __init__(self, plugin):
        self.plugin = plugin
        self._cached_fields = {}

    def isEnabled(self):
        return True

    def onHook(self):
        try:
            cellClass = find_class("org.telegram.ui.Cells.PhotoAttachPhotoCell")
            
            try:
                setHighQuality_method = cellClass.getClass().getDeclaredMethod("setHighQuality", find_class("java.lang.Boolean").TYPE)
                setHighQuality_method.setAccessible(True)
                self.plugin.hook_method(setHighQuality_method, PhotoCellSetHighQualityHook(self))
            except:
                method_names = ["setQuality", "setHD"]
                for method_name in method_names:
                    try:
                        setHighQuality_method = cellClass.getClass().getDeclaredMethod(method_name, find_class("java.lang.Boolean").TYPE)
                        setHighQuality_method.setAccessible(True)
                        self.plugin.hook_method(setHighQuality_method, PhotoCellSetHighQualityHook(self))
                        break
                    except:
                        continue
        except:
            pass




class PhotoCellSetHighQualityHook:
    def __init__(self, hook_instance):
        self.hook_instance = hook_instance
        self._field_cache = {}

    def _get_cached_field(self, obj, field_name):
        cache_key = f"{id(obj)}_{field_name}"
        if cache_key not in self._field_cache:
            try:
                field = obj.getClass().getDeclaredField(field_name)
                field.setAccessible(True)
                self._field_cache[cache_key] = field
            except:
                self._field_cache[cache_key] = None
        return self._field_cache.get(cache_key)

    def _get_field_value(self, obj, field_name):
        field = self._get_cached_field(obj, field_name)
        if field:
            try:
                return field.get(obj)
            except:
                return None
        return None

    def after_hooked_method(self, param):
        try:
            from android.view import ViewGroup
            from android.view import View
            
            highQuality = param.args[0] if param.args and len(param.args) > 0 else False
            
            if not highQuality:
                return
            
            try:
                photoEntry = self._get_field_value(param.thisObject, "photoEntry")
                if photoEntry:
                    isVideo = self._get_field_value(photoEntry, "isVideo") or False
                    if isVideo:
                        return
                    else:
                        videoInfoContainer = self._get_field_value(param.thisObject, "videoInfoContainer")
                        if videoInfoContainer:
                            videoInfoContainer.setVisibility(View.INVISIBLE)
            except:
                pass
        except:
            pass


class SwipePreventionHook(MethodReplacement):
    def __init__(self, plugin: UiTweaksPlugin):
        self.plugin = plugin

    def replace_hooked_method(self, param):
        try:
            prevent_editing = self.plugin.get_setting("prevent_swipe_while_editing", False)
            prevent_typing = self.plugin.get_setting("prevent_swipe_while_typing", False)
            
            if not prevent_editing and not prevent_typing:
                return True
            
            activity = param.thisObject
            if activity is None:
                return True
            
            swipe_back_enabled = True
            try:
                swipe_back_enabled = get_private_field(activity, "swipeBackEnabled")
                if swipe_back_enabled is None:
                    swipe_back_enabled = True
            except:
                pass
            
            forwarding_preview_view = None
            try:
                forwarding_preview_view = get_private_field(activity, "forwardingPreviewView")
            except:
                pass
            
            if not swipe_back_enabled or (forwarding_preview_view is not None and hasattr(forwarding_preview_view, 'isShowing') and forwarding_preview_view.isShowing()):
                return False
            
            is_editing = False
            is_keyboard_open = False
            
            if prevent_editing:
                try:
                    editing_message = get_private_field(activity, "editingMessageObject")
                    is_editing = editing_message is not None
                except:
                    pass
            
            if prevent_typing:
                try:
                    is_keyboard_open = activity.isKeyboardVisible()
                except:
                    pass
            
            should_prevent = (prevent_editing and is_editing) or (prevent_typing and is_keyboard_open)
            
            if should_prevent:
                return False
            else:
                return True
        except Exception as e:
            return True


class DeepLinkHook:
    def __init__(self, plugin: UiTweaksPlugin):
        self.plugin = plugin
        self.pending_intent = None
        self.pending_param = None
        self.is_processing = False

    def before_hooked_method(self, param):
        try:
            if not self.plugin.get_setting("confirm_deeplinks", False) and not self.plugin.get_setting("confirm_ayugram_deeplinks", False):
                return

            if self.is_processing:
                return

            if len(param.args) < 7:
                return

            intent = param.args[0]
            if not intent:
                return

            for i in range(1, 7):
                if param.args[i] is None:
                    return

            action = intent.getAction()
            if action and "voice" in action.lower():
                return

            data = intent.getData()
            if not data:
                return

            url = str(data)
            if url.startswith("tg://Quanta") or url.startswith("tg://quanta") or url == "tg://refresh":
                return
            elif url.startswith("tg://ayu/"):
                if not self.plugin.get_setting("confirm_ayugram_deeplinks", False):
                    return
                
                excluded_links = ["tg://ayu/prefs", "tg://ayu/db_export", "tg://ayu/db_import"]
                if url in excluded_links:
                    self.pending_intent = intent
                    self.pending_param = param
                    param.setResult(None)  
                    run_on_ui_thread(lambda: self.show_deeplink_confirmation_dialog(url))
                    return
                
                self.pending_intent = intent
                self.pending_param = param
                param.setResult(None)  
                run_on_ui_thread(lambda: self.show_ayugram_warning_dialog(url))
                return
            elif url.startswith("tg://"):
                if not self.plugin.get_setting("confirm_deeplinks", False):
                    return
                    
                self.pending_intent = intent
                self.pending_param = param
                param.setResult(None)  
                run_on_ui_thread(lambda: self.show_deeplink_confirmation_dialog(url))
                return

        except Exception as e:
            pass

    def show_ayugram_warning_dialog(self, url: str):
        try:
            fragment = get_last_fragment()
            activity = fragment.getParentActivity() if fragment else None

            if not activity:
                self.proceed_deeplink()
                return

            builder = AlertDialogBuilder(activity)
            builder.set_title(get_string("ayugram_deeplink_title", "AyuGram Deep Link"))
            builder.set_message(get_string("ayugram_deeplink_message", "This AyuGram link may redirect to auto-playing content with blocked controls."))
            builder.set_positive_button(get_string("proceed_anyway", "Proceed Anyway"), lambda b, w: self.proceed_deeplink())
            builder.set_negative_button(get_string("cancel", "Cancel"), lambda b, w: self.cancel_deeplink())
            builder.set_on_cancel_listener(lambda b: self.cancel_deeplink())
            builder.make_button_red(AlertDialogBuilder.BUTTON_POSITIVE)
            builder.show()

        except Exception as e:
            self.proceed_deeplink()

    def show_deeplink_confirmation_dialog(self, url: str):
        try:
            fragment = get_last_fragment()
            activity = fragment.getParentActivity() if fragment else None

            if not activity:
                self.proceed_deeplink()
                return

            builder = AlertDialogBuilder(activity)
            builder.set_title(get_string("confirm_deeplink_title", "Confirm Deep Link"))
            builder.set_message(get_string("confirm_deeplink_message", "Do you really want to open this deep link?\n{url}").format(url=url))
            builder.set_positive_button(get_string("open", "Open"), lambda b, w: self.proceed_deeplink())
            builder.set_negative_button(get_string("cancel", "Cancel"), lambda b, w: self.cancel_deeplink())
            builder.set_on_cancel_listener(lambda b: self.cancel_deeplink())
            builder.show()

        except Exception as e:
            self.proceed_deeplink()

    def proceed_deeplink(self):
        try:
            if self.pending_param and self.pending_intent:
                
                self.is_processing = True
                
                instance = self.pending_param.thisObject
                original_method = self.pending_param.method
                arguments = [self.pending_intent, True, False, False, None, True, False]
                original_method.invoke(instance, *arguments)
                
                
                self.pending_intent = None
                self.pending_param = None
                self.is_processing = False
        except Exception as e:
            self.is_processing = False
            pass

    def cancel_deeplink(self):
        self.pending_intent = None
        self.pending_param = None
        self.is_processing = False


class SetCommandHook:
    def __init__(self, plugin: UiTweaksPlugin):
        self.plugin = plugin

    def before_hooked_method(self, param):
        try:
            message_object = param.args[0]  
            command = param.args[1] 
            long_press = param.args[2] 
            username = param.args[3] 
            
            if message_object is not None and command is not None and command.startswith('/'):
                self.plugin.command_from_message_click = True
            else:
                self.plugin.command_from_message_click = False
            
        except Exception as e:
            self.plugin.command_from_message_click = False


class StarReactionMenuHook:
    def __init__(self, plugin: UiTweaksPlugin):
        self.plugin = plugin
        self._items_field = None
        self._visible_reactions_field = None

    def before_hooked_method(self, param):
        try:
            if not self.plugin.get_setting("hide_star_reaction", False):
                return
            
            hide_location = self.plugin.get_setting("star_reaction_hide_location", 0)
            if hide_location not in [0, 2]: 
                return
                
            container = param.thisObject
            if container is None:
                return
                
            try:
                if self._items_field is None:
                    self._items_field = container.getClass().getDeclaredField("items")
                    self._items_field.setAccessible(True)
                items = self._items_field.get(container)
                
                if items is not None and items.size() > 0:
                    filtered_items = []
                    star_count = 0
                    for i in range(items.size()):
                        item = items.get(i)
                        if item is not None:
                            reaction = getattr(item, 'reaction', None)
                            if reaction is not None:
                                is_star_property = getattr(reaction, 'isStar', False)
                                is_star_class = isinstance(reaction, jclass('org.telegram.tgnet.TLRPC$TL_reactionPaid'))
                                is_star = is_star_property or is_star_class
                                if is_star:
                                    star_count += 1
                                    continue
                                else:
                                    filtered_items.append(item)
                            else:
                                filtered_items.append(item)
                    
                    if len(filtered_items) < items.size():
                        from java.util import ArrayList
                        new_items = ArrayList()
                        for item in filtered_items:
                            new_items.add(item)
                        self._items_field.set(container, new_items)
                            
                        if hasattr(container, 'notifyDataSetChanged'):
                            container.notifyDataSetChanged()
                        
            except Exception as e:
                try:
                    if self._visible_reactions_field is None:
                        self._visible_reactions_field = container.getClass().getDeclaredField("visibleReactions")
                        self._visible_reactions_field.setAccessible(True)
                    visible_reactions = self._visible_reactions_field.get(container)
                    
                    if visible_reactions is not None:
                        filtered_reactions = []
                        for i in range(visible_reactions.size()):
                            reaction = visible_reactions.get(i)
                            if reaction is not None:
                                is_star_property = getattr(reaction, 'isStar', False)
                                is_star_class = isinstance(reaction, jclass('org.telegram.tgnet.TLRPC$TL_reactionPaid'))
                                is_star = is_star_property or is_star_class
                                if is_star:
                                    continue
                                else:
                                    filtered_reactions.append(reaction)
                        
                        if len(filtered_reactions) < visible_reactions.size():
                            from java.util import ArrayList
                            new_list = ArrayList()
                            for reaction in filtered_reactions:
                                new_list.add(reaction)
                            self._visible_reactions_field.set(container, new_list)
                            
                except Exception as e2:
                    pass
                
        except Exception as e:
            pass


class StarReactionVisibleListHook:
    def __init__(self, plugin: UiTweaksPlugin):
        self.plugin = plugin

    def before_hooked_method(self, param):
        try:
            
            if not self.plugin.get_setting("hide_star_reaction", False):
                return
                
            hide_location = self.plugin.get_setting("star_reaction_hide_location", 0)
            if hide_location not in [0, 2]: 
                return
                
            reactions_list = param.args[0]
            if reactions_list is None or reactions_list.size() == 0:
                return
                
            
            filtered_reactions = []
            has_star = False
            for i in range(reactions_list.size()):
                reaction = reactions_list.get(i)
                if reaction is not None:
                    is_star_property = getattr(reaction, 'isStar', False)
                    is_star_class = isinstance(reaction, jclass('org.telegram.tgnet.TLRPC$TL_reactionPaid'))
                    is_star = is_star_property or is_star_class
                    if is_star:
                        has_star = True
                    else:
                        filtered_reactions.append(reaction)
            
            if has_star and len(filtered_reactions) < reactions_list.size():
                from java.util import ArrayList
                new_list = ArrayList()
                for reaction in filtered_reactions:
                    new_list.add(reaction)
                param.args[0] = new_list
                
        except Exception as e:
            pass


class StarReactionGradientHook:
    def __init__(self, plugin: UiTweaksPlugin):
        self.plugin = plugin

    def before_hooked_method(self, param):
        try:
            if not self.plugin.get_setting("hide_star_reaction", False):
                return
                
            hide_location = self.plugin.get_setting("star_reaction_hide_location", 0)
            if hide_location not in [0, 2]:
                return
                
            container = param.thisObject
            if container is None:
                return
                
            try:
                has_star_field = container.getClass().getDeclaredField("hasStar")
                has_star_field.setAccessible(True)
                has_star_field.set(container, False)
            except Exception as e:
                pass
                
        except Exception as e:
            pass


class StarReactionLayoutDrawHook:
    def __init__(self, plugin: UiTweaksPlugin):
        self.plugin = plugin

    def before_hooked_method(self, param):
        try:
            if not self.plugin.get_setting("hide_star_reaction", False):
                return
                
            hide_cells = self.plugin.get_setting("star_reaction_hide_cells", False)
            if not hide_cells: 
                return
                
            message_object = param.args[0] if len(param.args) > 0 else None
            if message_object is None:
                return
            if (hasattr(message_object, 'messageOwner') and 
                message_object.messageOwner is not None and 
                hasattr(message_object.messageOwner, 'reactions') and 
                message_object.messageOwner.reactions is not None and
                hasattr(message_object.messageOwner.reactions, 'results') and
                message_object.messageOwner.reactions.results is not None):
                
                original_results = message_object.messageOwner.reactions.results
                filtered_results = []
                
                for i in range(original_results.size()):
                    reaction_count = original_results.get(i)
                    if reaction_count is not None and reaction_count.reaction is not None:
                        is_star_property = getattr(reaction_count.reaction, 'isStar', False)
                        is_star_class = isinstance(reaction_count.reaction, jclass('org.telegram.tgnet.TLRPC$TL_reactionPaid'))
                        is_star = is_star_property or is_star_class
                        
                        if not is_star:
                            filtered_results.append(reaction_count)
                
                if len(filtered_results) < original_results.size():
                    from java.util import ArrayList
                    new_results = ArrayList()
                    for result in filtered_results:
                        new_results.add(result)
                    message_object.messageOwner.reactions.results = new_results
                        
        except Exception as e:
            pass


class DownloadManagerHook:
    def __init__(self, plugin: UiTweaksPlugin):
        self.plugin = plugin

    def before_hooked_method(self, param):
        try:
            if self.plugin.get_setting("always_show_download_manager", False):
                param.setResult(True)
        except Exception as e:
            pass

class ProxyButtonHook:
    def __init__(self, plugin: UiTweaksPlugin):
        self.plugin = plugin

    def after_hooked_method(self, param):
        try:
            if not self.plugin.get_setting("always_show_proxy_button", False):
                return
            
            dialogs_activity = param.thisObject
            
            try:
                proxy_item_field = dialogs_activity.getClass().getDeclaredField("proxyItem")
                proxy_item_field.setAccessible(True)
                proxy_item = proxy_item_field.get(dialogs_activity)
                
                if proxy_item is not None:
                    proxy_item.setVisibility(0)
                    
                    proxy_visible_field = dialogs_activity.getClass().getDeclaredField("proxyItemVisible")
                    proxy_visible_field.setAccessible(True)
                    proxy_visible_field.set(dialogs_activity, True)
                    
            except Exception as e:
                pass
                
        except Exception as e:
            pass

class ArticleViewerFixHook:
    def __init__(self, plugin: UiTweaksPlugin):
        self.plugin = plugin

    def before_hooked_method(self, param):
        try:
            if self.plugin.get_setting("disable_article_viewer_swipe", False):
                param.setResult(False)
        except Exception as e:
            pass


class WebAppSwipePreventionHook:
    def __init__(self, plugin: UiTweaksPlugin):
        self.plugin = plugin

    def after_hooked_method(self, param):
        try:
            swipe_container = param.thisObject
            if swipe_container:
                swipe_container.setAllowSwipes(False)
        except Exception as e:
            pass


class PhoneFormatHook:
    def __init__(self, plugin):
        self.plugin = plugin
    
    def after_hooked_method(self, param):
        try:
            phone_str = param.args[0]
            if phone_str and str(phone_str).startswith('+'):
                is_other = self.is_other_user_profile()
                if is_other:
                    param.setResult(get_string("MobileHidden", "Mobile hidden"))
        except:
            pass
    
    def is_other_user_profile(self):
        try:
            fragment = get_last_fragment()
            if not fragment or fragment.getClass().getSimpleName() != "ProfileActivity":
                return False
            
            userId_field = fragment.getClass().getDeclaredField("userId")
            userId_field.setAccessible(True)
            user_id = userId_field.getLong(fragment)
            
            if user_id == 0:
                return False
            
            from org.telegram.messenger import UserConfig
            current_user_id = UserConfig.getInstance(fragment.getCurrentAccount()).getClientUserId()
            return user_id != current_user_id
        except:
            return False


class MessagesControllerGetDialogsHook:
    def __init__(self, plugin: UiTweaksPlugin):
        self.plugin = plugin
        self._processed_accounts = set()

    def _remove_folder_dialog(self, dialog_list, dialog_object):
        if dialog_list is None:
            return
        for i in range(dialog_list.size() - 1, -1, -1):
            if dialog_object.isFolderDialogId(dialog_list.get(i).id):
                dialog_list.remove(i)
                return

    def before_hooked_method(self, param):
        try:
            if not self.plugin.get_setting("hide_archived_chats", False):
                self._processed_accounts.clear()
                return

            mc = param.thisObject
            account_id = mc.currentAccount
            
            if account_id in self._processed_accounts:
                return
            
            dialog_object = jclass("org.telegram.messenger.DialogObject")
            archive_id = dialog_object.makeFolderDialogId(1)
            
            if mc.dialogs_dict.get(archive_id) is not None:
                mc.dialogs_dict.remove(archive_id)
            
            self._remove_folder_dialog(mc.allDialogs, dialog_object)
            
            folder_dialogs = mc.dialogsByFolder.get(0) if mc.dialogsByFolder else None
            self._remove_folder_dialog(folder_dialogs, dialog_object)
            
            self._processed_accounts.add(account_id)
        except Exception:
            pass


class ChatUtilsHasArchivedHook:
    def __init__(self, plugin: UiTweaksPlugin):
        self.plugin = plugin

    def after_hooked_method(self, param):
        try:
            if self.plugin.get_setting("hide_archived_chats", False) and not self.plugin.get_setting("hide_archived_from_drawer", False):
                param.setResult(True)
        except Exception:
            pass


class ExteraConfigArchivedHook:
    def __init__(self, plugin: UiTweaksPlugin):
        self.plugin = plugin

    def before_hooked_method(self, param):
        try:
            if self.plugin.get_setting("hide_archived_chats", False) and not self.plugin.get_setting("hide_archived_from_drawer", False):
                if len(param.args) >= 2 and param.args[0] == "archivedChats":
                    param.thisObject.setObj("archivedChats", True)
                    param.setResult(None)
        except Exception:
            pass


class MessagesControllerSendTypingHook:
    def __init__(self, plugin: UiTweaksPlugin):
        self.plugin = plugin

    def before_hooked_method(self, param):
        try:
            if not self.plugin.get_setting("typing_instead_sticker", False):
                return

            if len(param.args) < 3:
                return

            action = param.args[2]
            if action == 10:
                from java.lang import Integer
                param.args[2] = Integer(0)
        except Exception:
            pass


class UpdateBotButtonHook:
    def __init__(self, plugin: UiTweaksPlugin):
        self.plugin = plugin

    def replace_hooked_method(self, param):
        try:
            if self.plugin.get_setting("hide_bot_button", False):
                self_instance = param.thisObject
                bot_button = getattr(self_instance, 'botButton', None)
                if bot_button:
                    bot_button.setVisibility(8)
                
                bot_commands_menu_button = getattr(self_instance, 'botCommandsMenuButton', None)
                if bot_commands_menu_button:
                    bot_commands_menu_button.setVisibility(8)
            
            return None
        except Exception as e:
            return None








class VoiceMessageControlHook:
    def __init__(self, plugin: UiTweaksPlugin):
        self.plugin = plugin

    def before_hooked_method(self, param):
        try:
            by_voice_end = param.args[2]
            if not by_voice_end:
                return
            
            media_controller = param.thisObject
            if media_controller is None:
                return
            
            try:
                playlist_field = media_controller.getClass().getDeclaredField("voiceMessagesPlaylist")
                playlist_field.setAccessible(True)
                voice_playlist = playlist_field.get(media_controller)
                
                playing_field = media_controller.getClass().getDeclaredField("playingMessageObject")
                playing_field.setAccessible(True)
                playing_message = playing_field.get(media_controller)
                
                if (playing_message and 
                    hasattr(playing_message, 'isVoice') and 
                    playing_message.isVoice() and
                    voice_playlist and 
                    voice_playlist.size() > 1):
                    
                    playlist_field.set(media_controller, None)
                    
                    playlist_map_field = media_controller.getClass().getDeclaredField("voiceMessagesPlaylistMap")
                    playlist_map_field.setAccessible(True)
                    playlist_map_field.set(media_controller, None)
                    
            except Exception as e:
                pass
                
        except Exception as e:
            pass


class VideoMessageControlHook:
    def __init__(self, plugin: UiTweaksPlugin):
        self.plugin = plugin

    def before_hooked_method(self, param):
        try:
            if not param.args[2] or not param.thisObject:
                return
            try:
                playing_field = param.thisObject.getClass().getDeclaredField("playingMessageObject")
                playing_field.setAccessible(True)
                playing_message = playing_field.get(param.thisObject)
                if (playing_message and hasattr(playing_message, 'isRoundVideo') and playing_message.isRoundVideo()):
                    voice_playlist_field = param.thisObject.getClass().getDeclaredField("voiceMessagesPlaylist")
                    voice_playlist_field.setAccessible(True)
                    voice_playlist = voice_playlist_field.get(param.thisObject)
                    if voice_playlist and voice_playlist.size() > 1:
                        voice_playlist_field.set(param.thisObject, None)
                        voice_playlist_map_field = param.thisObject.getClass().getDeclaredField("voiceMessagesPlaylistMap")
                        voice_playlist_map_field.setAccessible(True)
                        voice_playlist_map_field.set(param.thisObject, None)
            except:
                pass
        except:
            pass


class VoiceMessageTimeDisplayHook:
    def __init__(self, plugin: UiTweaksPlugin):
        self.plugin = plugin
        self._cell_cache = {}
        self._last_update_ts = {}
        self._cache_order = []
        self._cache_capacity = 16
        self._pending_updates = {}
        
    def after_hooked_method(self, param):
        try:
            if not self.plugin.get_setting("progress_timestamp_enabled", False):
                return
                
            cell = param.thisObject
            if not cell:
                return
                
            messageObject = get_private_field(cell, "currentMessageObject")
            if not messageObject:
                return
                
            documentAttachType = get_private_field(cell, "documentAttachType")
                
            if not self.is_voice_message(messageObject) and not self.is_round_video_message(messageObject):
                return
                
            if documentAttachType != 3 and not (hasattr(messageObject, 'isRoundVideo') and messageObject.isRoundVideo()):
                return
            
            if hasattr(messageObject, 'isRoundVideo') and messageObject.isRoundVideo():
                try:
                    set_private_field(cell, "roundPlayingDrawableProgress", 0.0)
                except:
                    pass
                
            self._apply_cached_update(cell, messageObject)
            
        except Exception as e:
            pass

    def _apply_cached_update(self, cell, messageObject):
        throttle_ms = 35
        key = id(cell)
        
        try:
            curr_id = int(messageObject.getId())
            curr_did = int(messageObject.getDialogId())
            duration = self.get_voice_duration(messageObject)
            currentProgress = 0
            if self.is_playing(messageObject):
                currentProgress = self.get_audio_progress_sec(messageObject)
        except:
            return
            
        prev = self._cell_cache.get(key)
        if prev is not None and len(prev) >= 5 and prev[3] == curr_id and prev[4] == curr_did and prev[0] == currentProgress and prev[1] == duration:
            try:
                if prev[2] is not None:
                    set_private_field(cell, "durationLayout", prev[2])
                cell.invalidate()
            except:
                pass
            return
            
        pend = self._pending_updates.get(key)
        if pend and pend[0] == curr_did and pend[1] == curr_id and pend[2] == currentProgress:
            return
            
        self._pending_updates[key] = (curr_did, curr_id, currentProgress)
        
        def runner():
            try:
                c = cell
                m = get_private_field(c, "currentMessageObject")
                if m is None:
                    return
                if int(m.getDialogId()) == curr_did and int(m.getId()) == curr_id:
                    self._force_update_with_cache(c, m)
            finally:
                self._pending_updates.pop(key, None)
        
        try:
            from org.telegram.messenger import AndroidUtilities
            AndroidUtilities.runOnUIThread(runner, throttle_ms)
        except:
            self._force_update_with_cache(cell, messageObject)

    def _force_update_with_cache(self, cell, messageObject):
        try:
            duration = self.get_voice_duration(messageObject)
            if duration <= 0:
                return
                
            currentProgress = 0
            if self.is_playing(messageObject):
                currentProgress = self.get_audio_progress_sec(messageObject)
                
            from org.telegram.messenger import AndroidUtilities
            from org.telegram.ui.ActionBar import Theme
            from android.text import StaticLayout, Layout
            from java import jint
            
            timeString = AndroidUtilities.formatShortDuration(currentProgress, int(duration))
            
            chatAudioTimePaint = Theme.chat_audioTimePaint
            if not chatAudioTimePaint:
                return
                
            timeWidth = int(chatAudioTimePaint.measureText(timeString))
            
            durationLayout = StaticLayout(
                timeString,
                chatAudioTimePaint,
                timeWidth,
                Layout.Alignment.ALIGN_NORMAL,
                1.0,
                0.0,
                False
            )
            
            set_private_field(cell, "durationLayout", durationLayout)
            set_private_field(cell, "timeWidthAudio", jint(timeWidth))
            set_private_field(cell, "lastTime", jint(currentProgress))
            cell.invalidate()
            
            key = id(cell)
            try:
                curr_id = int(messageObject.getId())
                curr_did = int(messageObject.getDialogId())
                self._cell_cache[key] = (currentProgress, duration, durationLayout, curr_id, curr_did)
                
                if key in self._cache_order:
                    self._cache_order.remove(key)
                self._cache_order.append(key)
                if len(self._cache_order) > self._cache_capacity:
                    old_key = self._cache_order.pop(0)
                    self._cell_cache.pop(old_key, None)
                    self._last_update_ts.pop(old_key, None)
            except:
                pass
                
        except Exception as e:
            pass
    
    def is_voice_message(self, messageObject):
        if not self.plugin.get_setting("voice_message_time_display", True):
            return False
        return hasattr(messageObject, 'isVoice') and messageObject.isVoice()
    
    def is_round_video_message(self, messageObject):
        if not self.plugin.get_setting("round_video_time_display", True):
            return False
        return hasattr(messageObject, 'isRoundVideo') and messageObject.isRoundVideo()
    
    def get_voice_duration(self, messageObject):
        return messageObject.getDuration() if hasattr(messageObject, 'getDuration') else 0
    
    def is_playing(self, messageObject):
        try:
            from org.telegram.messenger import MediaController
            return MediaController.getInstance().isPlayingMessage(messageObject)
        except:
            return False
    
    def get_audio_progress_sec(self, messageObject):
        return messageObject.audioProgressSec if hasattr(messageObject, 'audioProgressSec') else 0


class GifSpoilerHook:
    def __init__(self, plugin: UiTweaksPlugin):
        self.plugin = plugin
        self.added_items = []
        self.current_viewer = None

    def after_hooked_method(self, param):
        try:
            viewer = get_private_field(param.thisObject, "this$0")
            if not viewer:
                return

            if self.current_viewer and self.current_viewer != viewer:
                self.cleanup_menu_items()
                self.plugin.log("GIF Menu: Cleaned up previous menu items due to viewer change")

            self.current_viewer = viewer

            popup_window = get_private_field(viewer, "popupWindow")
            preview_menu = None
            if popup_window:
                preview_menu = popup_window.getContentView()
            else:
                preview_menu = get_private_field(viewer, "popupLayout")
            document = get_private_field(viewer, "currentDocument")

            if preview_menu and document:
                self.plugin.log("GIF Menu: Adding spoiler and caption menu items")
                self.add_spoiler_menu(preview_menu, viewer, document)

        except Exception as e:
            self.plugin.log(f"GIF Menu Error: {e}")
            pass

    def add_spoiler_menu(self, preview_menu, viewer, document):
        try:
            if not MessageObject.isGifDocument(document):
                self.plugin.log("GIF Menu: Document is not a GIF, skipping menu addition")
                return

            resources_provider = get_private_field(viewer, "resourcesProvider")
            delegate = get_private_field(viewer, "delegate")

            if not delegate or not delegate.needSend(1):
                self.plugin.log("GIF Menu: Delegate cannot send, skipping menu addition")
                return



            self.cleanup_menu_items()

            self.plugin.log("GIF Menu: Creating spoiler menu item")
            spoiler_item = ActionBarMenuItem.addItem(
                preview_menu,
                R_tg.drawable.msg_spoiler,
                get_string("hide_with_spoiler", "Hide with spoiler"),
                False,
                resources_provider)
            spoiler_item.setOnClickListener(OnClickListener(lambda *_: self.send_gif_with_spoiler(viewer, document, delegate)))
            self.added_items.append(spoiler_item)

            self.plugin.log("GIF Menu: Creating caption menu item")
            caption_item = ActionBarMenuItem.addItem(
                preview_menu,
                R_tg.drawable.menu_tag_edit_solar,
                get_string("send_with_caption", "Send with Caption"),
                False,
                resources_provider)
            caption_item.setOnClickListener(OnClickListener(lambda *_: self.show_caption_dialog(viewer, document, delegate)))
            self.added_items.append(caption_item)

            self.plugin.log(f"GIF Menu: Successfully added {len(self.added_items)} menu items")

        except Exception as e:
            self.plugin.log(f"GIF Menu: Error adding spoiler menu: {e}")
            pass

    def cleanup_menu_items(self):
        try:
            if not self.added_items:
                return
                
            self.plugin.log(f"GIF Menu: Cleaning up {len(self.added_items)} menu items")
            
            for item in self.added_items:
                try:
                    if item and hasattr(item, 'getParent'):
                        parent = item.getParent()
                        if parent:
                            parent.removeView(item)
                            self.plugin.log("GIF Menu: Removed menu item from parent")
                except Exception as e:
                    self.plugin.log(f"GIF Menu: Error removing menu item: {e}")
            
            self.added_items.clear()
            self.plugin.log("GIF Menu: Menu items cleanup completed")
            
        except Exception as e:
            self.plugin.log(f"GIF Menu: Error during cleanup: {e}")

    def send_gif_with_spoiler(self, viewer, document, delegate):
        try:
            parent = get_private_field(viewer, "parentObject")
            current_account = get_private_field(viewer, "currentAccount")

            topic_id = 0
            user_reply_to_msg = None
            topic_reply_to_msg = None
            
            try:
                from client_utils import get_last_fragment
                current_fragment = get_last_fragment()
                if current_fragment:
                    if hasattr(current_fragment, 'getTopicId'):
                        topic_id = current_fragment.getTopicId()
                    
                    if hasattr(current_fragment, 'getChatActivityEnterView'):
                        enter_view = current_fragment.getChatActivityEnterView()
                        if enter_view and hasattr(enter_view, 'getReplyingMessageObject'):
                            user_reply_to_msg = enter_view.getReplyingMessageObject()
            except:
                pass

            send_messages_helper = SendMessagesHelper.getInstance(current_account)

            from org.telegram.messenger import AccountInstance
            account_instance = AccountInstance.getInstance(current_account)
            
            if topic_id != 0:
                try:
                    from org.telegram.tgnet import TLRPC
                    topic = account_instance.getMessagesController().getTopicsController().findTopic(-delegate.getDialogId(), topic_id)
                    if topic and topic.topicStartMessage:
                        topic_reply_to_msg = MessageObject(current_account, topic.topicStartMessage, False, False)
                        topic_reply_to_msg.isTopicMainMessage = True
                except:
                    pass

            send_message_params = self.plugin._create_send_message_params_document(
                document, delegate.getDialogId(), user_reply_to_msg, topic_reply_to_msg if topic_reply_to_msg else user_reply_to_msg, None, parent, True
            )

            send_messages_helper.sendMessage(send_message_params)

            from org.telegram.messenger import MediaDataController
            from java.lang import System
            MediaDataController.getInstance(current_account).addRecentGif(document, int(System.currentTimeMillis() / 1000), True)
            
            try:
                from client_utils import get_last_fragment
                current_fragment = get_last_fragment()
                if current_fragment and hasattr(current_fragment, 'hideFieldPanel'):
                    current_fragment.hideFieldPanel(False)
            except:
                pass

        except Exception as e:
            pass
        finally:
            self.dismiss_popup(viewer)

    def show_caption_dialog(self, viewer, document, delegate):
        try:
            from org.telegram.ui.Components import EditTextBoldCursor
            from android.text import InputType
            from android.util import TypedValue
            
            activity = get_last_fragment().getParentActivity()
            if not activity:
                return

            input_field = EditTextBoldCursor(activity)
            input_field.setHint(get_string("enter_caption", "Message"))
            input_field.setInputType(InputType.TYPE_CLASS_TEXT)
            input_field.setMaxLines(1)
            input_field.setSingleLine(True)
            input_field.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 18)
            input_field.setTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteBlackText))
            input_field.setHintTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteHintText))
            input_field.setBackground(Theme.createEditTextDrawable(activity, True))
            input_field.setCursorColor(Theme.getColor(Theme.key_windowBackgroundWhiteBlueHeader))
            input_field.setCursorSize(AndroidUtilities.dp(20))
            input_field.setCursorWidth(1.5)
            input_field.setPadding(0, 0, 0, 0)
            input_field.setFocusable(True)
            
            def on_send_click(dialog, which):
                try:
                    AndroidUtilities.hideKeyboard(input_field)
                    caption = input_field.getText().toString()
                    self.send_gif_with_caption(viewer, document, delegate, caption)
                except Exception:
                    pass
                dialog.dismiss()
            
            def on_cancel_click(dialog, which):
                try:
                    AndroidUtilities.hideKeyboard(input_field)
                except Exception:
                    pass
                dialog.dismiss()
            
            builder = AlertDialogBuilder(activity)
            builder.set_title(get_string("add_caption_to_gif", "Caption"))
            builder.set_view(input_field)
            builder.set_negative_button(get_string("cancel", "Cancel"), on_cancel_click)
            builder.set_positive_button(get_string("send", "Send"), on_send_click)
            
            dialog = builder.show()
            
            def apply_layout_params():
                try:
                    layout_params = input_field.getLayoutParams()
                    if layout_params is not None:
                        if isinstance(layout_params, FrameLayout.LayoutParams):
                            layout_params.gravity = Gravity.CENTER_HORIZONTAL
                        
                        if hasattr(layout_params, 'rightMargin'):
                            layout_params.rightMargin = AndroidUtilities.dp(24)
                            layout_params.leftMargin = AndroidUtilities.dp(24)
                            layout_params.height = AndroidUtilities.dp(36)
                            layout_params.bottomMargin = AndroidUtilities.dp(15)
                        input_field.setLayoutParams(layout_params)
                    
                    input_field.requestFocus()
                    text_length = input_field.getText().length() if input_field.getText() else 0
                    input_field.setSelection(0, text_length)
                    AndroidUtilities.showKeyboard(input_field)
                except Exception:
                    pass
            
            run_on_ui_thread(apply_layout_params, delay=100)
        except:
            pass

    def send_gif_with_caption(self, viewer, document, delegate, caption):
        try:
            current_account = get_private_field(viewer, "currentAccount")
            
            topic_id = 0
            user_reply_to_msg = None
            topic_reply_to_msg = None
            
            try:
                from client_utils import get_last_fragment
                current_fragment = get_last_fragment()
                if current_fragment:
                    if hasattr(current_fragment, 'getTopicId'):
                        topic_id = current_fragment.getTopicId()
                    
                    if hasattr(current_fragment, 'getChatActivityEnterView'):
                        enter_view = current_fragment.getChatActivityEnterView()
                        if enter_view and hasattr(enter_view, 'getReplyingMessageObject'):
                            user_reply_to_msg = enter_view.getReplyingMessageObject()
            except:
                pass

            if topic_id != 0:
                try:
                    from org.telegram.messenger import AccountInstance
                    from org.telegram.tgnet import TLRPC
                    account_instance = AccountInstance.getInstance(current_account)
                    topic = account_instance.getMessagesController().getTopicsController().findTopic(-delegate.getDialogId(), topic_id)
                    if topic and topic.topicStartMessage:
                        topic_reply_to_msg = MessageObject(current_account, topic.topicStartMessage, False, False)
                        topic_reply_to_msg.isTopicMainMessage = True
                except:
                    pass
            
            SendMessagesHelper.getInstance(current_account).sendMessage(
                self.plugin._create_send_message_params_document(
                    document, delegate.getDialogId(), user_reply_to_msg, topic_reply_to_msg if topic_reply_to_msg else user_reply_to_msg, caption, get_private_field(viewer, "parentObject"), False
                )
            )
            from org.telegram.messenger import MediaDataController
            from java.lang import System
            MediaDataController.getInstance(current_account).addRecentGif(document, int(System.currentTimeMillis() / 1000), True)
            
            try:
                from client_utils import get_last_fragment
                current_fragment = get_last_fragment()
                if current_fragment and hasattr(current_fragment, 'hideFieldPanel'):
                    current_fragment.hideFieldPanel(False)
            except:
                pass
            
            self.dismiss_popup(viewer)
        except:
            pass

    def dismiss_popup(self, viewer):
        try:
            self.plugin.log("GIF Menu: Dismissing popup and cleaning up menu items")
            self.cleanup_menu_items()
            
            method = viewer.getClass().getDeclaredMethod("dismissPopupWindow")
            method.setAccessible(True)
            method.invoke(viewer)
            self.plugin.log("GIF Menu: Popup dismissed successfully")
        except Exception as e:
            self.plugin.log(f"GIF Menu: Error dismissing popup: {e}")
            pass


class GifDismissHook:
    def __init__(self, plugin: UiTweaksPlugin):
        self.plugin = plugin

    def before_hooked_method(self, param):
        try:
            if hasattr(self.plugin, 'hook_gif_spoiler_ref') and self.plugin.hook_gif_spoiler_ref:
                hook_instance = self.plugin.hook_gif_spoiler_ref
                if hasattr(hook_instance, 'cleanup_menu_items'):
                    self.plugin.log("GIF Menu: Auto-cleanup triggered by dismiss hook")
                    hook_instance.cleanup_menu_items()
        except Exception as e:
            self.plugin.log(f"GIF Menu: Error in dismiss hook cleanup: {e}")


class ProcessExternalUrlHook:
    def __init__(self, plugin: UiTweaksPlugin):
        self.plugin = plugin

    def before_hooked_method(self, param):
        try:
            url = param.args[1]
            if url and self.is_external(url):
                param.args[4] = True
        except Exception:
            pass

    def is_external(self, url):
        try:
            from android.net import Uri
            uri = Uri.parse(url)
            host = uri.getHost()
            if not host:
                return False
            host = host.lower()
            return not any(host == domain or host.endswith("." + domain) 
                          for domain in ["t.me", "telegram.me", "telegram.dog", "telegram.org", "telegram.com"])
        except Exception:
            return True


class CreateViewHook(MethodHook):
    def __init__(self, plugin):
        self.plugin = plugin
    
    def after_hooked_method(self, param):
        try:
            chat_activity = param.thisObject
            if chat_activity is None:
                return
            
            action_bar = chat_activity.actionBar
            if action_bar is None:
                return
            
            back_button = action_bar.backButtonImageView
            if back_button is None:
                return
            
            self.plugin.current_chat_activity = chat_activity
            self.plugin.current_back_button = back_button
            
            back_button_id = id(back_button)
            if back_button_id not in self.plugin.counter_views:
                self._create_badge(chat_activity, back_button)
            
            self._update_badge(chat_activity)
            
        except Exception:
            pass
    
    def _create_badge(self, chat_activity, back_button):
        try:
            CounterViewClass = find_class("org.telegram.ui.Components.CounterView")
            LayoutHelperClass = find_class("org.telegram.ui.Components.LayoutHelper")
            GravityClass = find_class("android.view.Gravity")
            AndroidUtilities = jclass("org.telegram.messenger.AndroidUtilities")
            
            if not CounterViewClass:
                return
            
            context = back_button.getContext()
            counter_view = CounterViewClass(context, None)
            counter_view.setGravity(GravityClass.LEFT)
            counter_view.setReverse(True)
            
            layout_params = LayoutHelperClass.createFrame(
                -2,
                -2,
                GravityClass.LEFT | GravityClass.TOP,
                0, 0, 0, 0
            )
            
            action_bar = back_button.getParent()
            action_bar.addView(counter_view, layout_params)
            
            self.plugin.counter_views[id(back_button)] = counter_view
            
            from android_utils import run_on_ui_thread
            def force_layout():
                try:
                    ViewClass = find_class("android.view.View")
                    counter_view.setVisibility(ViewClass.VISIBLE)
                    
                    status_bar_height = AndroidUtilities.statusBarHeight if action_bar.getOccupyStatusBar() else 0
                    
                    badge_x = AndroidUtilities.dp(30)
                    badge_y = status_bar_height - AndroidUtilities.dp(30)
                    
                    counter_view.setX(badge_x)
                    counter_view.setY(badge_y)
                    counter_view.setElevation(AndroidUtilities.dp(2))
                    
                    counter_view.bringToFront()
                    counter_view.requestLayout()
                    action_bar.requestLayout()
                    action_bar.invalidate()
                    
                    self._update_badge(chat_activity)
                except Exception:
                    pass
            
            run_on_ui_thread(force_layout)
            
            def register_observer():
                try:
                    NotificationCenter = jclass("org.telegram.messenger.NotificationCenter")
                    notification_center = chat_activity.getNotificationCenter()
                    
                    from java import dynamic_proxy
                    NotificationCenterDelegate = self.plugin._get_class("org.telegram.messenger.NotificationCenter$NotificationCenterDelegate")
                    
                    ObserverProxy = dynamic_proxy(NotificationCenterDelegate)
                    
                    class UnreadObserver(ObserverProxy):
                        def __init__(self, plugin_ref, chat_ref, back_btn_id):
                            super().__init__()
                            self.plugin = plugin_ref
                            self.chat_activity = chat_ref
                            self.back_button_id = back_btn_id
                        
                        def didReceivedNotification(self, notification_id, account, *args):
                            try:
                                if notification_id == NotificationCenter.dialogsUnreadCounterChanged:
                                    if self.back_button_id not in self.plugin.counter_views:
                                        return
                                    
                                    counter = self.plugin.counter_views[self.back_button_id]
                                    storage = self.chat_activity.getMessagesStorage()
                                    
                                    if storage:
                                        count = storage.getMainUnreadCount()
                                        
                                        from android_utils import run_on_ui_thread
                                        def update():
                                            try:
                                                ViewClass = self.plugin._get_class("android.view.View")
                                                try:
                                                    in_preview = self.chat_activity.inPreviewMode
                                                except:
                                                    in_preview = False
                                                
                                                if count > 0 and not in_preview:
                                                    counter.setVisibility(ViewClass.VISIBLE)
                                                    counter.setCount(count, True)
                                                else:
                                                    counter.setVisibility(ViewClass.GONE)
                                            except Exception:
                                                pass
                                        
                                        run_on_ui_thread(update)
                            except Exception:
                                pass
                    
                    observer = UnreadObserver(self.plugin, chat_activity, id(back_button))
                    notification_center.addObserver(observer, NotificationCenter.dialogsUnreadCounterChanged)
                    
                    self.plugin.counter_views[id(back_button) + 1000000] = observer
                    
                except Exception:
                    pass
            
            run_on_ui_thread(register_observer)
            
        except Exception:
            pass
    
    def _update_badge(self, chat_activity):
        try:
            back_button = chat_activity.actionBar.backButtonImageView
            if back_button is None:
                return
            
            back_button_id = id(back_button)
            if back_button_id not in self.plugin.counter_views:
                return
            
            counter_view = self.plugin.counter_views[back_button_id]
            
            messages_storage = chat_activity.getMessagesStorage()
            if messages_storage:
                unread_count = messages_storage.getMainUnreadCount()
                
                ViewClass = find_class("android.view.View")
                try:
                    in_preview = chat_activity.inPreviewMode
                except:
                    in_preview = False
                
                if unread_count > 0 and not in_preview:
                    counter_view.setVisibility(ViewClass.VISIBLE)
                    counter_view.setCount(unread_count, True)
                else:
                    counter_view.setVisibility(ViewClass.GONE)
            
        except Exception:
            pass


class FragmentDestroyHook(MethodHook):
    def __init__(self, plugin):
        self.plugin = plugin
    
    def after_hooked_method(self, param):
        try:
            chat_activity = param.thisObject
            if chat_activity is None:
                return
            
            action_bar = chat_activity.actionBar
            if action_bar is None:
                return
            
            back_button = action_bar.backButtonImageView
            if back_button is None:
                return
            
            back_button_id = id(back_button)
            observer_id = back_button_id + 1000000
            
            if observer_id in self.plugin.counter_views:
                observer = self.plugin.counter_views[observer_id]
                notification_center = chat_activity.getNotificationCenter()
                
                NotificationCenter = jclass("org.telegram.messenger.NotificationCenter")
                notification_center.removeObserver(observer, NotificationCenter.dialogsUnreadCounterChanged)
                
                del self.plugin.counter_views[observer_id]
            
            if back_button_id in self.plugin.counter_views:
                del self.plugin.counter_views[back_button_id]
            
        except Exception:
            pass


class ForwardConfirmationHook:
    def __init__(self, plugin: UiTweaksPlugin, reflected_method):
        self.plugin = plugin
        self.reflected_method = reflected_method
        self._suppress_next = False

    def before_hooked_method(self, param):
        try:
            chat_activity = param.thisObject
            if chat_activity is None:
                return
            if self._suppress_next:
                self._suppress_next = False
                return
            if not self.plugin.get_setting("enable_confirmation_settings", False) or not self.plugin.get_setting("confirm_forward", True):
                return
            args = list(param.args) if param.args else []
            def on_confirm():
                try:
                    self._suppress_next = True
                    self.reflected_method.setAccessible(True)
                    coerced = list(args)
                    if len(coerced) >= 6:
                        try:
                            coerced[4] = jclass("java.lang.Integer")(int(coerced[4]))
                        except Exception:
                            pass
                        try:
                            coerced[5] = jclass("java.lang.Long")(int(coerced[5]))
                        except Exception:
                            pass
                    self.reflected_method.invoke(chat_activity, *coerced)
                except Exception:
                    pass
  
            ctx = None
            try:
                fragment = get_last_fragment()
                ctx = fragment.getParentActivity() if fragment and fragment.getParentActivity() else None
            except Exception:
                ctx = None
            if ctx:
                def _show():
                    try:
                        builder = AlertDialogBuilder(ctx)
                        builder.set_title(get_string("confirm_forward", "Confirm Forwarding Messages"))
                        builder.set_message(get_string("confirm_forward_message", "Are you sure you want to forward this message?"))
                        builder.set_positive_button(get_string("ok", "OK"), lambda dialog, which: on_confirm())
                        builder.set_negative_button(get_string("cancel", "Cancel"), None)
                        builder.show()
                    except Exception:
                        pass
                run_on_ui_thread(_show)
                param.setResult(None)
            else:
                pass
        except Exception:
            pass


class JoinConfirmationClickListener(dynamic_proxy(find_class("android.view.View$OnClickListener"))):
    def __init__(self, original_listener):
        super().__init__()
        self.original_listener = original_listener

    def onClick(self, view):
        plugin_instance = uitweaks_plugin_instance
        if (not plugin_instance or 
            not plugin_instance.get_setting("enable_confirmation_settings", False) or 
            not plugin_instance.get_setting("confirm_join_chat", False) or 
            not self._is_join_action()):
            self.original_listener.onClick(view)
            return
            
        def show_confirmation():
            try:
                builder = AlertDialogBuilder(view.getContext())
                
                chat_name = self._get_chat_name()
                
                builder.set_title(get_string("join_confirmation", "Join Confirmation"))
                message = get_string("join_confirmation_message", "Are you sure you want to join **{chat_name}**?").format(chat_name=chat_name)
                builder.set_message(AndroidUtilities.replaceTags(message))
                
                def on_confirm(dialog, which):
                    dialog.dismiss()
                    self.original_listener.onClick(view)
                
                def on_cancel(dialog, which):
                    dialog.dismiss()
                
                builder.set_positive_button(get_string("join", "Join"), on_confirm)
                builder.set_negative_button(get_string("cancel", "Cancel"), on_cancel)
                builder.show()
                
            except Exception as e:
                self.original_listener.onClick(view)

        run_on_ui_thread(show_confirmation)

    def _is_join_action(self):
        try:
            fragment = get_last_fragment()
            if not fragment:
                return False
            
            if hasattr(fragment, 'currentChat') and fragment.currentChat:
                try:
                    chat_activity_class = find_class("org.telegram.ui.ChatActivity")
                    overlay_field = chat_activity_class.getClass().getDeclaredField("bottomOverlayChatText")
                    overlay_field.setAccessible(True)
                    overlay_text_view = overlay_field.get(fragment)
                    
                    if overlay_text_view and hasattr(overlay_text_view, 'getText'):
                        try:
                            if hasattr(fragment, 'currentChat') and fragment.currentChat:
                                chat_object_class = find_class("org.telegram.messenger.ChatObject")
                                if chat_object_class:
                                    is_not_in_chat_method = chat_object_class.getClass().getDeclaredMethod("isNotInChat", find_class("org.telegram.tgnet.TLRPC$Chat"))
                                    is_not_in_chat = is_not_in_chat_method.invoke(None, fragment.currentChat)
                                    return is_not_in_chat
                        except Exception as e:
                            pass
                except Exception as e:
                    pass
                
                return False
            
            return False
        except Exception as e:
            return False

    def _get_chat_name(self):
        try:
            fragment = get_last_fragment()
            if fragment and hasattr(fragment, 'currentChat') and fragment.currentChat and hasattr(fragment.currentChat, 'title'):
                return fragment.currentChat.title
            return "this chat"
        except:
            return "this chat"


class FillActionModeMenuHook:
    def __init__(self, plugin):
        self.plugin = plugin
    
    def after_hooked_method(self, param):
        try:
            menu = param.args[0]
            
            if menu.findItem(CUSTOM_CODE_ID) is not None:
                return
            
            string_builder = SpannableStringBuilder(get_string("code_menu_item", "Code"))
            string_builder.setSpan(TypefaceSpan(Typeface.MONOSPACE), 0, string_builder.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE)
            menu.add(R_tg.id.menu_groupbolditalic, CUSTOM_CODE_ID, 7, string_builder)
            
            mention_string_builder = SpannableStringBuilder(get_string("mention_menu_item", "Mention"))
            menu.add(R_tg.id.menu_groupbolditalic, CUSTOM_MENTION_ID, 8, mention_string_builder)
            
        except Exception as e:
            traceback.print_exc()

class PerformMenuActionHook:
    def __init__(self, plugin):
        self.plugin = plugin
    
    def before_hooked_method(self, param):
        try:
            item_id = param.args[0]
            edit_text = param.thisObject
            
            if item_id == CUSTOM_CODE_ID:
                import time
                current_time = time.time()
                
                if not hasattr(self.plugin, '_last_code_click'):
                    self.plugin._last_code_click = 0
                
                if current_time - self.plugin._last_code_click > DEBOUNCE_TIME:
                    self.plugin._last_code_click = current_time
                    self.plugin._make_selected_code(edit_text)
                return
                
            elif item_id == CUSTOM_MENTION_ID:
                import time
                current_time = time.time()
                
                if not hasattr(self.plugin, '_last_mention_click'):
                    self.plugin._last_mention_click = 0
                
                if current_time - self.plugin._last_mention_click > DEBOUNCE_TIME:
                    self.plugin._last_mention_click = current_time
                    self.plugin._make_selected_mention(edit_text)
                return
                
        except Exception as e:
            traceback.print_exc()


class JoinConfirmationHook:
    def __init__(self, plugin):
        self.plugin = plugin

    def after_hooked_method(self, param: Any):
        try:
            chat_activity = param.thisObject
            if not chat_activity:
                return

            chat_activity_class = self.plugin._get_class("org.telegram.ui.ChatActivity")
            overlay_field = chat_activity_class.getClass().getDeclaredField("bottomOverlayChatText")
            overlay_field.setAccessible(True)
            overlay_text_view = overlay_field.get(chat_activity)
            
            if not overlay_text_view:
                return

            view_class = self.plugin._get_class("android.view.View")
            listener_info_method = view_class.getClass().getDeclaredMethod("getListenerInfo")
            listener_info_method.setAccessible(True)
            listener_info = listener_info_method.invoke(overlay_text_view)
            
            if not listener_info:
                return

            click_listener_field = listener_info.getClass().getDeclaredField("mOnClickListener")
            click_listener_field.setAccessible(True)
            original_listener = click_listener_field.get(listener_info)
            
            if original_listener and not isinstance(original_listener, JoinConfirmationClickListener):
                custom_listener = JoinConfirmationClickListener(original_listener)
                overlay_text_view.setOnClickListener(custom_listener)
                
        except Exception as e:
            pass



uitweaks_plugin_instance = None

def uitweaks_log(message: str):
    if uitweaks_plugin_instance and uitweaks_plugin_instance.get_setting("show_logs", False):
        log(f"[UiTweaks] {message}")


class MessagePreviewViewHook:
    def __init__(self, plugin):
        self.plugin = plugin

    def after_hooked_method(self, param):
        try:
            preview_view = param.thisObject
            if preview_view and preview_view not in self.plugin.added_send_media_buttons:
                run_on_ui_thread(lambda: self.plugin._add_send_media_button(preview_view), 100)
        except:
            pass


class DisableAutoWebLoginHook:
    def __init__(self, plugin):
        self.plugin = plugin
        uitweaks_log("DisableAutoWebLoginHook initialized")

    def before_hooked_method(self, param):
        try:
            from org.telegram.messenger import AccountInstance, UserConfig
            currentAccount = UserConfig.selectedAccount
            messagesController = AccountInstance.getInstance(currentAccount).getMessagesController()
            if hasattr(messagesController, 'autologinDomains'):
                uitweaks_log("Clearing autologinDomains to prevent token injection")
                messagesController.autologinDomains.clear()
        except Exception as e:
            uitweaks_log("Error clearing autologinDomains: " + str(e))


class DoNotSharePhoneNumberHook:
    def __init__(self, plugin):
        self.plugin = plugin
        self.fill_items_hook = None

    def setup(self):
        try:
            ContactAddActivity = self.plugin._get_class("org.telegram.ui.ContactAddActivity")
            if not ContactAddActivity:
                return
            activity_class = ContactAddActivity.getClass()
            array_list_class = jclass("java.util.ArrayList")
            universal_adapter = self.plugin._get_class("org.telegram.ui.Components.UniversalAdapter")
            method = activity_class.getDeclaredMethod("fillItems", array_list_class, universal_adapter)
            method.setAccessible(True)
            self.fill_items_hook = self.plugin.hook_method(method, _ContactAddActivityFillItemsHook(), priority=0)
        except Exception:
            pass

    def teardown(self):
        if self.fill_items_hook:
            self.plugin.unhook_method(self.fill_items_hook)
            self.fill_items_hook = None
        if hasattr(self, "do_not_share_hook") and self.do_not_share_hook:
            self.do_not_share_hook.teardown()
            self.do_not_share_hook = None

    def on_plugin_unload(self):
        self.teardown()


class _ContactAddActivityFillItemsHook:
    def before_hooked_method(self, param):
        activity = param.thisObject
        try:
            activity_class = activity.getClass()
            check_share_field = activity_class.getDeclaredField("checkShare")
            check_share_field.setAccessible(True)
            if check_share_field.getBoolean(activity):
                first_set_field = activity_class.getDeclaredField("firstSet")
                first_set_field.setAccessible(True)
                if first_set_field.getBoolean(activity):
                    check_share_field.setBoolean(activity, False)
        except Exception:
            pass


class PreferCommonGroupsTabHook:
    def __init__(self, plugin):
        self.plugin = plugin

    def after_hooked_method(self, param):
        try:
            userInfo = param.args[0]
            sharedMediaLayout = param.thisObject
            
            if userInfo and hasattr(userInfo, 'common_chats_count') and userInfo.common_chats_count > 0:
                try:
                    scrollSlidingTextTabStrip = getattr(sharedMediaLayout, 'scrollSlidingTextTabStrip', None)
                    if scrollSlidingTextTabStrip:
                        currentTabId = scrollSlidingTextTabStrip.getCurrentTabId()
                        if currentTabId == 14:
                            sharedMediaLayout.scrollToPage(6)
                except Exception as e:
                    pass
        except Exception as e:
            pass


class SafeModeHook:
    def __init__(self, plugin):
        self.plugin = plugin
    
    def before_hooked_method(self, param):
        try:
            from android.view import KeyEvent
            from java.lang import System
            
            key_event = param.args[0]
            if not key_event:
                return
            
            key_code = key_event.getKeyCode()
            action = key_event.getAction()
            
            if key_code == KeyEvent.KEYCODE_VOLUME_DOWN:
                current_time = System.currentTimeMillis()
                
                if action == KeyEvent.ACTION_DOWN:
                    self.plugin.safe_mode_volume_down_press_time = current_time
                    self.plugin.safe_mode_is_holding = False
                elif action == KeyEvent.ACTION_UP:
                    press_duration = current_time - self.plugin.safe_mode_volume_down_press_time
                    
                    if press_duration > 500:
                        self.plugin.safe_mode_is_holding = True
                        self.plugin.safe_mode_volume_down_count = 0
                        return
                    
                    if (current_time - self.plugin.safe_mode_last_volume_down_time) > self.plugin.safe_mode_cooldown:
                        self.plugin.safe_mode_volume_down_count = 1
                        self.plugin.safe_mode_last_volume_down_time = current_time
                    elif (current_time - self.plugin.safe_mode_last_volume_down_time) <= self.plugin.safe_mode_multi_tap_window:
                        self.plugin.safe_mode_volume_down_count += 1
                        self.plugin.safe_mode_last_volume_down_time = current_time
                        if self.plugin.safe_mode_volume_down_count >= self.plugin.safe_mode_required_taps:
                            self.plugin.safe_mode_volume_down_count = 0
                            self.plugin._on_safe_mode_detected()
                            param.setResult(True)
                            return
                        
                        param.setResult(True)
        except Exception:
            pass


class ChatActionBarItemsHook:
    def __init__(self, plugin):
        self.plugin = plugin
    
    def after_hooked_method(self, param):
        try:
            chat_activity = param.thisObject
            activity_id = id(chat_activity)
            
            if activity_id not in self.plugin.chat_action_bar_hooked_activities:
                self.plugin.chat_action_bar_hooked_activities.add(activity_id)
                
                if self.plugin.get_setting("enable_goto_message", False):
                    self.add_goto_message_menu_item(chat_activity)
                
                if self.plugin.get_setting("enable_ai_summarize", False):
                    self.add_summarize_menu_item(chat_activity)
        except Exception as e:
            self.plugin.log(f"Error in Chat Action Bar Items Hook: {e}")
    
    def add_summarize_menu_item(self, chat_activity):
        try:
            AiController = self.plugin._get_class("com.exteragram.messenger.ai.AiController")
            if not AiController:
                return

            if hasattr(AiController, 'canUseAI') and not AiController.canUseAI():
                return
            
            headerItem = get_private_field(chat_activity, "headerItem")
            if headerItem is None:
                return
            
            R = self.plugin._get_class("org.telegram.messenger.R")
            if R is None:
                return
            
            try:
                ai_icon = R.drawable.ai_chat
                summarize_text = get_string("summarize_menu_item", "Summarize")
                
                lazy_list = get_private_field(headerItem, "lazyList")
                lazy_map = get_private_field(headerItem, "lazyMap")
                
                if lazy_list is not None:
                    admin_gap = get_private_field(chat_activity, "adminItemsGap")
                    insert_position = lazy_list.size()
                    
                    if admin_gap is not None and lazy_map is not None:
                        for i in range(lazy_list.size()):
                            item = lazy_list.get(i)
                            if item == admin_gap:
                                insert_position = i
                                break
                    
                    ActionBarMenuItem = jclass("org.telegram.ui.ActionBar.ActionBarMenuItem")
                    ItemClass = jclass("org.telegram.ui.ActionBar.ActionBarMenuItem$Item")
                    item_java_class = ItemClass.getClass()
                    
                    asSubItemMethod = item_java_class.getDeclaredMethod("asSubItem", 
                        jclass("java.lang.Integer").TYPE,
                        jclass("java.lang.Integer").TYPE, 
                        jclass("android.graphics.drawable.Drawable"),
                        jclass("java.lang.CharSequence"),
                        jclass("java.lang.Boolean").TYPE,
                        jclass("java.lang.Boolean").TYPE
                    )
                    asSubItemMethod.setAccessible(True)
                    
                    Integer = jclass("java.lang.Integer")
                    Boolean = jclass("java.lang.Boolean")
                    
                    our_item = asSubItemMethod.invoke(None, 
                        Integer(self.plugin.ai_summarize_menu_id),
                        Integer(ai_icon),
                        None,
                        summarize_text,
                        Boolean(True),
                        Boolean(False)
                    )
                    
                    lazy_list.add(insert_position, our_item)
                    
                    if lazy_map is not None:
                        lazy_map.put(self.plugin.ai_summarize_menu_id, our_item)
                else:
                    headerItem.lazilyAddSubItem(
                        self.plugin.ai_summarize_menu_id,
                        ai_icon,
                        summarize_text
                    )
                
                self.hook_action_bar_callback(chat_activity)
                
            except Exception as e:
                self.plugin.log(f"Error adding AI Summarize menu item: {e}")
                
        except Exception as e:
            self.plugin.log(f"Error in add_summarize_menu_item: {e}")
    
    def add_goto_message_menu_item(self, chat_activity):
        try:
            headerItem = get_private_field(chat_activity, "headerItem")
            if headerItem is None:
                return
            
            R = self.plugin._get_class("org.telegram.messenger.R")
            if R is None:
                return
            
            try:
                goto_icon = R.drawable.msg_to_beginning_solar
                goto_text = get_string("goto_message", "Go to Message")
                
                lazy_list = get_private_field(headerItem, "lazyList")
                lazy_map = get_private_field(headerItem, "lazyMap")
                
                if lazy_list is not None:
                    admin_gap = get_private_field(chat_activity, "adminItemsGap")
                    insert_position = lazy_list.size()
                    
                    if admin_gap is not None and lazy_map is not None:
                        for i in range(lazy_list.size()):
                            item = lazy_list.get(i)
                            if item == admin_gap:
                                insert_position = i
                                break
                    
                    ActionBarMenuItem = jclass("org.telegram.ui.ActionBar.ActionBarMenuItem")
                    ItemClass = jclass("org.telegram.ui.ActionBar.ActionBarMenuItem$Item")
                    item_java_class = ItemClass.getClass()
                    
                    asSubItemMethod = item_java_class.getDeclaredMethod("asSubItem", 
                        jclass("java.lang.Integer").TYPE,
                        jclass("java.lang.Integer").TYPE, 
                        jclass("android.graphics.drawable.Drawable"),
                        jclass("java.lang.CharSequence"),
                        jclass("java.lang.Boolean").TYPE,
                        jclass("java.lang.Boolean").TYPE
                    )
                    asSubItemMethod.setAccessible(True)
                    
                    Integer = jclass("java.lang.Integer")
                    Boolean = jclass("java.lang.Boolean")
                    
                    our_item = asSubItemMethod.invoke(None, 
                        Integer(self.plugin.goto_message_menu_id),
                        Integer(goto_icon),
                        None,
                        goto_text,
                        Boolean(True),
                        Boolean(False)
                    )
                    
                    lazy_list.add(insert_position, our_item)
                    
                    if lazy_map is not None:
                        lazy_map.put(self.plugin.goto_message_menu_id, our_item)
                else:
                    headerItem.lazilyAddSubItem(
                        self.plugin.goto_message_menu_id,
                        goto_icon,
                        goto_text
                    )
                
                self.hook_action_bar_callback(chat_activity)
                
            except Exception as e:
                self.plugin.log(f"Error adding Goto Message menu item: {e}")
                
        except Exception as e:
            self.plugin.log(f"Error in add_goto_message_menu_item: {e}")
    
    def hook_action_bar_callback(self, chat_activity):
        try:
            action_bar = get_private_field(chat_activity, "actionBar")
            if action_bar is None:
                return
            
            current_callback = get_private_field(action_bar, "actionBarMenuOnItemClick")
            if current_callback is None:
                return
            
            callback_class = current_callback.getClass()
            jint = jclass("java.lang.Integer").TYPE
            
            onItemClickMethod = callback_class.getDeclaredMethod("onItemClick", jint)
            onItemClickMethod.setAccessible(True)
            
            hook_handler = ChatActionBarMenuItemClickHook(self.plugin, chat_activity)
            
            if self.plugin.hook_ai_summarize_item_click_ref:
                self.plugin.unhook_method(self.plugin.hook_ai_summarize_item_click_ref)
            
            self.plugin.hook_ai_summarize_item_click_ref = self.plugin.hook_method(
                onItemClickMethod,
                hook_handler
            )
            
        except Exception as e:
            self.plugin.log(f"Error hooking AI Summarize action bar callback: {e}")


class ChatActionBarMenuItemClickHook:
    def __init__(self, plugin, chat_activity):
        self.plugin = plugin
        self.chat_activity = chat_activity
    
    def get_unread_count(self, chat_activity):
        try:
            mc = get_messages_controller()
            dialog = mc.getDialog(chat_activity.getDialogId()) if mc else None
            if dialog:
                unread_count = getattr(dialog, 'unread_count', 0) or 0
                return unread_count if unread_count > 0 else 200
        except Exception:
            pass
        return 200
    
    def before_hooked_method(self, param):
        try:
            item_id = int(param.args[0])
            
            if item_id == self.plugin.ai_summarize_menu_id:
                self.open_summarize_view(self.chat_activity)
                param.setResult(None)
            elif item_id == self.plugin.goto_message_menu_id:
                self.plugin.show_goto_message_dialog(self.chat_activity)
                param.setResult(None)
                
        except Exception as e:
            self.plugin.log(f"Error in Chat Action Bar Menu Item Click Hook: {e}")
    
    def open_summarize_view(self, chat_activity):
        GenerateFromMessageBottomSheet = self.plugin._get_class("com.exteragram.messenger.ai.ui.GenerateFromMessageBottomSheet")
        if not GenerateFromMessageBottomSheet:
            return
        
        LocaleController = self.plugin._get_class("org.telegram.messenger.LocaleController")
        R = self.plugin._get_class("org.telegram.messenger.R")
        
        if LocaleController and R:
            getStringMethod = LocaleController.getClass().getDeclaredMethod("getString", jclass("java.lang.Integer").TYPE)
            
            class LocaleHook:
                def __init__(self):
                    self.role_prompt_id = R.string.RolePrompt
                    self.proceed_id = R.string.Proceed
                    self.generate_id = R.string.Generate
                
                def after_hooked_method(self, param):
                    string_id = param.args[0]
                    if string_id == self.role_prompt_id:
                        param.setResult(get_string("message_count_label", "Message Count"))
                    elif string_id == self.proceed_id:
                        param.setResult(get_string("summarize_button", "Summarize"))
                    elif string_id == self.generate_id:
                        param.setResult(get_string("summarize_title", "Summarize"))
            
            unhook_locale = self.plugin.hook_method(getStringMethod, LocaleHook())
        
        Callback = jclass("org.telegram.messenger.Utilities$Callback")
        
        class DataCallback(dynamic_proxy(Callback)):
            def __init__(self, plugin_ref, activity_ref):
                super().__init__()
                self.plugin = plugin_ref
                self.activity = activity_ref
            
            def run(self, data):
                default_count = ChatActionBarMenuItemClickHook(self.plugin, self.activity).get_unread_count(self.activity)
                count = int(str(data.prompt() or str(default_count)).strip())
                count = max(1, count)
                self.fetch_and_summarize(self.activity, count)
            
            def fetch_and_summarize(self, chat_activity, count):
                loading = AlertDialogBuilder(chat_activity.getParentActivity(), AlertDialogBuilder.ALERT_TYPE_SPINNER)
                loading.show()
                loading.set_cancelable(False)
                
                
                def process():
                    try:
                        messages = ChatActionBarMenuItemClickHook.get_messages(chat_activity, count, self.plugin)
                        run_on_ui_thread(loading.dismiss)
                        
                        if messages:
                            run_on_ui_thread(lambda: ChatActionBarMenuItemClickHook(self.plugin, chat_activity).show_alert(chat_activity, messages))
                        else:
                            run_on_ui_thread(lambda: BulletinHelper.of(chat_activity).createErrorBulletin("No messages to summarize").show())
                    except Exception as e:
                        self.plugin.log(f"Error fetching messages for summarization: {e}")
                        run_on_ui_thread(loading.dismiss)
                
                run_on_queue(process)
        
        callback = DataCallback(self.plugin, chat_activity)
        
        unread_count = self.get_unread_count(chat_activity)
        
        sheet = GenerateFromMessageBottomSheet(
            str(unread_count),
            None,
            chat_activity,
            chat_activity.getContext(),
            callback,
            False
        )
        sheet.show()
        
        if 'unhook_locale' in locals():
            self.plugin.unhook_method(unhook_locale)
    
    def show_alert(self, chat_activity, messages):
        try:
            AiConfig = self.plugin._get_class("com.exteragram.messenger.ai.AiConfig")
            if AiConfig:
                AiConfig.showResponseOnly = True
            
            context = self.build_message_context(messages)
            full_prompt = context
            
            AiController = self.plugin._get_class("com.exteragram.messenger.ai.AiController")
            controller = AiController.getInstance()
            
            summarizer_role = None
            roles_list = controller.getRoles()
            if roles_list:
                for i in range(roles_list.size()):
                    role = roles_list.get(i)
                    if role and role.getName() == "Quanta!":
                        summarizer_role = role
                        break
            
            client_builder = self.plugin._get_class("com.exteragram.messenger.ai.network.Client").Builder()
            if summarizer_role:
                client_builder.roleOverride(summarizer_role)
            client = client_builder.build()
            
            if not client:
                return
            
            current_chat = get_private_field(chat_activity, "currentChat")
            no_forwards = self.plugin._get_class("org.telegram.messenger.MessagesController").getInstance(0).isChatNoForwards(current_chat) if current_chat else False
            
            setText = jclass("android.widget.TextView").getClass().getDeclaredMethod("setText", jclass("java.lang.CharSequence"))
            
            class TextViewHook:
                def __init__(self, full_text, display_text):
                    self.full_text = full_text
                    self.display_text = display_text
                    self.hooked = False
                
                def before_hooked_method(self, param):
                    if not self.hooked:
                        text = str(param.args[0]) if param.args[0] else ""
                        if self.full_text in text:
                            param.args[0] = self.display_text
                            self.hooked = True
            
            unhook = self.plugin.hook_method(setText, TextViewHook(full_prompt, get_string("ai_summarizing", "Summarizing...")))
            
            Callback2 = jclass("org.telegram.messenger.Utilities$Callback2")
            class InsertCallback(dynamic_proxy(Callback2)):
                def run(self, prompt, response):
                    chatActivityEnterView = get_private_field(chat_activity, "chatActivityEnterView")
                    if chatActivityEnterView:
                        AiConfig = find_class("com.exteragram.messenger.ai.AiConfig")
                        if AiConfig and AiConfig.insertAsQuote:
                            editField = chatActivityEnterView.getEditField()
                            editField.setText(str(response) + "\n")
                            QuoteSpan = find_class("org.telegram.ui.Components.QuoteSpan")
                            if QuoteSpan:
                                QuoteSpan.putQuoteToEditable(chatActivityEnterView.getEditText(), 0, len(str(response)), True)
                        else:
                            chatActivityEnterView.getEditField().setText(str(response))
                        chatActivityEnterView.getEditField().setSelection(chatActivityEnterView.getEditText().length())
                        chatActivityEnterView.openKeyboard()
            
            find_class("com.exteragram.messenger.ai.ui.ResponseAlert").showAlert(
                chat_activity,
                client,
                full_prompt,
                True,
                no_forwards,
                None,
                None,
                InsertCallback()
            )
            
            if unhook:
                self.plugin.unhook_method(unhook)
            
        except Exception as e:
            self.plugin.log(f"Error opening AI Summarize view: {e}")
            import traceback
            self.plugin.log(f"Traceback: {traceback.format_exc()}")
    
    @staticmethod
    def get_messages(chat_activity, count, plugin):
        try:
            from client_utils import get_messages_controller, send_request, RequestCallback
            from org.telegram.tgnet import TLRPC
            import time
            
            dialog_id = get_private_field(chat_activity, "dialog_id")
            if dialog_id is None:
                return []
            
            result_container = {'messages': [], 'done': False, 'offset_id': 0}
            
            def fetch_batch():
                remaining = count - len(result_container['messages'])
                if remaining <= 0:
                    result_container['done'] = True
                    return
                
                batch_size = min(100, remaining)
                
                req = TLRPC.TL_messages_getHistory()
                req.peer = get_messages_controller().getInputPeer(dialog_id)
                req.offset_id = result_container['offset_id']
                req.limit = batch_size
                req.add_offset = 0
                req.max_id = 0
                req.min_id = 0
                req.hash = 0
                
                def handle_response(response, error):
                    if error or not response or not hasattr(response, 'messages'):
                        result_container['done'] = True
                        return
                    
                    messages_count = response.messages.size()
                    if messages_count == 0:
                        result_container['done'] = True
                        return
                    
                    last_id = result_container['offset_id']
                    for i in range(messages_count):
                        msg = response.messages.get(i)
                        if msg and hasattr(msg, 'message') and msg.message:
                            result_container['messages'].append(msg)
                            if hasattr(msg, 'id'):
                                last_id = msg.id
                    
                    result_container['offset_id'] = last_id
                    
                    if len(result_container['messages']) >= count or messages_count < batch_size:
                        result_container['done'] = True
                    else:
                        fetch_batch()
                
                callback = RequestCallback(handle_response)
                send_request(req, callback)
            
            fetch_batch()
            
            timeout = 30
            start_time = time.time()
            while not result_container['done'] and (time.time() - start_time) < timeout:
                time.sleep(0.1)
            
            messages = result_container['messages'][:count]
            messages.reverse()
            return messages
            
        except Exception as e:
            plugin.log(f"Error getting messages for summarization: {e}")
            return []
    
    def build_message_context(self, messages):
        try:
            from client_utils import get_messages_controller
            mc = get_messages_controller()
            parts = []
            
            for msg in messages:
                if not (hasattr(msg, 'message') and msg.message):
                    continue
                
                text = str(msg.message).strip()
                if not text:
                    continue
                
                sender = "User"
                
                if hasattr(msg, 'post_author') and msg.post_author:
                    if hasattr(msg, 'peer_id') and msg.peer_id and hasattr(msg.peer_id, 'channel_id'):
                        if hasattr(msg, 'from_id') and msg.from_id and hasattr(msg.from_id, 'channel_id'):
                            if msg.peer_id.channel_id == msg.from_id.channel_id:
                                sender = str(msg.post_author).strip()
                                chat = mc.getChat(msg.peer_id.channel_id)
                                if chat and hasattr(chat, 'title'):
                                    sender = f"{chat.title} ({sender})"
                        else:
                            sender = str(msg.post_author).strip()
                elif hasattr(msg, 'from_id') and msg.from_id:
                    fid = msg.from_id
                    if hasattr(fid, 'user_id'):
                        user = mc.getUser(fid.user_id)
                        if user:
                            name = f"{user.first_name or ''} {user.last_name or ''}".strip()
                            sender = name or "User"
                    elif hasattr(fid, 'channel_id'):
                        chat = mc.getChat(fid.channel_id)
                        if chat and hasattr(chat, 'title'):
                            sender = str(chat.title)
                
                parts.append(f"{sender}: {text}")
            
            return "\n".join(parts)
        except Exception as e:
            self.plugin.log(f"Error building AI Summarize context: {e}")
            return ""


RIGHT_DURATION = 20

def show_duration_selector_sheet(context, on_duration_selected, plugin=None):
    if plugin:
        BottomSheet = plugin._get_class("org.telegram.ui.ActionBar.BottomSheet")
        LinearLayout = plugin._get_class("android.widget.LinearLayout")
        HeaderCell = plugin._get_class("org.telegram.ui.Cells.HeaderCell")
        Theme = plugin._get_class("org.telegram.ui.ActionBar.Theme")
        LayoutHelper = plugin._get_class("org.telegram.ui.Components.LayoutHelper")
        LocaleController = plugin._get_class("org.telegram.messenger.LocaleController")
        R_string = plugin._get_class("org.telegram.messenger.R$string")
        ConnectionsManager = plugin._get_class("org.telegram.tgnet.ConnectionsManager")
        AlertsCreator = plugin._get_class("org.telegram.ui.Components.AlertsCreator")
        UserConfig = plugin._get_class("org.telegram.messenger.UserConfig")
        AndroidUtilities = plugin._get_class("org.telegram.messenger.AndroidUtilities")
    else:
        BottomSheet = find_class("org.telegram.ui.ActionBar.BottomSheet")
        LinearLayout = find_class("android.widget.LinearLayout")
        HeaderCell = find_class("org.telegram.ui.Cells.HeaderCell")
        Theme = find_class("org.telegram.ui.ActionBar.Theme")
        LayoutHelper = find_class("org.telegram.ui.Components.LayoutHelper")
        LocaleController = find_class("org.telegram.messenger.LocaleController")
        R_string = find_class("org.telegram.messenger.R$string")
        ConnectionsManager = find_class("org.telegram.tgnet.ConnectionsManager")
        AlertsCreator = find_class("org.telegram.ui.Components.AlertsCreator")
        UserConfig = find_class("org.telegram.messenger.UserConfig")
        AndroidUtilities = find_class("org.telegram.messenger.AndroidUtilities")
    
    builder = BottomSheet.Builder(context)
    builder.setApplyTopPadding(False)
    
    linear_layout = LinearLayout(context)
    linear_layout.setOrientation(LinearLayout.VERTICAL)
    
    header_cell = HeaderCell(context, Theme.key_dialogTextBlue2, 23, 15, False)
    header_cell.setHeight(47)
    header_cell.setText(LocaleController.getString("UserRestrictionsDuration", R_string.UserRestrictionsDuration))
    linear_layout.addView(header_cell)
    
    buttons_container = LinearLayout(context)
    buttons_container.setOrientation(LinearLayout.VERTICAL)
    linear_layout.addView(buttons_container, LayoutHelper.createLinear(-1, -2))
    durations = [
        (LocaleController.getString("UserRestrictionsUntilForever", R_string.UserRestrictionsUntilForever), 0),
        (LocaleController.formatPluralString("Days", 1), 86400),
        (LocaleController.formatPluralString("Weeks", 1), 604800),
        (LocaleController.formatPluralString("Months", 1), 2592000),
        (LocaleController.getString("UserRestrictionsCustom", R_string.UserRestrictionsCustom), -1)
    ]
    
    current_account = UserConfig.selectedAccount
    
    for idx, (label, duration_seconds) in enumerate(durations):
        cell = BottomSheet.BottomSheetCell(context, 0)
        cell.setPadding(AndroidUtilities.dp(7), 0, AndroidUtilities.dp(7), 0)
        cell.setTag(idx)
        cell.setBackgroundDrawable(Theme.getSelectorDrawable(False))
        cell.setTextAndIcon(label, 0)
        buttons_container.addView(cell, LayoutHelper.createLinear(-1, -2))
        
        def create_click_listener(duration, is_custom):
            def on_click(view=None):
                if is_custom:
                    current_time = ConnectionsManager.getInstance(current_account).getCurrentTime()
                    
                    ScheduleDatePickerDelegate = plugin._get_class("org.telegram.ui.Components.AlertsCreator$ScheduleDatePickerDelegate") if plugin else find_class("org.telegram.ui.Components.AlertsCreator$ScheduleDatePickerDelegate")
                    DateDelegateProxy = dynamic_proxy(ScheduleDatePickerDelegate)
                    
                    class DateDelegate(DateDelegateProxy):
                        def __init__(self):
                            super().__init__()
                        
                        def didSelectDate(self, notify, schedule_date):
                            on_duration_selected(schedule_date)
                    
                    date_builder = AlertsCreator.createDatePickerDialog(
                        context,
                        LocaleController.getString("UserRestrictionsDuration", R_string.UserRestrictionsDuration),
                        LocaleController.getString("Set", R_string.Set),
                        current_time,
                        DateDelegate()
                    )
                    if date_builder:
                        date_builder.show()
                else:
                    if duration == 0:
                        on_duration_selected(0)
                    else:
                        current_time = ConnectionsManager.getInstance(current_account).getCurrentTime()
                        on_duration_selected(current_time + duration)
                builder.getDismissRunnable().run()
            return on_click
        
        cell.setOnClickListener(OnClickListener(create_click_listener(duration_seconds, duration_seconds == -1)))
    
    builder.setCustomView(linear_layout)
    sheet = builder.create()
    sheet.show()

class DeleteWithDurationFillItemsHook:
    def __init__(self, plugin):
        self.plugin = plugin
    
    def after_hooked_method(self, param):
        try:
            sheet_instance = param.thisObject
            items = param.args[0]
            banOrRestrict = get_private_field(sheet_instance, 'banOrRestrict')
            restrict = get_private_field(sheet_instance, 'restrict')
            bannedRights = get_private_field(sheet_instance, 'bannedRights')
            
            if banOrRestrict and bannedRights:
                checks = get_private_field(banOrRestrict, 'checks')
                if checks and (checks[0] or restrict):
                    UItem = self.plugin._get_class("org.telegram.ui.Components.UItem")
                    LocaleController = self.plugin._get_class("org.telegram.messenger.LocaleController")
                    R_string = self.plugin._get_class("org.telegram.messenger.R$string")
                    
                    if bannedRights.until_date == 0 or abs(bannedRights.until_date - int(time.time())) > 10 * 365 * 24 * 60 * 60:
                        value = LocaleController.getString("UserRestrictionsUntilForever", R_string.UserRestrictionsUntilForever)
                    else:
                        value = LocaleController.formatDateForBan(bannedRights.until_date)
                    
                    duration_item = UItem.asButton(
                        RIGHT_DURATION,
                        LocaleController.getString("UserRestrictionsDuration", R_string.UserRestrictionsDuration),
                        value
                    )
                    items.add(duration_item)
                    
        except Exception as e:
            self.plugin.log(f"Error adding duration item: {e}")

class DeleteWithDurationOnClickHook:
    def __init__(self, plugin):
        self.plugin = plugin
    
    def before_hooked_method(self, param):
        try:
            sheet_instance = param.thisObject
            item = param.args[0]
            
            if item.id == RIGHT_DURATION:
                context = sheet_instance.getContext()
                
                bannedRights = get_private_field(sheet_instance, 'bannedRights')
                adapter = get_private_field(sheet_instance, 'adapter')
                
                def on_duration_selected(duration):
                    if bannedRights:
                        bannedRights.until_date = duration
                        if adapter:
                            adapter.update(True)
                
                show_duration_selector_sheet(context, on_duration_selected, self.plugin)
                param.setResult(None)
                return
                
        except Exception as e:
            self.plugin.log(f"Error handling duration click: {e}")


class SleepTimerConstructorHook(MethodHook):
    def __init__(self, plugin):
        super().__init__()
        self.plugin = plugin
    
    def after_hooked_method(self, param):
        try:
            alert = param.thisObject
            options_button = get_private_field(alert, "optionsButton")
            if not options_button:
                return
            
            options_button.addSubItem(1390, R_tg.drawable.menu_premium_clock, get_string("sleep_timer_menu", "Sleep Timer"))
        except Exception as e:
            pass


class SleepTimerClickHook(MethodHook):
    def __init__(self, plugin):
        super().__init__()
        self.plugin = plugin
    
    def before_hooked_method(self, param):
        try:
            item_id = param.args[0]
            if item_id != 1390:
                return
            
            alert = param.thisObject
            self._show_sleep_timer_dialog(alert)
        except Exception as e:
            pass
    
    def _show_sleep_timer_dialog(self, alert):
        try:
            preset_labels = [
                get_string("sleep_timer_disable", "Disable"),
                LocaleController.formatPluralString("Minutes", 1),
                LocaleController.formatPluralString("Minutes", 5),
                LocaleController.formatPluralString("Minutes", 10),
                LocaleController.formatPluralString("Minutes", 20),
                LocaleController.formatPluralString("Minutes", 40),
                LocaleController.formatPluralString("Hours", 1),
                LocaleController.getString(R_tg.string.AutoDownloadCustom)
            ]
            
            preset_values = [0, 1, 5, 10, 20, 40, 60]
            hook_instance = self
            
            def on_preset_click(builder, which):
                if which < len(preset_values):
                    minutes = preset_values[which]
                    hook_instance._set_sleep_timer(alert, minutes * 60)
                else:
                    Callback = jclass("org.telegram.messenger.Utilities$Callback")
                    CallbackProxy = dynamic_proxy(Callback)
                    
                    class TimePickerCallback(CallbackProxy):
                        def run(self, picked_minutes):
                            hook_instance._set_sleep_timer(alert, picked_minutes * 60)
                    
                    from org.telegram.ui.Components import AlertsCreator
                    AlertsCreator.createTimePickerDialog(
                        alert.getContext(),
                        get_string("sleep_timer_custom", "Sleep Timer"),
                        0,
                        0,
                        12 * 60,
                        TimePickerCallback()
                    )
            
            resources_provider = get_private_field(alert, "resourcesProvider")
            builder = AlertDialogBuilder(alert.getContext(), resources_provider=resources_provider)
            builder.set_title(get_string("sleep_timer_title", "Sleep Timer"))
            builder.set_items(preset_labels, on_preset_click)
            builder.set_negative_button(LocaleController.getString(R_tg.string.Cancel))
            builder.show()
        except:
            pass
    
    def _set_sleep_timer(self, alert, seconds):
        try:
            self.plugin.log(f"Setting sleep timer to {seconds} seconds")
            if not hasattr(self.plugin, '_sleep_handler') or self.plugin._sleep_handler is None:
                self.plugin._sleep_handler = Handler(Looper.getMainLooper())
            if hasattr(self.plugin, '_sleep_runnable') and self.plugin._sleep_runnable is not None:
                self.plugin._sleep_handler.removeCallbacks(self.plugin._sleep_runnable)
            
            if seconds > 0:
                def pause_music():
                    from org.telegram.messenger import MediaController
                    media_controller = MediaController.getInstance()
                    if not media_controller.isMessagePaused():
                        media_controller.pauseMessage(media_controller.getPlayingMessageObject())
                    self.plugin.sleep_timer_active = False
                
                from android_utils import R as Runnable
                self.plugin._sleep_runnable = Runnable(pause_music)
                self.plugin._sleep_handler.postDelayed(self.plugin._sleep_runnable, seconds * 1000)
                
                self.plugin.sleep_timer_active = True
                if seconds < 3600:
                    minutes = seconds // 60
                    formatted_time = LocaleController.formatPluralString("Minutes", minutes)
                else:
                    hours = seconds // 3600
                    formatted_time = LocaleController.formatPluralString("Hours", hours)
                
                from org.telegram.ui.Components import BulletinFactory
                container_view = get_private_field(alert, "containerView")
                resources_provider = get_private_field(alert, "resourcesProvider")
                if container_view and isinstance(container_view, FrameLayout):
                    message = get_string("sleep_timer_set", "Sleep timer is set to {time}").format(time=formatted_time)
                    BulletinFactory.of(container_view, resources_provider).createSimpleBulletin(
                        R_tg.raw.done,
                        AndroidUtilities.replaceTags(message)
                    ).show()
            else:
                if self.plugin.sleep_timer_active:
                    from org.telegram.ui.Components import BulletinFactory
                    container_view = get_private_field(alert, "containerView")
                    resources_provider = get_private_field(alert, "resourcesProvider")
                    if container_view and isinstance(container_view, FrameLayout):
                        BulletinFactory.of(container_view, resources_provider).createSimpleBulletin(
                            R_tg.raw.done,
                            get_string("sleep_timer_disabled", "Sleep timer is disabled")
                        ).show()
                self.plugin.sleep_timer_active = False
        except Exception as e:
            self.plugin.log(f"Error in sleep timer: {e}")


class AdaptiveAudioHook:
    def __init__(self, plugin):
        self.plugin = plugin
    
    def after_hooked_method(self, param):
        try:
            cell = param.thisObject
            
            documentAttachTypeField = cell.getClass().getDeclaredField("documentAttachType")
            documentAttachTypeField.setAccessible(True)
            documentAttachType = documentAttachTypeField.getInt(cell)
            
            if documentAttachType != 3:
                return
            
            currentMessageObjectField = cell.getClass().getDeclaredField("currentMessageObject")
            currentMessageObjectField.setAccessible(True)
            messageObject = currentMessageObjectField.get(cell)
            
            if messageObject is None:
                return
            
            documentAttachField = cell.getClass().getDeclaredField("documentAttach")
            documentAttachField.setAccessible(True)
            documentAttach = documentAttachField.get(cell)
            
            if documentAttach is None:
                return
            
            duration = 0
            attributes = documentAttach.attributes
            for i in range(attributes.size()):
                attr = attributes.get(i)
                attr_class_name = attr.getClass().getName()
                if "TL_documentAttributeAudio" in attr_class_name:
                    duration = attr.duration
                    break
            
            if duration <= 0:
                return
            
            backgroundWidthField = cell.getClass().getDeclaredField("backgroundWidth")
            backgroundWidthField.setAccessible(True)
            currentBackgroundWidth = backgroundWidthField.getInt(cell)
            
            extra = 0
            if duration >= 180:
                extra = AndroidUtilities.dp(120)
            elif duration >= 120:
                extra = AndroidUtilities.dp(80)
            elif duration >= 60:
                extra = AndroidUtilities.dp(40)
            
            if extra > 0:
                from java.lang import Class
                AndroidUtilitiesClass = Class.forName("org.telegram.messenger.AndroidUtilities")
                displaySizeField = AndroidUtilitiesClass.getDeclaredField("displaySize")
                displaySizeField.setAccessible(True)
                displaySize = displaySizeField.get(None)
                
                screenLimit = displaySize.x - AndroidUtilities.dp(75)
                
                newBackgroundWidth = min(currentBackgroundWidth + extra, screenLimit)
                backgroundWidthField.setInt(cell, newBackgroundWidth)
        except:
            pass


class MusicSpeedControlHook:
    def __init__(self, plugin):
        self.plugin = plugin
        self._is_music_field = None
        self._playback_button_field = None
        self._title_text_view_field = None
        self._subtitle_text_view_field = None
    
    def after_hooked_method(self, param):
        try:
            instance = param.thisObject
            if self._is_music_field is None or self._playback_button_field is None:
                c = instance.getClass()
                self._is_music_field = c.getDeclaredField("isMusic")
                self._is_music_field.setAccessible(True)
                self._playback_button_field = c.getDeclaredField("playbackSpeedButton")
                self._playback_button_field.setAccessible(True)
                try:
                    self._title_text_view_field = c.getDeclaredField("titleTextView")
                    self._title_text_view_field.setAccessible(True)
                except Exception:
                    pass
                try:
                    self._subtitle_text_view_field = c.getDeclaredField("subtitleTextView")
                    self._subtitle_text_view_field.setAccessible(True)
                except Exception:
                    pass
            is_music = self._is_music_field.getBoolean(instance)
            btn = self._playback_button_field.get(instance)
            if is_music and btn is not None:
                btn.setVisibility(0)
                btn.setAlpha(1.0)
                btn.setEnabled(True)
                speed_btn_width = AndroidUtilities.dp(36)
                try:
                    if self._title_text_view_field is not None:
                        title_view = self._title_text_view_field.get(instance)
                        if title_view is not None:
                            current_right = title_view.getPaddingRight()
                            if current_right < speed_btn_width:
                                title_view.setPadding(
                                    title_view.getPaddingLeft(),
                                    title_view.getPaddingTop(),
                                    current_right + speed_btn_width,
                                    title_view.getPaddingBottom()
                                )
                except Exception:
                    pass
                try:
                    if self._subtitle_text_view_field is not None:
                        subtitle_view = self._subtitle_text_view_field.get(instance)
                        if subtitle_view is not None:
                            current_right = subtitle_view.getPaddingRight()
                            if current_right < speed_btn_width:
                                subtitle_view.setPadding(
                                    subtitle_view.getPaddingLeft(),
                                    subtitle_view.getPaddingTop(),
                                    current_right + speed_btn_width,
                                    subtitle_view.getPaddingBottom()
                                )
                except Exception:
                    pass
                try:
                    methods = instance.getClass().getDeclaredMethods()
                    target = None
                    for m in methods:
                        if m.getName() == "updatePlaybackButton" and len(m.getParameterTypes()) == 1:
                            target = m
                            break
                    if target is not None:
                        target.setAccessible(True)
                        target.invoke(instance, False)
                except Exception:
                    pass
        except Exception as e:
            pass


class SendCommentsAfterForwardHook:
    def __init__(self, plugin):
        self.plugin = plugin
    
    def before_hooked_method(self, param):
        return None


class CheckSendButtonHook:
    def __init__(self, plugin):
        self.plugin = plugin

    def after_hooked_method(self, param):
        try:
            enter_view = param.thisObject
            enter_view.updateScheduleButton(True)
        except Exception:
            pass


class AlwaysVisibleScheduleButtonHook:
    def __init__(self, plugin):
        self.plugin = plugin
    
    def replace_hooked_method(self, param):
        try:
            enter_view = param.thisObject
            animated = param.args[0]
            
            schedule_button_hidden = get_private_field(enter_view, "scheduleButtonHidden")
            recording_audio_video = get_private_field(enter_view, "recordingAudioVideo")
            is_in_schedule_mode = enter_view.isInScheduleMode()
            
            has_text = enter_view.hasText()
            
            visible = (not schedule_button_hidden) and (not recording_audio_video) and (not has_text) and (not is_in_schedule_mode)
            scheduled_button = get_private_field(enter_view, "scheduledButton")
            
            if visible and not scheduled_button:
                try:
                    ChatActivityEnterViewClass = find_class("org.telegram.ui.Components.ChatActivityEnterView")
                    create_method = ChatActivityEnterViewClass.getClass().getDeclaredMethod("createScheduledButton")
                    create_method.setAccessible(True)
                    create_method.invoke(enter_view)
                    scheduled_button = get_private_field(enter_view, "scheduledButton")
                    self._update_schedule_button_icon(scheduled_button, enter_view)
                except Exception:
                    pass
            
            if scheduled_button:
                if visible:
                    scheduled_button.setVisibility(0)
                    scheduled_button.setAlpha(1.0)
                    scheduled_button.setScaleX(1.0)
                    scheduled_button.setScaleY(1.0)
                    scheduled_button.setTag(1)
                else:
                    scheduled_button.setVisibility(8)
                    
        except Exception:
            pass
        
        return None
    
    def _update_schedule_button_icon(self, scheduled_button, enter_view):
        try:
            if not scheduled_button:
                return
            
            Theme = find_class("org.telegram.ui.ActionBar.Theme")
            R_tg = find_class("org.telegram.messenger.R")
            PorterDuff = find_class("android.graphics.PorterDuff")
            PorterDuffColorFilter = find_class("android.graphics.PorterDuffColorFilter")
            
            context = scheduled_button.getContext()
            
            key_color = getattr(Theme, 'key_chat_messagePanelIcons')
            color = Theme.getColor(key_color)
            
            drawable = context.getResources().getDrawable(R_tg.drawable.msg_calendar2).mutate()
            drawable.setColorFilter(PorterDuffColorFilter(color, PorterDuff.Mode.MULTIPLY))
            scheduled_button.setImageDrawable(drawable)
        except Exception:
            pass


class DisableEmojiSuggestionsHook:
    def before_hooked_method(self, param):
        param.setResult(None)


class DisableFireUpdateHook:
    def before_hooked_method(self, param):
        param.setResult(None)


class ReplyInAnotherChatLayoutHook:
    def __init__(self, plugin_instance):
        self.plugin = plugin_instance
    
    def after_hooked_method(self, param):
        try:
            layout = param.thisObject
            self.plugin._setup_reply_button(layout)
        except Exception as e:
            pass


class ReplyInAnotherChatDialogsHook:
    def __init__(self):
        self.saved_reply_object = None
        self.is_plugin_action = False

    def before_hooked_method(self, param):
        try:
            fragment = param.args[0]
            if fragment is None:
                return
            args = fragment.getArguments()
            if args is None or not args.getBoolean("reply_in_another_chat_plugin", False):
                self.is_plugin_action = False
                return
            self.is_plugin_action = True
            chat_activity = param.thisObject
            try:
                f_replyingMessageObject = chat_activity.getClass().getDeclaredField("replyingMessageObject")
                f_replyingMessageObject.setAccessible(True)
                self.saved_reply_object = f_replyingMessageObject.get(chat_activity)
            except Exception as e:
                self.saved_reply_object = None
            selected_message_object = None
            try:
                f_selectedMessagesIds = chat_activity.getClass().getDeclaredField("selectedMessagesIds")
                f_selectedMessagesIds.setAccessible(True)
                selectedMessagesIds = f_selectedMessagesIds.get(chat_activity)
                sparse_array = selectedMessagesIds[0]
                if sparse_array.size() > 0:
                    selected_message_object = sparse_array.get(sparse_array.keyAt(0))
            except Exception as e:
                pass
            if selected_message_object:
                try:
                    f_replyingMessageObject.set(chat_activity, selected_message_object)
                except Exception as e:
                    pass
        except Exception as e:
            pass

    def after_hooked_method(self, param):
        if not self.is_plugin_action:
            return
        try:
            chat_activity = param.thisObject
            try:
                f_replyingMessageObject = chat_activity.getClass().getDeclaredField("replyingMessageObject")
                f_replyingMessageObject.setAccessible(True)
                f_replyingMessageObject.set(chat_activity, self.saved_reply_object)
            except Exception as e:
                pass
            self.saved_reply_object = None
            self.is_plugin_action = False
        except Exception as e:
            pass


class AllowReplyButtonHook:
    def __init__(self, plugin_instance):
        self.plugin = plugin_instance
    
    def after_hooked_method(self, param):
        try:
            chat_activity = param.thisObject
            
            try:
                f_currentChat = chat_activity.getClass().getDeclaredField("currentChat")
                f_currentChat.setAccessible(True)
                current_chat = f_currentChat.get(chat_activity)
                
                f_selectedMessagesIds = chat_activity.getClass().getDeclaredField("selectedMessagesIds")
                f_selectedMessagesIds.setAccessible(True)
                selectedMessagesIds = f_selectedMessagesIds.get(chat_activity)
                selected_count = selectedMessagesIds[0].size() + selectedMessagesIds[1].size()
                
                ChatObject = find_class("org.telegram.tgnet.TLRPC$Chat")
                is_channel = current_chat is not None and self._is_channel(current_chat)
                can_post = current_chat is not None and self._can_post(current_chat)
                is_megagroup = current_chat is not None and self._is_megagroup(current_chat)
                is_forum = current_chat is not None and self._is_forum(current_chat)
                
                should_use_plugin = is_channel and not can_post and not is_megagroup and not is_forum and selected_count <= 1
                
                f_actionsButtonsLayout = chat_activity.getClass().getDeclaredField("actionsButtonsLayout")
                f_actionsButtonsLayout.setAccessible(True)
                actions_layout = f_actionsButtonsLayout.get(chat_activity)
                
                if actions_layout is not None and should_use_plugin:
                    show_reply_method = actions_layout.getClass().getDeclaredMethod("showReplyButton", jclass("java.lang.Boolean").TYPE, jclass("java.lang.Boolean").TYPE)
                    show_reply_method.setAccessible(True)
                    show_reply_method.invoke(actions_layout, True, True)
                    
                    try:
                        f_replyButton = actions_layout.getClass().getDeclaredField("replyButton")
                        f_replyButton.setAccessible(True)
                        button_holder = f_replyButton.get(actions_layout)
                        
                        if button_holder is not None:
                            f_button = button_holder.getClass().getDeclaredField("button")
                            f_button.setAccessible(True)
                            reply_button_view = f_button.get(button_holder)
                            
                            if reply_button_view is not None:
                                listener = self._create_click_listener(chat_activity)
                                reply_button_view.setOnClickListener(listener)
                                reply_button_view.setOnLongClickListener(None)
                    except Exception as e:
                        pass
            except Exception as e:
                pass
        except Exception as e:
            pass
    
    def _is_channel(self, chat):
        try:
            class_name = chat.getClass().getSimpleName()
            return "channel" in class_name.lower()
        except Exception as e:
            return False
    
    def _can_post(self, chat):
        try:
            ChatObject = self.plugin._get_class("org.telegram.messenger.ChatObject")
            Chat = self.plugin._get_class("org.telegram.tgnet.TLRPC$Chat")
            canPost_method = ChatObject.getClass().getMethod("canPost", Chat)
            can_post = canPost_method.invoke(None, chat)
            return can_post
        except Exception as e:
            return True
    
    def _is_megagroup(self, chat):
        try:
            class_name = chat.getClass().getSimpleName()
            is_megagroup = "megagroup" in class_name.lower() or "supergroup" in class_name.lower()
            return is_megagroup
        except Exception as e:
            return False
    
    def _is_forum(self, chat):
        try:
            ChatObject = find_class("org.telegram.messenger.ChatObject")
            Chat = find_class("org.telegram.tgnet.TLRPC$Chat")
            isForum_method = ChatObject.getClass().getMethod("isForum", Chat)
            is_forum = isForum_method.invoke(None, chat)
            return is_forum
        except Exception as e:
            return False
    
    def _create_click_listener(self, chat_activity):
        def on_click(view):
            try:
                self.plugin._launch_reply_in_another_chat(chat_activity)
            except Exception as e:
                pass
        
        return OnClickListener(on_click)


class RemoveHttpsHook(MethodHook):
    def before_hooked_method(self, param):
        try:
            clip_data = param.args[0]
            if clip_data:
                item = clip_data.getItemAt(0)
                if item:
                    text = item.getText()
                    if text:
                        text_str = str(text)
                        if text_str.startswith("https://t.me/") or text_str.startswith("https://"):
                            modified_text = text_str.replace("https://", "", 1)
                            ClipDataClass = find_class("android.content.ClipData")
                            new_clip = ClipDataClass.newPlainText("label", modified_text)
                            param.args[0] = new_clip
        except Exception as e:
            pass


class DirectProfileHook:
    
    def __init__(self, plugin):
        self.plugin = plugin
    
    def before_hooked_method(self, param):
        try:
            delegate = param.thisObject
            if not delegate:
                return
            
            if len(param.args) < 1:
                return
            
            view = param.args[0]
            
            member_request_cell_class = find_class("org.telegram.ui.Cells.MemberRequestCell")
            if not member_request_cell_class:
                return
                
            if not isinstance(view, member_request_cell_class):
                return
            
            is_search_expanded = get_private_field(delegate, "isSearchExpanded")
            if is_search_expanded:
                fragment = get_private_field(delegate, "fragment")
                if fragment and fragment.getParentActivity():
                    AndroidUtilities = jclass("org.telegram.messenger.AndroidUtilities")
                    AndroidUtilities.hideKeyboard(fragment.getParentActivity().getCurrentFocus())
            
            cell = view
            
            def open_profile_directly():
                try:
                    importer = cell.getImporter()
                    if not importer:
                        return
                    
                    users = get_private_field(delegate, "users")
                    if not users:
                        return
                    
                    user = users.get(importer.user_id)
                    if not user:
                        return
                    
                    fragment = get_private_field(delegate, "fragment")
                    if not fragment:
                        return
                    
                    fragment.getMessagesController().putUser(user, False)
                    
                    set_private_field(delegate, "isNeedRestoreList", True)
                    
                    fragment.dismissCurrentDialog()
                    
                    Bundle = jclass("android.os.Bundle")
                    args = Bundle()
                    args.putLong("user_id", user.id)
                    args.putBoolean("removeFragmentOnChatOpen", False)
                    
                    ProfileActivity = jclass("org.telegram.ui.ProfileActivity")
                    profileActivity = ProfileActivity(args)
                    
                    fragment.presentFragment(profileActivity)
                    
                except Exception:
                    pass
            
            from android_utils import R
            
            AndroidUtilities = jclass("org.telegram.messenger.AndroidUtilities")
            delay = 100 if is_search_expanded else 0
            AndroidUtilities.runOnUIThread(R(open_profile_directly), delay)
            
            param.setResult(None)
            
        except Exception:
            pass


class RemoveGreetingStickerHook(MethodReplacement):
    def replace_hooked_method(self, param):
        result = self.invoke_original_method(param)
        
        try:
            chat_activity = param.thisObject
            greetings_container = get_private_field(chat_activity, "greetingsViewContainer")
            
            if greetings_container is not None:
                parent = greetings_container.getParent()
                if parent is not None:
                    parent.removeView(greetings_container)
                set_private_field(chat_activity, "greetingsViewContainer", None)
                
        except Exception:
            pass
        
        return result


class MotionEventSwipeHook(MethodHook):
    def __init__(self, plugin):
        self.plugin = plugin
        self.last_x = 0
        self.last_y = 0
        self.swipe_threshold = 100
    
    def before_hooked_method(self, param):
        try:
            motion_event = param.args[0] if len(param.args) > 0 else None
            if not motion_event:
                return
            
            action = motion_event.getAction()
            x = motion_event.getX()
            y = motion_event.getY()
            
            if action == 0:
                self.last_x = x
                self.last_y = y
            
            elif action == 1:
                dx = x - self.last_x
                dy = y - self.last_y
                
                if abs(dx) > self.swipe_threshold and abs(dy) < 50:
                    swipe_action = self.plugin.get_setting("swipe_action", 0)
                    if swipe_action != 0:
                        chat_activity = param.thisObject
                        try:
                            current_message = get_private_field(chat_activity, "selectedObject")
                            if current_message:
                                if swipe_action == 1:
                                    run_on_ui_thread(lambda: self.plugin._save_to_saved_messages(chat_activity, current_message))
                                elif swipe_action == 2:
                                    run_on_ui_thread(lambda: self.plugin._show_translate_alert(chat_activity, current_message))
                                elif swipe_action == 3:
                                    run_on_ui_thread(lambda: self.plugin._show_share_alert(chat_activity, current_message))
                        except Exception as e:
                            pass
        
        except Exception as e:
            pass


class SwipeReplyHook(MethodHook):
    def __init__(self, plugin):
        self.plugin = plugin
    
    def before_hooked_method(self, param):
        try:
            chat_activity = param.thisObject
            message_object = param.args[0] if len(param.args) > 0 else None
            
            if not message_object:
                return
            
            Thread = jclass("java.lang.Thread")
            stack_trace = Thread.currentThread().getStackTrace()
            
            is_from_swipe = False
            for element in stack_trace:
                method_name = str(element.getMethodName())
                if method_name == "processTouchEvent":
                    is_from_swipe = True
                    break
            
            if not is_from_swipe:
                return
            
            action = self.plugin.get_setting("swipe_action", 0)
            
            if action == 0:
                return
            
            param.setResult(None)
            
            if action == 1:
                run_on_ui_thread(lambda: self.plugin._save_to_saved_messages(chat_activity, message_object))
            
            elif action == 2:
                run_on_ui_thread(lambda: self.plugin._show_translate_alert(chat_activity, message_object))
            
            elif action == 3:
                run_on_ui_thread(lambda: self.plugin._show_share_alert(chat_activity, message_object))
        
        except Exception as e:
            pass


SEARCH_FILTER_NONE = 0
SEARCH_FILTER_PHOTOS = 1
SEARCH_FILTER_VIDEOS = 2
SEARCH_FILTER_VOICE_MESSAGES = 3
SEARCH_FILTER_VIDEO_MESSAGES = 4
SEARCH_FILTER_FILES = 5
SEARCH_FILTER_MUSIC = 6
SEARCH_FILTER_GIFS = 7
SEARCH_FILTER_GEO = 8
SEARCH_FILTER_CONTACTS = 9
SEARCH_FILTER_MENTIONS = 10


class PlaySoundHook:
    def __init__(self, plugin):
        self.plugin = plugin
    
    def before_hooked_method(self, param):
        setting = self.plugin.get_setting("notification_sound", 1)
        vibrate_setting = self.plugin.get_setting("in_chat_vibration", 0)
        
        if vibrate_setting != 0:
            try:
                Vibrator = jclass("android.os.Vibrator")
                ApplicationLoader = self.plugin._get_class("org.telegram.messenger.ApplicationLoader")
                context = ApplicationLoader.applicationContext
                vibrator = context.getSystemService("vibrator")
                
                if vibrate_setting == 1:
                    vibrator.vibrate(30)
                elif vibrate_setting == 2:
                    vibrator.vibrate(50)
                elif vibrate_setting == 3:
                    pattern = [0, 50, 50, 50]
                    vibrator.vibrate(pattern, -1)
                elif vibrate_setting == 4:
                    vibrator.vibrate(200)
            except Exception as e:
                pass
        
        if setting == 0:
            param.setResult(None)
        elif setting == 2:
            try:
                from android.media import MediaPlayer, AudioManager
                
                if os.path.exists(self.plugin.ios_sound_path):
                    mp = MediaPlayer()
                    mp.setAudioStreamType(AudioManager.STREAM_NOTIFICATION)
                    mp.setDataSource(self.plugin.ios_sound_path)
                    mp.prepare()
                    mp.setVolume(1.0, 1.0)
                    mp.start()
                    
                    def release_player():
                        try:
                            mp.release()
                        except:
                            pass
                    
                    import threading
                    threading.Timer(3.0, release_player).start()
                
                param.setResult(None)
            except Exception as e:
                pass


class SoundPoolLoadHook:
    def __init__(self, plugin):
        self.plugin = plugin
    
    def after_hooked_method(self, param):
        try:
            context = param.args[0]
            res_id = param.args[1]
            
            R = find_class("org.telegram.messenger.R")
            if R and res_id == R.raw.sound_in:
                setting = self.plugin.get_setting("notification_sound", 1)
                if setting == 2 and os.path.exists(self.plugin.ios_sound_path):
                    soundpool = param.thisObject
                    ios_id = soundpool.load(self.plugin.ios_sound_path, 1)
                    self.plugin.soundpool_instance = soundpool
                    self.plugin.ios_sound_id = ios_id
                    param.setResult(ios_id)
        except Exception as e:
            pass


class SetVisibleReactionsListHook(MethodHook):
    
    def __init__(self, plugin):
        self.plugin = plugin
        self.processed_count = 0
    
    def before_hooked_method(self, param):
        try:
            container = param.thisObject
            
            is_channel = self._is_channel_context(container)
            
            pinned_reactions = self.plugin.get_pinned_reactions(is_channel)
            
            if not pinned_reactions:
                return
            
            original_list = param.args[0]
            
            allowed_reactions_type = self._get_allowed_reactions_type(is_channel)
            
            star_reactions = []
            allowed_reactions = []
            for i in range(original_list.size()):
                reaction = original_list.get(i)
                if hasattr(reaction, 'isStar') and reaction.isStar:
                    star_reactions.append((i, reaction))
                else:
                    allowed_reactions.append(reaction)
            
            ArrayList = jclass("java.util.ArrayList")
            new_list = ArrayList()
            
            added_hashes = set()
            for pinned in pinned_reactions:
                found = False
                for allowed in allowed_reactions:
                    if pinned.hash == allowed.hash:
                        new_list.add(pinned)
                        added_hashes.add(pinned.hash)
                        found = True
                        break
                
                if not found:
                    if "All" in str(allowed_reactions_type):
                        new_list.add(pinned)
                        added_hashes.add(pinned.hash)
            
            for allowed in allowed_reactions:
                if allowed.hash not in added_hashes:
                    new_list.add(allowed)
 
            for original_pos, star_reaction in star_reactions:
                if original_pos <= new_list.size():
                    new_list.add(original_pos, star_reaction)
                else:
                    new_list.add(star_reaction)
            
            param.args[0] = new_list
            
            self.processed_count += 1
            
        except Exception:
            pass
    
    def _is_channel_context(self, container):
        try:
            from client_utils import get_last_fragment
            fragment = get_last_fragment()
            
            if fragment is None:
                return False
            
            ChatActivity = find_class("org.telegram.ui.ChatActivity")
            if isinstance(fragment, ChatActivity):
                current_chat = fragment.getCurrentChat()
                if current_chat is not None:
                    if hasattr(current_chat, 'megagroup'):
                        return not current_chat.megagroup
                    else:
                        return False
            
            return False
        except Exception:
            return False
    
    def _get_allowed_reactions_type(self, is_channel):
        try:
            from client_utils import get_last_fragment
            
            fragment = get_last_fragment()
            if fragment is None:
                return "TL_chatReactionsAll"
            
            ChatActivity = find_class("org.telegram.ui.ChatActivity")
            if isinstance(fragment, ChatActivity):
                current_chat = fragment.getCurrentChat()
                if current_chat is not None:
                    if not hasattr(current_chat, 'megagroup'):
                        return "TL_chatReactionsAll"
                    
                    MessagesController = find_class("org.telegram.messenger.MessagesController")
                    if MessagesController:
                        mc = MessagesController.getInstance(0)
                        chat_full = mc.getChatFull(current_chat.id)
                        if chat_full and hasattr(chat_full, 'available_reactions'):
                            reactions_obj = chat_full.available_reactions
                            if reactions_obj:
                                class_name = reactions_obj.getClass().getSimpleName()
                                return class_name
            
            return "TL_chatReactionsAll"
        except Exception:
            return "TL_chatReactionsAll"


class SearchLinksReplacement(MethodHook):
    def __init__(self, plugin_instance):
        super().__init__()
        self.plugin = plugin_instance
    
    def before_hooked_method(self, param):
        try:
            text = param.args[0] if len(param.args) > 0 else None
            if not text:
                param.setResult(None)
                return
            
            text_str = str(text)
            exclude_pattern = self.plugin.get_setting("disable_link_preview_exclude_pattern", "")
            
            if not exclude_pattern or exclude_pattern.strip() == "":
                param.setResult(None)
                return
            
            try:
                if re.search(exclude_pattern, text_str, re.IGNORECASE):
                    return
                else:
                    param.setResult(None)
                    return
            except re.error as e:
                param.setResult(None)
                return
            
        except Exception as e:
            param.setResult(None)
            return


class EnterViewConstructorHook:
    def after_hooked_method(self, param):
        try:
            enter_view = param.thisObject
            field = enter_view.getClass().getDeclaredField("messageWebPageSearch")
            field.setAccessible(True)
            field.setBoolean(enter_view, False)
        except:
            pass


class SendMessageParamsHook:
    def after_hooked_method(self, param):
        try:
            params = param.getResult()
            if params is not None:
                field = params.getClass().getDeclaredField("searchLinks")
                field.setAccessible(True)
                field.setBoolean(params, False)
        except:
            pass


class SearchFilterOpenSearchHook:
    def __init__(self, plugin):
        self.plugin = plugin
    
    def after_hooked_method(self, param):
        try:
            from android.view import View
            chat_activity = param.thisObject
            def create_and_show_button():
                self.plugin._create_search_filter_button(chat_activity)
                activity_id = id(chat_activity)
                if activity_id in self.plugin.search_filter_buttons:
                    filter_button = self.plugin.search_filter_buttons[activity_id]
                    filter_button.setVisibility(View.VISIBLE)
            run_on_ui_thread(create_and_show_button)
        except:
            pass


class SearchFilterSendRequestHook:
    def __init__(self, plugin):
        self.plugin = plugin
    
    def before_hooked_method(self, param):
        try:
            if self.plugin.search_filter_current == SEARCH_FILTER_NONE:
                return
            
            request = param.args[0]
            request_class_name = request.getClass().getName()
            
            if "TL_messages_search" in request_class_name:
                filter_obj = self.plugin._get_search_filter_type()
                
                try:
                    filter_field = request.getClass().getDeclaredField("filter")
                    filter_field.setAccessible(True)
                    filter_field.set(request, filter_obj)
                except:
                    pass
                    
        except:
            pass


class PinnedReactionsDelegate(dynamic_proxy(UniversalFragment.UniversalFragmentDelegate)):
    
    def __init__(self, plugin):
        super().__init__()
        self.plugin = plugin
        self.listView = None
        self.current_tab = 0
        self.emoji_spans = {}
    
    def getTitle(self):
        return get_string("pinned_reactions_title", "Pinned Reactions")
    
    def onFragmentCreate(self):
        pass
    
    def onFragmentDestroy(self):
        pass
    
    def onBackPressed(self):
        return True
    
    def beforeCreateView(self):
        return None

    def onLongClick(self, item, view, position, x, y):
        return False
    
    def _get_emoji_for_document_id(self, document_id):
        try:
            from android.text import SpannableString, Spanned
            from org.telegram.ui.Components import AnimatedEmojiSpan
            
            spannable = SpannableString(" ")
            span = AnimatedEmojiSpan(document_id, None)
            spannable.setSpan(span, 0, spannable.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE)
            return spannable
        except Exception:
            return f"ID: {document_id}"    
    
    def afterCreateView(self, view):
        from org.telegram.ui.Components import UniversalRecyclerView
        if hasattr(view, 'getChildAt'):
            for i in range(view.getChildCount()):
                child = view.getChildAt(i)
                if isinstance(child, UniversalRecyclerView):
                    self.listView = child
                    break
        return None
    
    def fillItems(self, items, adapter):
        try:
            from org.telegram.ui.Components import UItem
            from org.telegram.messenger import Utilities
            from java import jarray, jclass, dynamic_proxy
            
            def on_tab_change(tab_index):
                self.current_tab = tab_index
                if self.listView is not None:
                    self.listView.adapter.update(True)
            
            CallbackInterface = Utilities.Callback
            class TabCallback(dynamic_proxy(CallbackInterface)):
                def __init__(self, callback):
                    super().__init__()
                    self.callback = callback
                
                def run(self, value):
                    self.callback(value)
            
            String = jclass('java.lang.String')
            tab_names = jarray(String)([get_string("chats", "Chats"), get_string("channels", "Channels")])
            
            items.add(UItem.asSlideView(
                tab_names,
                self.current_tab,
                TabCallback(on_tab_change)
            ))
        
            is_channel = self.current_tab == 1
            reactions_list = self._get_reactions_list(is_channel)
            
            enable_key = "pinned_reactions_enabled_channels" if is_channel else "pinned_reactions_enabled_chats"
            is_enabled = self.plugin.get_setting(enable_key, "true") == "true"
            
            def on_switch_change(enabled):
                self.plugin.set_setting(enable_key, "true" if enabled else "false")
                if self.listView:
                    self.listView.adapter.update(True)
            
            switch_title = get_string("channels_switch", "Enable Pinned Reactions in Channels") if is_channel else get_string("chats_switch", "Enable Pinned Reactions in Chats")
            items.add(UItem.asCheck(
                1,
                switch_title
            ).setChecked(is_enabled))
            
            items.add(UItem.asShadow(get_string("pin_reactions_info", "You can pin reactions from any pack")))
            
            header_text = get_string("pinned_reactions_count", "Pinned Reactions ({count}/7)").format(count=len(reactions_list))
            items.add(UItem.asHeader(header_text))
            
            if reactions_list:
                for idx, reaction in enumerate(reactions_list):
                    if "document_id" in reaction:
                        document_id = reaction["document_id"]
                        emoji_span = self._get_emoji_for_document_id(document_id)
                        
                        from android.text import SpannableStringBuilder
                        combined = SpannableStringBuilder()
                        combined.append(emoji_span)
                        combined.append(f"  {get_string('tap_to_remove', 'Tap to remove')}")
                        
                        self.emoji_spans[100 + idx] = combined
                        button_item = UItem.asButton(100 + idx, combined).accent()
                    else:
                        emoji = reaction.get("emoticon", "?")
                        button_text = f"{emoji}  {get_string('tap_to_remove', 'Tap to remove')}"
                        button_item = UItem.asButton(100 + idx, button_text).accent()
                    
                    items.add(button_item)
            else:
                items.add(UItem.asShadow(get_string("no_reactions_pinned", "No reactions pinned yet")))
            
            if len(reactions_list) < 7:
                items.add(UItem.asButton(200, get_string("add_reaction", "Add Reaction")).accent())
            
            items.add(UItem.asShadow(
                get_string("add_reaction_hint", "Tap Add Reaction and enter an emoji")
            ))
        
        except Exception:
            pass
    
    def onClick(self, item, view, position, x, y):
        from ui.alert import AlertDialogBuilder
        from android_utils import run_on_ui_thread
        
        item_id = item.id
        
        if item_id == 1:
            is_channel = self.current_tab == 1
            enable_key = "pinned_reactions_enabled_channels" if is_channel else "pinned_reactions_enabled_chats"
            current_value = self.plugin.get_setting(enable_key, "true") == "true"
            self.plugin.set_setting(enable_key, "false" if current_value else "true")
            if self.listView:
                self.listView.adapter.update(True)
        elif 100 <= item_id < 200:
            idx = item_id - 100
            is_channel = self.current_tab == 1
            reactions = self._get_reactions_list(is_channel)
            if idx < len(reactions):
                reactions.pop(idx)
                self.plugin.save_pinned_reactions(is_channel, reactions)
                if self.listView is not None:
                    self.listView.adapter.update(True)
        elif item_id == 200:
            self._show_add_reaction_dialog()
    
    def _show_add_reaction_dialog(self):
        from ui.alert import AlertDialogBuilder
        from client_utils import get_last_fragment
        from org.telegram.ui.Components import EditTextBoldCursor
        from org.telegram.ui.ActionBar import Theme
        from org.telegram.messenger import AndroidUtilities
        from android.text import InputType
        from android.util import TypedValue
        from android.widget import FrameLayout
        from android.view import Gravity
        from android_utils import run_on_ui_thread
        
        fragment = get_last_fragment()
        if fragment is None:
            return
        
        activity = fragment.getParentActivity()
        if activity is None:
            return

        edit_text = EditTextBoldCursor(activity)
        edit_text.setHint(get_string("document_id_hint", "Document ID"))
        edit_text.setInputType(InputType.TYPE_CLASS_TEXT)
        edit_text.setMaxLines(1)
        edit_text.setSingleLine(True)
        edit_text.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 18)
        edit_text.setTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteBlackText))
        edit_text.setHintTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteHintText))
        edit_text.setBackground(Theme.createEditTextDrawable(activity, True))
        edit_text.setCursorColor(Theme.getColor(Theme.key_windowBackgroundWhiteBlueHeader))
        edit_text.setCursorSize(AndroidUtilities.dp(20))
        edit_text.setCursorWidth(1.5)
        edit_text.setPadding(0, 0, 0, 0)
        edit_text.setFocusable(True)
        
        builder = AlertDialogBuilder(activity)
        builder.set_title(get_string("add_reaction_title", "Add Reaction"))
        builder.set_message(get_string("add_reaction_message", "Enter the document ID of the emoji you want to pin"))
        builder.set_view(edit_text)
        
        def on_add(dialog, which):
            from ui.bulletin import BulletinHelper
            from org.telegram.messenger import UserConfig
            
            input_text = str(edit_text.getText()).strip()
            if not input_text:
                return
            
            is_channel = self.current_tab == 1
            reactions = self._get_reactions_list(is_channel)
            
            try:
                document_id = int(input_text)
                
                if not UserConfig.getInstance(UserConfig.selectedAccount).isPremium():
                    BulletinHelper.show_simple(get_string("premium_required", "Premium required"), R_tg.raw.star_premium_2, fragment)
                    return
                
                for reaction in reactions:
                    if reaction.get("document_id") == document_id:
                        BulletinHelper.show_simple(get_string("already_pinned", "Already pinned"), R_tg.raw.ic_pin, fragment)
                        return
                
                if len(reactions) < 7:
                    reactions.append({"document_id": document_id})
                    self.plugin.save_pinned_reactions(is_channel, reactions)
                    run_on_ui_thread(lambda: self.listView.adapter.update(True) if self.listView else None, 100)
            except ValueError:
                for reaction in reactions:
                    if reaction.get("emoticon") == input_text:
                        BulletinHelper.show_simple(get_string("already_pinned", "Already pinned"), R_tg.raw.ic_pin, fragment)
                        return
                
                if len(reactions) < 7:
                    reactions.append({"emoticon": input_text})
                    self.plugin.save_pinned_reactions(is_channel, reactions)
                    run_on_ui_thread(lambda: self.listView.adapter.update(True) if self.listView else None, 100)
        
        def on_cancel_click(dialog, which):
            try:
                AndroidUtilities.hideKeyboard(edit_text)
            except Exception:
                pass
            dialog.dismiss()
        
        builder.set_positive_button(get_string("button_add", "Add"), on_add)
        builder.set_negative_button(get_string("button_cancel", "Cancel"), on_cancel_click)
        
        dialog = builder.show()
        
        def apply_layout_params():
            try:
                layout_params = edit_text.getLayoutParams()
                if layout_params is not None:
                    if isinstance(layout_params, FrameLayout.LayoutParams):
                        layout_params.gravity = Gravity.CENTER_HORIZONTAL
                    
                    if hasattr(layout_params, 'rightMargin'):
                        layout_params.rightMargin = AndroidUtilities.dp(24)
                        layout_params.leftMargin = AndroidUtilities.dp(24)
                        layout_params.height = AndroidUtilities.dp(36)
                        layout_params.bottomMargin = AndroidUtilities.dp(15)
                    edit_text.setLayoutParams(layout_params)
                
                edit_text.requestFocus()
                text_length = edit_text.getText().length() if edit_text.getText() else 0
                edit_text.setSelection(0, text_length)
            except Exception:
                pass
        
        run_on_ui_thread(apply_layout_params, 100)
    
    def _get_reactions_list(self, is_channel):
        if is_channel:
            reactions_json = self.plugin.get_setting("pinned_reactions_channels", "[]")
        else:
            reactions_json = self.plugin.get_setting("pinned_reactions_chats", "[]")
        
        try:
            return json.loads(reactions_json)
        except:
            return []


class ProcessSelectedOptionHook(MethodHook):
    def before_hooked_method(self, param):
        if param.args[0] == 2:
            activity = param.thisObject
            activity_class = activity.getClass()
            
            selected = activity_class.getDeclaredField("selectedObject")
            selected.setAccessible(True)
            
            selected_group = activity_class.getDeclaredField("selectedObjectGroup")
            selected_group.setAccessible(True)
            
            forwarding = activity_class.getDeclaredField("forwardingMessage")
            forwarding.setAccessible(True)
            forwarding.set(activity, selected.get(activity))
            
            forwarding_group = activity_class.getDeclaredField("forwardingMessageGroup")
            forwarding_group.setAccessible(True)
            forwarding_group.set(activity, selected_group.get(activity))
            
            try:
                scrim = activity_class.getDeclaredField("scrimPopupWindow")
                scrim.setAccessible(True)
                popup = scrim.get(activity)
                if popup:
                    popup.dismiss()
            except:
                pass
            
            method = activity_class.getDeclaredMethod("openForward", jclass("java.lang.Boolean").TYPE)
            method.setAccessible(True)
            method.invoke(activity, False)
            
            param.setResult(None)


class UnifyUsernameProcessClickHook(MethodHook):
    def before_hooked_method(self, param):
        try:
            profile_activity = param.thisObject
            position = param.args[0]
            
            username_row = get_private_field(profile_activity, "usernameRow")
            set_username_row = get_private_field(profile_activity, "setUsernameRow")
            
            if position != username_row and position != set_username_row:
                return
            
            user_id = get_private_field(profile_activity, "userId")
            chat_id = get_private_field(profile_activity, "chatId")
            
            if user_id != 0:
                return
            
            if chat_id == 0:
                return
            
            param.setResult(True)
            
        except:
            pass


class UnifyUsernameBindViewHook(MethodHook):
    def __init__(self, plugin):
        self.plugin = plugin

    def after_hooked_method(self, param):
        try:
            list_adapter = param.thisObject
            holder = param.args[0]
            position = param.args[1]
            
            this_class = list_adapter.getClass()
            outer_field = this_class.getDeclaredField("this$0")
            outer_field.setAccessible(True)
            profile_activity = outer_field.get(list_adapter)
            
            username_row = get_private_field(profile_activity, "usernameRow")
            
            if position != username_row:
                return
            
            user_id = get_private_field(profile_activity, "userId")
            chat_id = get_private_field(profile_activity, "chatId")
            
            if user_id != 0:
                return
            
            if chat_id == 0:
                return
            
            from org.telegram.messenger import MessagesController, ChatObject, LocaleController, R
            
            current_account = get_private_field(profile_activity, "currentAccount")
            messages_controller = MessagesController.getInstance(current_account)
            chat = messages_controller.getChat(chat_id)
            
            if not chat:
                return
            
            username = ChatObject.getPublicUsername(chat)
            if not username:
                return
            
            view = holder.itemView
            text_detail_cell_class = self.plugin._get_class("org.telegram.ui.Cells.TextDetailCell")
            
            if not text_detail_cell_class.getClass().isInstance(view):
                return
            
            new_text = "@" + username
            new_label = LocaleController.getString(R.string.Username)
            
            view.setTextAndValue(new_text, new_label, True)
            
            from android_utils import OnClickListener, OnLongClickListener
            from org.telegram.messenger import AndroidUtilities
            from android.view import HapticFeedbackConstants
            
            def on_click(v):
                text = "@" + username
                AndroidUtilities.addToClipboard(text)
                from ui.bulletin import BulletinHelper
                from org.telegram.messenger import R as R_tg
                BulletinHelper.show_simple(LocaleController.getString(R.string.UsernameCopied), R_tg.raw.copy, profile_activity)
            
            def on_long_click(v):
                v.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS, HapticFeedbackConstants.FLAG_IGNORE_GLOBAL_SETTING)
                link = "https://t.me/" + username
                AndroidUtilities.addToClipboard(link)
                from ui.bulletin import BulletinHelper
                from org.telegram.messenger import R as R_tg
                BulletinHelper.show_simple(LocaleController.getString(R.string.LinkCopied), R_tg.raw.copy, profile_activity)
                return True
            
            from org.telegram.ui.ActionBar import Theme as UITheme
            view.setForeground(UITheme.createSelectorDrawable(UITheme.getColor(UITheme.key_listSelector), 2))
            view.setOnClickListener(OnClickListener(on_click))
            view.setOnLongClickListener(OnLongClickListener(on_long_click))
            
        except:
            pass


class EditFileNameSetItemOptionsHook(MethodHook):
    def __init__(self, plugin):
        self.plugin = plugin
    
    def before_hooked_method(self, param):
        try:
            options = param.args[0] if param and hasattr(param, "args") and param.args else None
            if not options:
                return
            
            if getattr(self.plugin, "_last_item_options", None) is not options:
                self.plugin._last_item_options = options
                self.plugin._menu_item_added = False
            
            message_send_preview = param.thisObject if param and hasattr(param, "thisObject") else None
            self.plugin._message_send_preview = message_send_preview
            
            if getattr(self.plugin, "_menu_item_added", False):
                return
            
            if not self.plugin._has_document_selected():
                return
            
            from org.telegram.messenger import R
            from java.lang import Runnable
            from java import dynamic_proxy
            
            class RunnableFactory(dynamic_proxy(Runnable)):
                def __init__(self, fn):
                    super().__init__()
                    self.fn = fn
                
                def run(self):
                    try:
                        self.fn()
                    except Exception:
                        pass
            
            action = RunnableFactory(lambda opts=options, preview=message_send_preview: self.plugin._on_edit_filename_click(opts, preview))
            
            try:
                icon_id = R.drawable.msg_edit
            except:
                icon_id = 0
            
            if icon_id > 0:
                options.add(icon_id, get_string("edit_file_name", "Edit File Name"), action)
            else:
                options.add(get_string("edit_file_name", "Edit File Name"), action)
            
            self.plugin._menu_item_added = True
            
        except Exception:
            pass


class OpenForwardHook(MethodHook):
    def before_hooked_method(self, param):
        if param.args[0]:
            param.args[0] = False


class UiTweaksSettingsHeaderHook:
    def __init__(self, plugin):
        self.plugin = plugin
    
    def after_hooked_method(self, param):
        try:
            activity = param.thisObject
            items = param.args[0]
            if not items or items.size() == 0:
                return
            
            plugin_obj = get_private_field(activity, "plugin")
            if not plugin_obj or str(plugin_obj.getId()) != "ui_tweaks":
                return
            
            if get_private_field(activity, "createSubFragmentCallback") is not None:
                return
            
            try:
                qh = getattr(quantahut, 'QuantaHut', None)
                if qh and hasattr(qh, 'instance') and qh.instance:
                    state = qh.instance._search_state.get(id(activity))
                    if state and (state.get("active") or state.get("show_history")):
                        return
            except:
                pass
            
            header = self.plugin._create_settings_header(activity.getContext())
            if header:
                from org.telegram.ui.Components import UItem
                from com.exteragram.messenger.plugins.models import HeaderSetting
                item = UItem.asCustom(header)
                item.settingItem = HeaderSetting("uitweaks_header")
                try: item.setTransparent(True)
                except: pass
                items.add(0, item)
                items.add(1, UItem.asShadow())
        except:
            pass

