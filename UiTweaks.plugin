import traceback
import re
import urllib.parse
import os
import json
import urllib.request
import base64
import weakref
import threading
import time
from collections import deque

from typing import Set, Any, Optional, List, Dict
from base_plugin import BasePlugin, MenuItemData, MenuItemType, HookResult, HookStrategy, MethodReplacement, AppEvent
from hook_utils import find_class, get_private_field, set_private_field
from java import dynamic_proxy, jclass, jlong

from ui.settings import Header, Switch, Divider, Selector, Text
from ui.bulletin import BulletinHelper
from ui.alert import AlertDialogBuilder

from client_utils import get_last_fragment, get_send_messages_helper, get_messages_storage, run_on_queue, PLUGINS_QUEUE, get_messages_controller
from android_utils import run_on_ui_thread, log, OnLongClickListener, OnClickListener

from android.view import View, ViewGroup, Gravity, HapticFeedbackConstants
from android.widget import FrameLayout, TextView, ImageView, LinearLayout, HorizontalScrollView
from android.graphics import Canvas, Path, Rect, Typeface
from android.graphics.drawable import Drawable, GradientDrawable
from android.text import SpannableStringBuilder, TextUtils, Spanned
from android.text.style import ForegroundColorSpan, TypefaceSpan, CharacterStyle
from android.text import InputType
from android.util import TypedValue
from android.os import Bundle, Handler, Looper
from android.content import Context, ClipData, ClipboardManager
from android.os import Vibrator
from java.util import ArrayList
import threading
from com.exteragram.messenger.plugins import PluginsController
from com.exteragram.messenger.plugins.ui import PluginsActivity, PluginSettingsActivity

from org.telegram.messenger import R as R_tg
from org.telegram.messenger import MessagesController, UserConfig, ApplicationLoader, LocaleController, AndroidUtilities, MessagesStorage
from org.telegram.messenger import UserObject, ChatObject, ImageLocation, MessageObject, DialogObject, NotificationCenter, BotWebViewVibrationEffect, SendMessagesHelper, CodeHighlighting
from org.telegram.ui.Components import EditTextBoldCursor, URLSpanUserMention
from org.telegram.tgnet import TLRPC
from org.telegram.ui.ActionBar import ActionBarPopupWindow, Theme, ActionBarMenuItem
from org.telegram.ui.Components import AvatarDrawable, BackupImageView, LayoutHelper
from org.telegram.ui import ChatActivity, ProfileActivity, TopicsFragment, DialogsActivity, LaunchActivity
from org.telegram.ui.ActionBar import BaseFragment
from com.google.android.exoplayer2.util import Consumer

try:
    import quantahut
    if hasattr(quantahut, '__version__') and quantahut.__version__ < "1.4.7":
        raise Exception(f"QuantaHut {quantahut.__version__} is too old. Need 1.4.7+")
    from quantahut import showmultiselector, showupdatebottomsheet, export_plugin_settings
except ImportError:
    raise Exception("QuantaHut is required but not installed. Install it first. (Don't report this as a bug - it's your fault.)")

QuantaHut = quantahut

__id__ = "ui_tweaks"
__name__ = "UiTweaks"
__description__ = "Well sometimes you just need to tweak things... (requires QuantaHut)"
__version__ = "1.7.7"
__author__ = "@luvztroy"
__min_version__ = "12.1.1"
__icon__ = "luvztroyIcons/13"
__dependencies__ = ["quantahut"]


CUSTOM_CODE_ID = 99999
CUSTOM_MENTION_ID = 99998
DEBOUNCE_TIME = 0.5

def show_confirmation_selector():
    try:
        global uitweaks_plugin_instance
        if uitweaks_plugin_instance:
            uitweaks_plugin_instance._show_confirmation_selector()
    except Exception as e:
        pass

def get_text(key: str, default: str = None) -> str:
    try:
        selected_language = get_selected_language_preference()
        if selected_language:
            localized_text = quantahut.get_localized_string("UiTweaks", key, default or key)
            return localized_text
        else:
            current_language = LocaleController.getInstance().getCurrentLocaleInfo().getLangCode()
            if current_language == "en":
                return default or key
            localized_text = quantahut.get_localized_string("UiTweaks", key, default or key)
            return localized_text
    except Exception as e:
        return default or key

def get_selected_language_preference():
    try:
        from base_plugin import PluginsController
        from hook_utils import get_private_field
        prefs = get_private_field(PluginsController.getInstance(), "preferences")
        return prefs.getString("plugin_setting_ui_tweaks_selected_language", None)
    except Exception as e:
        return None

def set_selected_language_preference(lang_code):
    try:
        from base_plugin import PluginsController
        from hook_utils import get_private_field
        prefs = get_private_field(PluginsController.getInstance(), "preferences")
        prefs.edit().putString("plugin_setting_ui_tweaks_selected_language", lang_code).apply()
    except Exception as e:
        pass



TL_documentAttributeSticker = jclass('org.telegram.tgnet.TLRPC$TL_documentAttributeSticker')
TL_documentAttributeAudio = jclass('org.telegram.tgnet.TLRPC$TL_documentAttributeAudio')
TL_documentAttributeVideo = jclass('org.telegram.tgnet.TLRPC$TL_documentAttributeVideo')
TL_documentAttributeAnimated = jclass('org.telegram.tgnet.TLRPC$TL_documentAttributeAnimated')


CUSTOM_BUTTON_TAG = 0x6E7166

class RecentChatsManager:
    
    MAX_RECENT_DIALOGS = 25
    
    def __init__(self, plugin_instance):
        self.plugin_ref = weakref.ref(plugin_instance)
        self.recent_dialogs = {}
        self.clearing = False
        self.clear_timestamp = 0
        self.add_disabled = False
        self._save_timers = {}
    
    def get_recent_dialogs(self, account_id: int) -> List[int]:
        plugin = self.plugin_ref()
        if plugin is None:
            return []
        if account_id not in self.recent_dialogs:
            try:
                saved_data = plugin.get_setting(f"recents_{account_id}", "")
                if saved_data is not None and saved_data != "" and saved_data.strip():
                    try:
                        decoded_data = base64.b64decode(saved_data)
                        dialog_ids = json.loads(decoded_data.decode('utf-8'))
                        self.recent_dialogs[account_id] = deque(dialog_ids)
                    except:
                        self.recent_dialogs[account_id] = deque()
                else:
                    self.recent_dialogs[account_id] = deque()
            except:
                self.recent_dialogs[account_id] = deque()
        
        return list(self.recent_dialogs[account_id])
    
    def add_to_recent_dialogs(self, account_id: int, dialog_id: int):
        import time
        
        plugin = self.plugin_ref()
        if plugin is None:
            return
        
        if self.clearing:
            return
        
        clear_timestamp = float(plugin.get_setting(f"clear_timestamp_{account_id}", "0"))
        if clear_timestamp > 0 and time.time() - clear_timestamp < 3:
            return
        
        if clear_timestamp > 0:
            plugin.set_setting(f"clear_timestamp_{account_id}", "0")
            self.recent_dialogs[account_id] = deque()
            
        if account_id not in self.recent_dialogs:
            self.recent_dialogs[account_id] = deque()
        
        if dialog_id in self.recent_dialogs[account_id]:
            self.recent_dialogs[account_id].remove(dialog_id)
        
        self.recent_dialogs[account_id].appendleft(dialog_id)
        
        while len(self.recent_dialogs[account_id]) > self.MAX_RECENT_DIALOGS:
            self.recent_dialogs[account_id].pop()
        
        self._debounced_save_recent_dialogs(account_id)
    
    def clear_recent_dialogs(self, account_id: int):
        import time
        
        plugin = self.plugin_ref()
        if plugin is None:
            return
        
        self.clearing = True
        plugin.set_setting(f"clear_timestamp_{account_id}", str(time.time()))
        self.recent_dialogs[account_id] = deque()
        plugin.set_setting(f"recents_{account_id}", "")
        self.clearing = False
    
    def _debounced_save_recent_dialogs(self, account_id: int):
        if account_id in self._save_timers:
            timer = self._save_timers[account_id]
            if timer:
                timer.cancel()
        
        def timer_callback():
            try:
                if account_id in self.recent_dialogs:
                    self._save_recent_dialogs(account_id)
            finally:
                if account_id in self._save_timers:
                    del self._save_timers[account_id]
        
        timer = threading.Timer(0.5, timer_callback)
        self._save_timers[account_id] = timer
        timer.start()
    
    def _save_recent_dialogs(self, account_id: int):
        try:
            plugin = self.plugin_ref()
            if plugin is None:
                return
            dialog_ids = list(self.recent_dialogs[account_id])
            json_data = json.dumps(dialog_ids)
            encoded_data = base64.b64encode(json_data.encode('utf-8')).decode('utf-8')
            plugin.set_setting(f"recents_{account_id}", encoded_data)
        except Exception as e:
            pass
        finally:
            if account_id in self._save_timers:
                del self._save_timers[account_id]
    
    def force_reload(self, account_id: int):
        if account_id in self.recent_dialogs:
            del self.recent_dialogs[account_id]
    
    def cleanup(self):
        for timer in self._save_timers.values():
            timer.cancel()
        self._save_timers.clear()

class RecentChatsPopup:
    
    def __init__(self, plugin_instance):
        self.plugin = plugin_instance
        self.recent_manager = RecentChatsManager(plugin_instance)
        self.current_popup = None
        self._save_debounce_timer = None
    
    def show(self, current_account: int, fragment: BaseFragment, back_button: View):
        from org.telegram.messenger import AndroidUtilities
        
        if fragment is None:
            return
        
        context = fragment.getParentActivity()
        fragment_view = fragment.getFragmentView()
        if context is None or fragment_view is None:
            return
        
        self.recent_manager.force_reload(current_account)
        recent_dialogs = self.recent_manager.get_recent_dialogs(current_account)

        if not recent_dialogs:
            return
        
        layout = self._create_popup_layout(context, fragment, recent_dialogs, current_account)
        
        popup_window = ActionBarPopupWindow(
            layout, 
            -2,
            -2
        )
        
        popup_window.setPauseNotifications(True)
        popup_window.setDismissAnimationDuration(220)
        popup_window.setOutsideTouchable(True)
        popup_window.setClippingEnabled(True)
        popup_window.setAnimationStyle(R_tg.style.PopupContextAnimation)
        popup_window.setFocusable(True)
        
        layout.measure(
            View.MeasureSpec.makeMeasureSpec(AndroidUtilities.dp(1000), View.MeasureSpec.AT_MOST),
            View.MeasureSpec.makeMeasureSpec(AndroidUtilities.dp(1000), View.MeasureSpec.AT_MOST)
        )
        
        popup_window.setInputMethodMode(ActionBarPopupWindow.INPUT_METHOD_NOT_NEEDED)
        popup_window.setSoftInputMode(0)
        popup_window.getContentView().setFocusableInTouchMode(True)
        layout.setFitItems(True)
        
        popup_x = AndroidUtilities.dp(8)
        if AndroidUtilities.isTablet():
            location = [0, 0]
            fragment_view.getLocationInWindow(location)
            popup_x += location[0]
        
        popup_y = back_button.getBottom() - AndroidUtilities.dp(8)
        self.current_popup = popup_window
        
        OnDismissListenerInterface = find_class("android.widget.PopupWindow$OnDismissListener")
        OnDismissListener = dynamic_proxy(OnDismissListenerInterface)
        class DismissListenerImpl(OnDismissListener):
            def __init__(self, callback_ref):
                super().__init__()
                self.callback_ref = callback_ref
            def onDismiss(self):
                callback = self.callback_ref()
                if callback:
                    callback()
        popup_window.setOnDismissListener(DismissListenerImpl(weakref.ref(self._on_popup_dismissed)))
        
        popup_window.showAtLocation(fragment_view, Gravity.LEFT | Gravity.TOP, popup_x, popup_y)
        popup_window.dimBehind()
    
    def _on_popup_dismissed(self):
        self.current_popup = None
    
    def _create_popup_layout(self, context, fragment, recent_dialogs, current_account):
        layout = ActionBarPopupWindow.ActionBarPopupWindowLayout(context)
        layout.setBackgroundColor(Theme.getColor(Theme.key_actionBarDefaultSubmenuBackground))
        
        header_view = self._create_header(context, fragment, current_account)
        layout.addView(header_view, LayoutHelper.createLinear(
            -1, -2, 4, 4, 4, 4
        ))
        
        for dialog_id in recent_dialogs:
            chat_item = self._create_chat_item(context, fragment, dialog_id, current_account)
            if chat_item is not None:
                layout.addView(chat_item, LayoutHelper.createLinear(
                    -1, 48
                ))
        
        return layout
    
    def _create_header(self, context, fragment, current_account):
        from org.telegram.messenger import AndroidUtilities
        
        header_view = FrameLayout(context)
        header_view.setBackgroundColor(Theme.getColor(Theme.key_actionBarDefaultSubmenuBackground))
        
        title_text_view = TextView(context)
        title_text_view.setTextColor(Theme.getColor(Theme.key_dialogTextBlue))
        title_text_view.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 16)
        title_text_view.setText(get_text("recent_chats", "Recent Chats"))
        title_text_view.setTypeface(AndroidUtilities.getTypeface(AndroidUtilities.TYPEFACE_ROBOTO_MEDIUM))
        header_view.addView(title_text_view, LayoutHelper.createFrame(
            -2, 24, Gravity.LEFT
        ))
        
        clear_image_view = ImageView(context)
        clear_image_view.setScaleType(ImageView.ScaleType.CENTER)
        clear_image_view.setColorFilter(Theme.getColor(Theme.key_actionBarDefaultSubmenuItemIcon))
        clear_image_view.setImageResource(R_tg.drawable.msg_close)
        clear_image_view.setBackground(Theme.createSelectorDrawable(Theme.getColor(Theme.key_listSelector)))
        clear_click_listener = self._create_clear_click_listener(fragment, current_account)
        OnClickInterface = find_class("android.view.View$OnClickListener")
        OnClick = dynamic_proxy(OnClickInterface)
        class ClearClickImpl(OnClick):
            def __init__(self, listener, fragment_ref):
                super().__init__()
                self.listener = listener
                self.fragment_ref = fragment_ref
            def onClick(self, v):
                if self.fragment_ref and self.fragment_ref():
                    self.listener(v)
        clear_image_view.setOnClickListener(ClearClickImpl(clear_click_listener, weakref.ref(fragment)))
        header_view.addView(clear_image_view, LayoutHelper.createFrame(
            24, 24, Gravity.RIGHT | Gravity.CENTER_VERTICAL
        ))
        
        header_view.setPadding(AndroidUtilities.dp(9), AndroidUtilities.dp(8), AndroidUtilities.dp(8), AndroidUtilities.dp(8))
        return header_view
    
    def _create_clear_click_listener(self, fragment, current_account):
        fragment_ref = weakref.ref(fragment)
        popup_ref = weakref.ref(self)
        def clear_click_listener(*args):
            fragment = fragment_ref()
            popup = popup_ref()
            if fragment is None or popup is None:
                return
                
            view = args[0] if len(args) > 0 else None
            activity = fragment.getParentActivity()
            if activity is None:
                return
                
            builder = AlertDialogBuilder(activity)
            builder.set_title(get_text("clear_recent_chats", "Clear Recent Chats"))
            builder.set_message(get_text("clear_recent_chats_confirm", "Are you sure you want to clear all recent chats?"))
            builder.set_positive_button(get_text("clear", "Clear"), lambda dialog, which: popup._clear_recent_chats(current_account))
            builder.set_negative_button(get_text("cancel", "Cancel"), None)
            builder.show()
        
        return clear_click_listener
    
    def _clear_recent_chats(self, current_account):
        self.recent_manager.clear_recent_dialogs(current_account)
        
        if self.current_popup and self.current_popup.isShowing():
            self.current_popup.dismiss()
            self.current_popup = None
    
    def destroy(self):
        try:
            if self.current_popup and self.current_popup.isShowing():
                self.current_popup.dismiss()
        except Exception:
            pass
        finally:
            self.current_popup = None
    
    def _create_chat_item(self, context, fragment, dialog_id, current_account):
        from org.telegram.messenger import AndroidUtilities
        
        cell = FrameLayout(context)
        cell.setMinimumWidth(AndroidUtilities.dp(200))
        
        chat = None
        user = None
        if dialog_id < 0:
            chat = MessagesController.getInstance(current_account).getChat(-dialog_id)
        else:
            user = MessagesController.getInstance(current_account).getUser(dialog_id)
        
        if chat is None and user is None:
            return None
        
        image_view = BackupImageView(context)
        if chat is not None and chat.forum:
            image_view.setRoundRadius(AndroidUtilities.dp(8))
        else:
            image_view.setRoundRadius(AndroidUtilities.dp(16))
        cell.addView(image_view, LayoutHelper.createFrameRelatively(
            32, 32, Gravity.START | Gravity.CENTER_VERTICAL, 13, 0, 0, 0
        ))
        
        title_view = TextView(context)
        title_view.setLines(1)
        title_view.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 16)
        title_view.setTextColor(Theme.getColor(Theme.key_actionBarDefaultSubmenuItem))
        title_view.setEllipsize(TextUtils.TruncateAt.END)
        cell.addView(title_view, LayoutHelper.createFrameRelatively(
            -1, -2,
            Gravity.START | Gravity.CENTER_VERTICAL, 59, 0, 12, 0
        ))
        
        avatar_drawable = AvatarDrawable()
        avatar_drawable.setScaleSize(0.8)
        
        if chat is not None:
            avatar_drawable.setInfo(chat)
            if chat.photo is not None and chat.photo.strippedBitmap is not None:
                image_view.setImage(ImageLocation.getForChat(chat, ImageLocation.TYPE_SMALL), "50_50", chat.photo.strippedBitmap, chat)
            else:
                image_view.setImageDrawable(avatar_drawable)
            title_view.setText(chat.title)
        else:
            if UserObject.isReplyUser(user):
                name = get_text("replies", "Replies")
                avatar_drawable.setInfo(user)
                image_view.setImageDrawable(avatar_drawable)
            elif UserObject.isDeleted(user):
                name = get_text("hidden_name", "Hidden Name")
                avatar_drawable.setInfo(user)
                image_view.setImage(ImageLocation.getForUser(user, ImageLocation.TYPE_SMALL), "50_50", avatar_drawable, user)
            else:
                name = UserObject.getUserName(user)
                avatar_drawable.setInfo(user)
                if user.photo is not None and user.photo.strippedBitmap is not None:
                    image_view.setImage(ImageLocation.getForUser(user, ImageLocation.TYPE_SMALL), "50_50", user.photo.strippedBitmap, user)
                else:
                    image_view.setImageDrawable(avatar_drawable)
            title_view.setText(name)
        
        cell.setBackground(Theme.getSelectorDrawable(Theme.getColor(Theme.key_listSelector), False))
        chat_click_listener = self._create_chat_click_listener(fragment, dialog_id)
        chat_long_click_listener = self._create_chat_long_click_listener(fragment, dialog_id)
        cell.setOnClickListener(OnClickListener(chat_click_listener))
        cell.setOnLongClickListener(OnLongClickListener(chat_long_click_listener))
        
        return cell
    
    def _create_chat_click_listener(self, fragment, dialog_id):
        fragment_ref = weakref.ref(fragment)
        popup_ref = weakref.ref(self)
        def chat_click_listener(*args):
            fragment = fragment_ref()
            popup = popup_ref()
            if fragment is None or popup is None:
                return
                
            view = args[0] if len(args) > 0 else None
            if popup.current_popup and popup.current_popup.isShowing():
                popup.current_popup.dismiss()
                popup.current_popup = None
            
            if dialog_id < 0:
                if MessagesController.getInstance(fragment.getCurrentAccount()).isForum(dialog_id):
                    bundle = Bundle()
                    bundle.putLong("chat_id", -dialog_id)
                    fragment.presentFragment(TopicsFragment(bundle))
                else:
                    bundle = Bundle()
                    bundle.putLong("chat_id", -dialog_id)
                    fragment.presentFragment(ChatActivity(bundle))
            else:
                bundle = Bundle()
                bundle.putLong("user_id", dialog_id)
                fragment.presentFragment(ChatActivity(bundle))
        
        return chat_click_listener
    
    def _create_chat_long_click_listener(self, fragment, dialog_id):
        fragment_ref = weakref.ref(fragment)
        popup_ref = weakref.ref(self)
        plugin_ref = weakref.ref(self.plugin)
        def chat_long_click_listener(*args):
            fragment = fragment_ref()
            popup = popup_ref()
            plugin = plugin_ref()
            if fragment is None or popup is None or plugin is None:
                return True
                
            view = args[0] if len(args) > 0 else None
            plugin._perform_haptic(fragment)
            if popup.current_popup and popup.current_popup.isShowing():
                popup.current_popup.dismiss()
                popup.current_popup = None
            
            bundle = Bundle()
            if dialog_id < 0:
                bundle.putLong("chat_id", -dialog_id)
            else:
                bundle.putLong("user_id", dialog_id)
            fragment.presentFragment(ProfileActivity(bundle))
            return True
        
        return chat_long_click_listener


class NonClickablePreviewDispatchTouchHook:
    def before_hooked_method(self, param):
        try:
            fragment_view = param.thisObject
            if not fragment_view:
                return
            
            chat_activity_field = fragment_view.getClass().getDeclaredField("this$0")
            chat_activity_field.setAccessible(True)
            chat_activity = chat_activity_field.get(fragment_view)
            if not chat_activity:
                return
            
            parent_layout_field = chat_activity.getClass().getSuperclass().getDeclaredField("parentLayout")
            parent_layout_field.setAccessible(True)
            parent_layout = parent_layout_field.get(chat_activity)
            if not parent_layout:
                return
            
            is_preview_method = parent_layout.getClass().getDeclaredMethod("isInPreviewMode")
            is_preview_method.setAccessible(True)
            in_preview_mode = is_preview_method.invoke(parent_layout)
            
            if in_preview_mode:
                try:
                    allow_field = chat_activity.getClass().getDeclaredField("allowExpandPreviewByClick")
                    allow_field.setAccessible(True)
                    allow_expand = allow_field.getBoolean(chat_activity)
                    
                    if allow_expand:
                        allow_field.setBoolean(chat_activity, False)
                except:
                    pass
        except:
            pass


class NonClickablePreviewPresentFragmentHook:
    def after_hooked_method(self, param):
        try:
            fragment = param.thisObject
            preview_fragment = param.args[0]
            preview_menu = param.args[1]
            
            if not preview_fragment or not preview_menu:
                return
                
            ChatActivity = jclass("org.telegram.ui.ChatActivity")
            if not isinstance(preview_fragment, ChatActivity):
                return
                
            try:
                allow_field = preview_fragment.getClass().getDeclaredField("allowExpandPreviewByClick")
                allow_field.setAccessible(True)
                allow_field.setBoolean(preview_fragment, False)
            except:
                pass

            try:
                chat_list_field = preview_fragment.getClass().getDeclaredField("chatListView")
                chat_list_field.setAccessible(True)
                chat_list_view = chat_list_field.get(preview_fragment)
                if chat_list_view is not None:
                    try:
                        chat_list_view.setOnItemClickListener(None)
                    except:
                        pass
                    try:
                        chat_list_view.setOnItemLongClickListener(None)
                    except:
                        pass
                    try:
                        chat_list_view.setClickable(False)
                    except:
                        pass
                    try:
                        chat_list_view.setLongClickable(False)
                    except:
                        pass
            except:
                pass

            dialog_id = preview_fragment.getDialogId()
            
            MessagesController = jclass("org.telegram.messenger.MessagesController")
            DialogObject = jclass("org.telegram.messenger.DialogObject")
            
            if DialogObject.isUserDialog(dialog_id):
                user = MessagesController.getInstance(fragment.currentAccount).getUser(dialog_id)
                if not user:
                    return
                self._add_open_profile_item(fragment, preview_menu, dialog_id)
                self._add_open_chat_item(fragment, preview_menu, dialog_id)
            else:
                chat_id_for_lookup = -dialog_id
                chat = MessagesController.getInstance(fragment.currentAccount).getChat(chat_id_for_lookup)
                if not chat:
                    return
                self._add_open_profile_item(fragment, preview_menu, dialog_id)
                self._add_open_chat_item(fragment, preview_menu, dialog_id)
        except:
            pass
    
    def _add_open_profile_item(self, fragment, preview_menu, dialog_id):
        try:
            ActionBarMenuSubItem = jclass("org.telegram.ui.ActionBar.ActionBarMenuSubItem")
            ProfileActivity = jclass("org.telegram.ui.ProfileActivity")
            DialogObject = jclass("org.telegram.messenger.DialogObject")
            R = jclass("org.telegram.messenger.R")
            
            item_text = get_text("open_profile", "Open Profile")
            item_icon = R.drawable.msg_openprofile
            
            open_profile_item = ActionBarMenuSubItem(fragment.getParentActivity(), False, False)
            open_profile_item.setTextAndIcon(item_text, item_icon)
            open_profile_item.setMinimumWidth(160)
            
            click_listener = OnClickListener(lambda *args: self._open_profile(fragment, dialog_id))
            open_profile_item.setOnClickListener(click_listener)
            
            preview_menu.addView(open_profile_item)
        except:
            pass
    
    def _add_open_chat_item(self, fragment, preview_menu, dialog_id):
        try:
            ActionBarMenuSubItem = jclass("org.telegram.ui.ActionBar.ActionBarMenuSubItem")
            R = jclass("org.telegram.messenger.R")
            
            item_text = get_text("open_chat", "Open Chat")
            item_icon = R.drawable.msg_msgbubble3
            
            open_chat_item = ActionBarMenuSubItem(fragment.getParentActivity(), False, False)
            open_chat_item.setTextAndIcon(item_text, item_icon)
            open_chat_item.setMinimumWidth(160)
            
            click_listener = OnClickListener(lambda *args: self._open_chat(fragment))
            open_chat_item.setOnClickListener(click_listener)
            
            preview_menu.addView(open_chat_item)
        except:
            pass
    
    def _open_chat(self, fragment):
        try:
            parent_layout = fragment.getParentLayout()
            if parent_layout:
                parent_layout.expandPreviewFragment()
        except:
            pass
    
    def _open_profile(self, fragment, dialog_id):
        try:
            fragment.finishPreviewFragment()
            
            Bundle = jclass("android.os.Bundle")
            args = Bundle()
            args.putBoolean("expandPhoto", False)
            
            DialogObject = jclass("org.telegram.messenger.DialogObject")
            if DialogObject.isUserDialog(dialog_id):
                args.putLong("user_id", dialog_id)
            else:
                chat_id_for_bundle = -dialog_id
                args.putLong("chat_id", chat_id_for_bundle)
            
            ProfileActivity = jclass("org.telegram.ui.ProfileActivity")
            present_fragment_method = fragment.getClass().getDeclaredMethod("presentFragment", jclass("org.telegram.ui.ActionBar.BaseFragment"))
            present_fragment_method.setAccessible(True)
            present_fragment_method.invoke(fragment, ProfileActivity(args))
        except:
            pass


class AddToFolderAllTabsHook:
    def __init__(self, plugin):
        self.plugin = plugin

    def after_hooked_method(self, param):
        try:
            dialogs_activity = param.thisObject
            
            add_to_folder_item_field = dialogs_activity.getClass().getDeclaredField("addToFolderItem")
            add_to_folder_item_field.setAccessible(True)
            add_to_folder_item = add_to_folder_item_field.get(dialogs_activity)
            
            if add_to_folder_item is None:
                return
            
            filter_tabs_view_field = dialogs_activity.getClass().getDeclaredField("filterTabsView")
            filter_tabs_view_field.setAccessible(True)
            filter_tabs_view = filter_tabs_view_field.get(dialogs_activity)
            
            folder_id_field = dialogs_activity.getClass().getDeclaredField("folderId")
            folder_id_field.setAccessible(True)
            folder_id = folder_id_field.getInt(dialogs_activity)
            
            selected_dialogs_field = dialogs_activity.getClass().getDeclaredField("selectedDialogs")
            selected_dialogs_field.setAccessible(True)
            selected_dialogs = selected_dialogs_field.get(dialogs_activity)
            
            FiltersListBottomSheetClass = find_class("org.telegram.ui.Components.FiltersListBottomSheet")
            if FiltersListBottomSheetClass:
                can_add_filters = FiltersListBottomSheetClass.getCanAddDialogFilters(dialogs_activity, selected_dialogs)
                has_available_folders = can_add_filters is not None and not can_add_filters.isEmpty()
            else:
                has_available_folders = False
            
            should_show = False
            
            if folder_id == 1:
                should_show = True
            elif (filter_tabs_view is not None and 
                  filter_tabs_view.getVisibility() == View.VISIBLE and 
                  has_available_folders):
                should_show = True
            
            if should_show:
                add_to_folder_item.setVisibility(View.VISIBLE)
            else:
                add_to_folder_item.setVisibility(View.GONE)
                
        except Exception:
            pass

class UnreadCountHook:
    def __init__(self, plugin_instance):
        self.plugin = plugin_instance
    
    def after_hooked_method(self, param):
        try:
            show_message_count = self.plugin.get_setting("unread_message_count", False)
            show_chat_count = self.plugin.get_setting("unread_chat_count", False)
            exclude_archived = self.plugin.get_setting("exclude_archived_from_count", False)
            process_counts = show_message_count or show_chat_count

            exclude_archived = self.plugin.get_setting("exclude_archived_from_count", False)
            process_counts = show_message_count or show_chat_count

            if not (process_counts or exclude_archived):
                return

            messages_storage = param.thisObject
            apply = param.args[0] if len(param.args) > 0 else False
            from org.telegram.messenger import UserConfig; current_account = UserConfig.selectedAccount
            from java import jclass; MessagesController = jclass("org.telegram.messenger.MessagesController"); messages_controller = MessagesController.getInstance(current_account)

            if process_counts:
                dialog_filters_field = messages_controller.getClass().getDeclaredField("dialogFilters"); dialog_filters_field.setAccessible(True); dialog_filters = dialog_filters_field.get(messages_controller)

                for i in range(dialog_filters.size()):
                    try:
                        filter_dialog = dialog_filters.get(i)

                        dialogs_field = filter_dialog.getClass().getDeclaredField("dialogs"); dialogs_field.setAccessible(True); dialogs = dialogs_field.get(filter_dialog)

                        if dialogs is None or dialogs.size() == 0:
                            continue

                        unread_count = 0; muted_excluded = 0; muted_with_mentions = 0; non_muted_counted = 0

                        for j in range(dialogs.size()):
                            dialog = dialogs.get(j)

                            dialog_unread_count = dialog.unread_count; dialog_unread_mentions = dialog.unread_mentions_count

                            if dialog_unread_count == 0 and dialog_unread_mentions == 0:
                                continue

                            if exclude_archived and hasattr(dialog, 'folder_id') and dialog.folder_id != 0:
                                continue

                            dialog_id = dialog.id; is_muted = messages_controller.isDialogMuted(dialog_id, 0)

                            if is_muted:
                                if show_message_count and not show_chat_count:
                                    unread_count += dialog_unread_count + dialog_unread_mentions
                                elif dialog_unread_mentions > 0 and show_chat_count and not show_message_count:
                                    unread_count += 1
                                muted_excluded += 1
                                continue

                            if show_message_count:
                                unread_count += dialog_unread_count
                            elif show_chat_count:
                                unread_count += 1
                            non_muted_counted += 1

                        filter_dialog.unreadCount = unread_count; filter_dialog.pendingUnreadCount = unread_count

                    except Exception:
                        continue

            if exclude_archived:
                try:
                    pending_archive_count_field = messages_storage.getClass().getDeclaredField("pendingArchiveUnreadCount")
                    pending_archive_count_field.setAccessible(True)
                    pending_archive_count_field.setInt(messages_storage, 0)

                    archive_count_field = messages_storage.getClass().getDeclaredField("archiveUnreadCount")
                    archive_count_field.setAccessible(True)
                    archive_count_field.setInt(messages_storage, 0)
                except Exception:
                    pass

                if not process_counts:
                    try:
                        from org.telegram.messenger import NotificationCenter
                        notification_center = NotificationCenter.getInstance(current_account)
                        notification_center.postNotificationName(NotificationCenter.dialogsUnreadCounterChanged, current_account)
                    except Exception:
                        pass

            if process_counts:
                main_unread_count_field = messages_storage.getClass().getDeclaredField("pendingMainUnreadCount")
                main_unread_count_field.setAccessible(True)
                previous_pending = main_unread_count_field.getInt(messages_storage)

                previous_main = None
                main_unread_count_apply_field = None
                if apply:
                    main_unread_count_apply_field = messages_storage.getClass().getDeclaredField("mainUnreadCount")
                    main_unread_count_apply_field.setAccessible(True)
                    previous_main = main_unread_count_apply_field.getInt(messages_storage)

                main_dialogs_method = messages_controller.getClass().getMethod("getAllDialogs")
                main_dialogs = main_dialogs_method.invoke(messages_controller)

                filtered_count = 0
                if main_dialogs is not None:
                    for k in range(main_dialogs.size()):
                        dialog = main_dialogs.get(k)
                        dialog_unread_count = dialog.unread_count
                        dialog_unread_mentions = dialog.unread_mentions_count

                        if dialog_unread_count == 0 and dialog_unread_mentions == 0:
                            continue

                        if exclude_archived and hasattr(dialog, 'folder_id') and dialog.folder_id != 0:
                            continue

                        dialog_id = dialog.id
                        is_muted = messages_controller.isDialogMuted(dialog_id, 0)

                        if is_muted:
                            if show_message_count and not show_chat_count:
                                filtered_count += dialog_unread_count + dialog_unread_mentions
                            elif dialog_unread_mentions > 0 and show_chat_count and not show_message_count:
                                filtered_count += 1
                            continue

                        if show_message_count:
                            filtered_count += dialog_unread_count
                        elif show_chat_count:
                            filtered_count += 1

                main_unread_count_field.setInt(messages_storage, filtered_count)

                if apply and main_unread_count_apply_field is not None:
                    main_unread_count_apply_field.setInt(messages_storage, filtered_count)

                should_notify = filtered_count != previous_pending or (apply and previous_main is not None and filtered_count != previous_main)

                if should_notify:
                    try:
                        from org.telegram.messenger import NotificationCenter
                        notification_center = NotificationCenter.getInstance(current_account)
                        notification_center.postNotificationName(NotificationCenter.dialogsUnreadCounterChanged, current_account)
                    except Exception:
                        pass
            
        except Exception:
            pass


class ContactStatusUpdateRowsIdsHook:
    def __init__(self, plugin):
        self.plugin = plugin

    def before_hooked_method(self, param):
        activity = param.thisObject
        state = self.plugin.contact_status_activity_state.setdefault(activity, {"mutualRow": -1})

        state["shouldInsertMutual"] = False

        user = self._get_profile_user(activity)
        if not user or not getattr(user, "mutual_contact", False):
            state["mutualRow"] = -1
            return

        state["shouldInsertMutual"] = True

    def after_hooked_method(self, param):
        activity = param.thisObject
        state = self.plugin.contact_status_activity_state.get(activity)
        if not state:
            return

        if not state.get("shouldInsertMutual"):
            state["mutualRow"] = -1
            state.pop("shouldInsertMutual", None)
            return

        insert_position = self._calculate_insert_position(activity)
        if insert_position == -1:
            state["mutualRow"] = -1
            state.pop("shouldInsertMutual", None)
            return

        state["mutualRow"] = insert_position
        state.pop("shouldInsertMutual", None)

        row_count = self._get_int_field(activity, "rowCount")
        if row_count != -1:
            self._set_int_field(activity, "rowCount", row_count + 1)

        try:
            activity_class = activity.getClass()
            fields = activity_class.getDeclaredFields()
            for i in range(len(fields)):
                field = fields[i]
                name = field.getName()
                if "Row" not in name and "row" not in name:
                    continue
                if name in ("rowCount", "phoneRow", "mutualRow"):
                    continue
                field_type = field.getType()
                INTEGER_CLASS = jclass("java.lang.Integer")
                if field_type != INTEGER_CLASS.TYPE and field_type != INTEGER_CLASS:
                    continue
                field.setAccessible(True)
                value_obj = field.get(activity)
                if value_obj is None:
                    continue
                try:
                    value = int(value_obj)
                except Exception:
                    continue
                if value >= state["mutualRow"] and value != -1:
                    try:
                        if field_type == INTEGER_CLASS.TYPE:
                            field.setInt(activity, value + 1)
                        else:
                            field.set(activity, INTEGER_CLASS(value + 1))
                    except Exception:
                        pass
        except Exception:
            pass

    def _get_profile_user(self, activity):
        try:
            user_id = self._get_long_field(activity, "userId")
            if user_id == 0:
                return None
            from org.telegram.messenger import MessagesController, UserConfig
            account = UserConfig.selectedAccount
            controller = MessagesController.getInstance(account)
            if not controller:
                return None
            try:
                user_id_int = int(user_id)
            except Exception:
                user_id_int = user_id
            user = controller.getUser(user_id_int)
            if user:
                return user
            user_full = self._get_object_field(activity, "userInfo")
            if user_full and getattr(user_full, "user", None):
                return user_full.user
        except Exception:
            return None

    def _get_int_field(self, obj, name):
        try:
            field = obj.getClass().getDeclaredField(name)
            field.setAccessible(True)
            return field.getInt(obj)
        except Exception:
            return -1

    def _set_int_field(self, obj, name, value):
        try:
            field = obj.getClass().getDeclaredField(name)
            field.setAccessible(True)
            field.setInt(obj, value)
        except Exception:
            pass

    def _get_long_field(self, obj, name):
        try:
            field = obj.getClass().getDeclaredField(name)
            field.setAccessible(True)
            return field.getLong(obj)
        except Exception:
            return 0

    def _get_object_field(self, obj, name):
        try:
            field = obj.getClass().getDeclaredField(name)
            field.setAccessible(True)
            return field.get(obj)
        except Exception:
            return None

    def _calculate_insert_position(self, activity):
        anchors = [
            "phoneRow",
            "infoHeaderRow",
            "infoHeaderRowEmpty",
            "userInfoRow",
            "usernameRow",
            "birthdayRow",
            "bizHoursRow",
            "bizLocationRow",
            "noteRow",
        ]
        for name in anchors:
            value = self._get_int_field(activity, name)
            if value != -1:
                return value + 1
        return -1


class ContactStatusListAdapterGetItemViewTypeHook:
    def __init__(self, plugin):
        self.plugin = plugin

    def before_hooked_method(self, param):
        adapter = param.thisObject
        activity = self._get_activity_from_adapter(adapter)
        state = self.plugin.contact_status_activity_state.get(activity)
        if not state:
            return
        position_arg = param.args[0]
        try:
            position = int(position_arg)
        except Exception:
            position = position_arg
        if position == state.get("mutualRow", -1):
            try:
                INTEGER_CLASS = jclass("java.lang.Integer")
                param.setResult(INTEGER_CLASS(1024))
            except Exception:
                param.setResult(1024)

    def _get_activity_from_adapter(self, adapter):
        try:
            field = adapter.getClass().getDeclaredField("this$0")
            field.setAccessible(True)
            return field.get(adapter)
        except Exception:
            return None


class ContactStatusListAdapterCreateViewHolderHook:
    def __init__(self, plugin):
        self.plugin = plugin

    def before_hooked_method(self, param):
        view_type = param.args[1]
        if view_type != 1024:
            return

        try:
            adapter = param.thisObject
            activity = self._get_activity_from_adapter(adapter)

            context = None
            parent = param.args[0]
            if parent is not None:
                try:
                    context = parent.getContext()
                except Exception:
                    context = None
            if context is None and activity is not None:
                for getter in ("getParentActivity", "getContext"):
                    try:
                        method = getattr(activity, getter)
                        context = method()
                        if context:
                            break
                    except Exception:
                        continue
            if context is None:
                raise ValueError("No context available for mutual cell")

            from org.telegram.ui.Cells import TextDetailCell
            cell = TextDetailCell(context)
            holder_class = jclass("org.telegram.ui.Components.RecyclerListView$Holder")
            holder = holder_class(cell)
            param.setResult(holder)
        except Exception:
            pass

    def _get_activity_from_adapter(self, adapter):
        try:
            field = adapter.getClass().getDeclaredField("this$0")
            field.setAccessible(True)
            return field.get(adapter)
        except Exception:
            return None


class ContactStatusListAdapterBindViewHolderHook:
    def __init__(self, plugin):
        self.plugin = plugin

    def before_hooked_method(self, param):
        position_arg = param.args[1]
        try:
            position = int(position_arg)
        except Exception:
            position = position_arg
        adapter = param.thisObject
        activity = self._get_activity_from_adapter(adapter)
        state = self.plugin.contact_status_activity_state.get(activity)
        if not state or position != state.get("mutualRow", -1):
            return

        try:
            holder = param.args[0]
            item_view = holder.itemView
            from org.telegram.ui.Cells import TextDetailCell
            if isinstance(item_view, TextDetailCell):
                item_view.setTextAndValue(
                    get_text("mutual_contact", "Mutual contact"),
                    get_text("both_saved_as_contacts", "Both saved as contacts"),
                    True
                )
            param.setResult(None)
        except Exception:
            pass

    def _get_activity_from_adapter(self, adapter):
        try:
            field = adapter.getClass().getDeclaredField("this$0")
            field.setAccessible(True)
            return field.get(adapter)
        except Exception:
            return None


class UiTweaksPlugin(BasePlugin):
    def __init__(self):
        super().__init__()

        self.hook_dialogs_ref = None
        self.hook_dialogs_destroy_ref = None
        self.hook_dialog_cell_ref = None
        self.hook_photo_cell_ref = None
        self.hook_gif_spoiler_ref = None
        self.hook_gif_dismiss_ref = None
        self.hook_process_external_url_ref = None
        self.hook_photo_cell_set_entry_ref = None
        self.hook_drawer_icon_ref = None
        self.hook_swipe_prevention_ref = None
        self.hook_star_reaction_menu_ref = None
        self.hook_star_reaction_visible_list_ref = None
        self.hook_article_viewer_ref = None
        self.hook_webapp_swipe_prevention_ref = None
        self.hook_download_manager_ref = None
        self.hook_proxy_button_ref = None
        self.current_chat_activity = None
        self.current_popup = None
        self._cached_accounts = None
        self.hook_phone_number_ref = None
        self.hook_messages_controller_ref = None
        self.hook_update_bot_button_ref = None
        self.hook_call_buttons_ref = None
        self.hook_group_voice_chat_icon_ref = None
        self.hook_voice_message_control_ref = None
        self.hook_voice_message_time_display_ref = None
        self.hook_video_message_control_ref = None
        self.hook_unread_badge_ref = None
        self.hook_back_button_draw_ref = None
        self.hook_no_quote_create_buttons_ref = None
        self.hook_no_quote_update_bottom_panel_ref = None
        self.hook_add_to_folder_all_tabs_ref = None
        self.current_back_button = None
        self.unread_count = 0
        self._unread_count_cache = 0
        self._last_unread_update = 0
        self._cached_dialog_id = 0
        self.forced_scroll_offset = 200
        
        self.unhook_send_message = None
        self.unhook_deeplink = None
        self.unhook_set_command = None
        self.hook_handler = None
        self.command_from_message_click = False
        self.hook_link_confirmation_ref = None
        self.hook_disable_topic_swipe_ref = None
        self.hook_select_all_media_ref = None
        self.hook_account_visibility_drawer_ref = None
        self.hook_account_visibility_profile_ref = None
        self.hook_fill_action_mode_menu_ref = None
        self.hook_perform_menu_action_ref = None
        self.hook_message_preview_view_ref = None
        self.hook_share_sheet_folders_ref = None
        self.hook_swipe_disable_ref = None
        self.hook_star_reaction_gradient_ref = None
        self.hook_star_reaction_layout_draw_ref = None
        self.hook_disable_auto_web_login_ref = None
        self.hook_do_not_share_phone_number_ref = None
        self.hook_prefer_common_groups_tab_ref = None
        self.hook_non_clickable_dispatch_ref = None
        self.hook_non_clickable_present_ref = None
        self.hook_non_clickable_present_ref2 = None
        self.hook_birthday_alert_ref = None
        self.hook_forward_confirmation_ref = None
        self.hook_join_confirmation_ref = None
        self.hook_send_typing_refs = None
        self.hook_open_link_internally_ref = None
        self.hook_recent_chats_activity_ref = None
        self.hook_recent_profile_activity_ref = None
        self.hook_recent_topics_fragment_ref = None
        self.hook_browser_open_url_ref = None
        self.hook_code_formatting_ref = None
        self.hook_sender_select_popup_ref = None
        self.hook_unread_count_ref = None
        self.contact_status_update_rows_hook = None
        self.contact_status_get_item_view_type_hook = None
        self.contact_status_create_view_holder_hook = None
        self.contact_status_bind_view_holder_hook = None
        self.contact_status_activity_state = {}
        
        self.safe_mode_hook_ref = None
        self.safe_mode_last_volume_down_time = 0
        self.safe_mode_volume_down_count = 0
        self.safe_mode_multi_tap_window = 2000
        self.safe_mode_required_taps = 5
        self.safe_mode_cooldown = 5000
        self.safe_mode_volume_down_press_time = 0
        self.safe_mode_is_holding = False
        
        self.no_quote_forward_menu_handle = None
        self.no_quote_requested = False
        
        self.hook_search_by_user_id_ref = None
        self.added_send_media_buttons = set()
        self._no_quote_buttons_created = set()
        self._no_quote_button_cache = {}

        self._select_all_id = 1000
        self._select_all_added_modes = set()
        
        self._goto_items_added = set()
        
        self.recent_manager = RecentChatsManager(self)
        self.popup_manager = RecentChatsPopup(self)
        self.hooked_activities = set()
        self.memory_check_running = False
        
       
        self.hidden_folders_data = {}
        self.hide_all_chats_folder = {}
        self.hook_folder_visibility_ref = None
        
        self.hook_gift_drawer_reset_ref = None
        self.hook_gift_drawer_click_ref = None
        self.hook_gift_drawer_cell_ref = None
        
        self.hook_ai_summarize_create_view_ref = None
        self.hook_ai_summarize_item_click_ref = None
        self.ai_summarize_menu_id = 99997
        self.ai_summarize_hooked_activities = set()
        
        self.goto_message_menu_id = 99996
        self.chat_action_bar_hooked_activities = set()
        
        self.hook_ai_role_limit_constructor_ref = None
        self.hook_ai_role_limit_settext_ref = None
        
        self.hook_sleep_timer_ref = None
        self.sleep_timer_active = False
        self._sleep_handler = None
        self._sleep_runnable = None
        
        self.hook_adaptive_audio_ref = None
        
        self.hook_music_speed_control_ref = None
        
        self.hook_custom_saved_messages_ref = None
        self.custom_saved_chat_id = None

    def log(self, message: str):
        if self.get_setting("show_logs", False):
            log(f"[UiTweaks] {message}")
    
    def _perform_haptic(self, host=None):
        try:
            root = None
            if host:
                get_pa = getattr(host, 'getParentActivity', None)
                if callable(get_pa):
                    act = get_pa()
                    if act:
                        root = act.getWindow().getDecorView()
                if root is None and hasattr(host, 'getWindow'):
                    root = host.getWindow().getDecorView()
            if root is None:
                cf = get_last_fragment()
                if cf:
                    act = cf.getParentActivity()
                    if act:
                        root = act.getWindow().getDecorView()
            if root:
                flags = HapticFeedbackConstants.FLAG_IGNORE_VIEW_SETTING | HapticFeedbackConstants.FLAG_IGNORE_GLOBAL_SETTING
                root.performHapticFeedback(HapticFeedbackConstants.KEYBOARD_TAP, flags)
        except:
            pass
    
    def _get_launch_activity(self, host=None):
        try:
            la = LaunchActivity.instance
        except:
            la = None
        if not la and host:
            try:
                pa = host.getParentActivity()
                if pa:
                    la = pa
            except:
                pass
        return la
    
    def _check_memory(self):
        try:
            if not self.get_setting("enable_memory_warning", True):
                return
                
            from java.lang import Runtime
            
            runtime = Runtime.getRuntime()
            used_memory = (runtime.totalMemory() - runtime.freeMemory()) / (1024 * 1024)
            
            if used_memory > 500:
                self.log(f"Memory threshold exceeded: {used_memory:.2f}MB")
                run_on_ui_thread(lambda: self._show_memory_alert(used_memory))
                return True
        except Exception as e:
            self.log(f"Error checking memory: {e}")
        return False
    
    def _show_memory_alert(self, used_mb):
        try:
            fragment = get_last_fragment()
            if not fragment:
                return
            
            context = fragment.getParentActivity()
            if not context:
                context = ApplicationLoader.applicationContext
            
            builder = AlertDialogBuilder(context)
            title_text = get_text("memory_warning_title", "Memory Warning")
            message_template = get_text("memory_warning_message", "High memory usage: {used_mb}MB.\n\nRestart app or dump memory?")
            message_text = message_template.replace("{used_mb}", f"{used_mb:.0f}")
            builder.set_title(title_text)
            builder.set_message(message_text)
            
            def on_restart(dialog, which):
                dialog.dismiss()
                from quantahut import restart_app
                restart_app(fragment)
            
            def on_dump_memory(dialog, which):
                dialog.dismiss()
                self._dump_memory()
            
            builder.set_positive_button(get_text("restart_app", "Restart"), on_restart)
            builder.set_neutral_button(get_text("dump_memory", "Dump Memory"), on_dump_memory)
            builder.set_negative_button(get_text("cancel", "Cancel"), lambda d, w: d.dismiss())
            builder.show()
        except Exception as e:
            self.log(f"Error showing memory alert: {e}")
    
    def _dump_memory(self):
        try:
            from java.lang import System
            from java.lang import Runtime
            import time
            
            runtime = Runtime.getRuntime()
            used_memory_before = (runtime.totalMemory() - runtime.freeMemory()) / (1024 * 1024)
            
            System.gc()
            System.runFinalization()
            System.gc()
            
            time.sleep(0.5)
            
            used_memory_after = (runtime.totalMemory() - runtime.freeMemory()) / (1024 * 1024)
            freed_memory = used_memory_before - used_memory_after
            
            self.log(f"Memory dump completed. Freed: {freed_memory:.2f}MB (Before: {used_memory_before:.2f}MB, After: {used_memory_after:.2f}MB)")
            
            from ui.bulletin import BulletinHelper
            if freed_memory > 0:
                BulletinHelper.show_success(get_text("memory_dump_success", "Memory dump successful! Freed {freed_memory:.1f}MB").format(freed_memory=freed_memory))
            else:
                BulletinHelper.show_info(get_text("memory_dump_no_freed", "Memory dump completed. No significant memory was freed."))
                
        except Exception as e:
            self.log(f"Error dumping memory: {e}")
            from ui.bulletin import BulletinHelper
            BulletinHelper.show_error(get_text("memory_dump_failed", "Failed to dump memory"))
    
    def _start_memory_monitoring(self):
        if self.memory_check_running:
            return
        
        self.memory_check_running = True
        self._last_memory_alert = 0
        
        def monitor():
            import time
            while self.memory_check_running:
                try:
                    current_time = time.time()
                    if current_time - self._last_memory_alert > 600:
                        alert_shown = self._check_memory()
                        if alert_shown:
                            self._last_memory_alert = current_time
                    time.sleep(60)
                except:
                    pass
        
        thread = threading.Thread(target=monitor)
        thread.daemon = True
        thread.start()

    def on_plugin_load(self):
        self.log(f"UiTweaks {__version__} loaded")
        self.custom_saved_chat_id = self.get_setting("custom_saved_chat_id", None)
        self.add_on_send_message_hook()
        self._load_hidden_folders()
        self._apply_hooks()
        self._setup_quanta_file_hook()
        global uitweaks_plugin_instance
        uitweaks_plugin_instance = self
        
        self._send_comments_bypass = False
        self._send_comments_pending = {}
        self.add_hook("TL_messages_forwardMessages")
        
        self.update_available = False
        self.latest_version = None
        self.changelog = None
        self.download_url = None
        self.checking_update = False
        
        self.hook_always_visible_schedule_button_ref = None
        
        try:
            locale_controller = LocaleController.getInstance()
            current_language = locale_controller.getCurrentLocaleInfo().getLangCode()
            self.log(f"Language detected: {current_language}")
        except Exception as e:
            current_language = "en"
            self.log(f"Language detection failed: {e}, using default: {current_language}")
        try:
            _pref_lang = get_selected_language_preference()
            if _pref_lang:
                self.log(f"[Diag] overriding detected language with stored preference: {_pref_lang}")
                current_language = _pref_lang
        except Exception as e:
            self.log(f"[Diag] failed to apply stored preference override: {e}")
        
        def check_and_download_localization():
            try:
                if current_language == "en":
                    self.log("Skipping localization download for English language")
                    return
                
                continue_english_key = f"continue_english_{current_language}"
                if self.get_setting(continue_english_key, False):
                    self.log(f"User already chose to continue in English for {current_language}")
                    return
                
                if hasattr(QuantaHut, 'github_localization'):
                    cache_timestamp_key = f"UiTweaks_{current_language}_timestamp"
                    has_cached_localization = cache_timestamp_key in QuantaHut.github_localization.localization_cache.content
                    if has_cached_localization:
                        self.log(f"Localization already cached for {current_language}")
                        return
                    else:
                        self.log(f"No cached localization found for {current_language}, will show download bottom sheet")
                
                try:
                    from java.util import Locale
                    locale = Locale(current_language)
                    language_name = locale.getDisplayLanguage(locale)
                except:
                    language_name = current_language.title()
                
                def check_localization_availability():
                    try:
                        import time
                        time.sleep(2)
                        
                        import urllib.request
                        branch_index = self.get_setting("localization_branch", 0)
                        branch = "main" if branch_index == 0 else "Beta"
                        self.log(f"Checking localization availability for {current_language} in branch: {branch}")
                        github_url = f"https://raw.githubusercontent.com/luvztroy/UiTweaks/refs/heads/{branch}/UiTweaks%20{current_language}.json"
                        self.log(f"GitHub URL: {github_url}")
                        
                        try:
                            with urllib.request.urlopen(github_url) as response:
                                if response.getcode() == 200:
                                    self.log(f"Language {current_language} found in {branch} branch")
                                    def show_available_sheet():
                                        showupdatebottomsheet(
                                            title=get_text("download_localization_title", "Download Localization"),
                                            subtitle=get_text("current_language_detected", "Current language detected: {language}").format(language=current_language.lower()),
                                            description=get_text("unlock_uitweaks_description", "Unlock UiTweaks in {language} for a seamless experience.").format(language=language_name),
                                            github_url=github_url,
                                            plugin_name="UiTweaks_Localization",
                                            sticker_pack="luvztroyIcons",
                                            sticker_index=13,
                                            bottom_text=get_text("localization_bottom_text", "This process only happens once. After downloading, the files are saved locally to give you seamless access to UiTweaks in your language anytime."),
                                            show_language_selector=False,
                                            available_languages=quantahut.available_languages,
                                            show_user_avatar=False,
                                            description_centered=True
                                        )
                                    run_on_ui_thread(show_available_sheet)
                                else:
                                    raise Exception("Not found")
                        except Exception as e:
                            self.log(f"Language {current_language} not found in {branch} branch: {e}")
                            def show_unavailable_sheet():
                                showupdatebottomsheet(
                                    title=get_text("localization_not_available", "Localization Not Available"),
                                    subtitle=get_text("current_language_detected", "Current language detected: {language}").format(language=current_language.lower()),
                                    description=get_text("localization_not_available_description", "UiTweaks localization for {language} is not available yet.").format(language=language_name),
                                    github_url=None,
                                    plugin_name="UiTweaks_Localization",
                                    sticker_pack="luvztroyIcons",
                                    sticker_index=13,
                                    button_text=get_text("continue", "Continue"),
                                    bottom_text=get_text("localization_continue_text", "The plugin will continue to work in English. Check back later for localization updates."),
                                    show_language_selector=False,
                                    available_languages=quantahut.available_languages,
                                    show_user_avatar=False,
                                    description_centered=True
                                )
                            run_on_ui_thread(show_unavailable_sheet)
                    except Exception as e:
                        self.log(f"Error checking localization availability: {e}")
                
                import threading
                thread = threading.Thread(target=check_localization_availability)
                thread.daemon = True
                thread.start()
                
            except Exception as e:
                self.log(f"Error checking localization: {e}")
        
        localization_thread = threading.Thread(target=check_and_download_localization)
        localization_thread.daemon = True
        localization_thread.start()
        
        self.hook_handler = ConfirmationHook(self)
        self.add_hook("TL_messages_forwardMessages")
        self._apply_hooks()
        self._setup_confirmation_hooks()
        self._setup_deeplink_hooks()
        self._setup_open_profile_hooks()
        self._setup_open_link_internally_hook()
        
        if self.get_setting("enable_goto_message", False):
            self._hook_goto_message()
        
        if self.get_setting("enable_reply_private_chat", False):
            self._add_reply_private_chat_menu_item()
        
        if self.get_setting("enable_no_quote_forward", True):
            self._add_no_quote_forward_menu_item()

        if self.get_setting("enable_select_all_dialogs", False):
            self._setup_select_all_dialogs()
        
        self._preload_recent_chats()
        
        try:
            run_on_queue(self._perform_heavy_operations, PLUGINS_QUEUE, 2000)
        except Exception as e:
            run_on_ui_thread(self._perform_heavy_operations, 3000)
        
        self._start_memory_monitoring()
        
        self._check_for_updates_on_load()

    def _setup_select_all_dialogs(self):
        try:
            DialogsActivityCls = find_class("org.telegram.ui.DialogsActivity")
            CreateActionMode = DialogsActivityCls.getClass().getDeclaredMethod("createActionMode", find_class("java.lang.String").getClass())
            CreateActionMode.setAccessible(True)
            ActionBarMenuCls = find_class("org.telegram.ui.ActionBar.ActionBarMenu")
            OnItemClick = ActionBarMenuCls.getClass().getDeclaredMethod("onItemClick", find_class("java.lang.Integer").TYPE)
            OnItemClick.setAccessible(True)

            class _UT_AddSelectAllMenu:
                def __init__(self, plugin):
                    self.plugin = plugin

                def after_hooked_method(self, param):
                    try:
                        dlg = param.thisObject
                        actionBar = getattr(dlg, "actionBar", None)
                        if actionBar is None:
                            return
                        actionMode = actionBar.getActionMode()
                        if actionMode is None:
                            return
                        try:
                            hc = actionMode.hashCode()
                            if hc in self.plugin._select_all_added_modes:
                                return
                        except Exception:
                            pass
                        otherItem = None
                        for i in range(actionMode.getChildCount()):
                            child = actionMode.getChildAt(i)
                            if child is not None and child.getClass().getName().endswith("ActionBarMenuItem"):
                                try:
                                    if hasattr(child, "hasSubMenu") and child.hasSubMenu():
                                        otherItem = child
                                        break
                                except Exception:
                                    pass
                        if otherItem is None:
                            return
                        try:
                            popup = get_private_field(otherItem, "popupLayout")
                            if popup is not None:
                                for k in range(popup.getItemsCount()):
                                    v = popup.getItemAt(k)
                                    if v is not None and v.getTag() == self.plugin._select_all_id:
                                        self.plugin._select_all_added_modes.add(hc)
                                        return
                        except Exception:
                            pass
                        title = get_text("select_all", "Select all")
                        otherItem.addSubItem(self.plugin._select_all_id, R_tg.drawable.msg_select_between_solar, title)
                        try:
                            self.plugin._select_all_added_modes.add(hc)
                        except Exception:
                            pass
                    except Exception:
                        pass

            class _UT_InterceptSelectAllClick:
                def __init__(self, plugin):
                    self.plugin = plugin

                def before_hooked_method(self, param):
                    try:
                        itemId = int(param.args[0])
                        if itemId != self.plugin._select_all_id:
                            return
                        menu = param.thisObject
                        actionBar = get_private_field(menu, "parentActionBar")
                        if actionBar is None:
                            return
                        fragment = get_private_field(actionBar, "parentFragment")
                        if fragment is None:
                            return
                        if fragment.getClass().getName() != "org.telegram.ui.DialogsActivity":
                            return
                        dlg = fragment

                        viewPages = get_private_field(dlg, "viewPages")
                        adapter = None
                        listView = None
                        if viewPages is not None:
                            try:
                                vp0 = viewPages[0]
                                adapter = get_private_field(vp0, "dialogsAdapter") or getattr(vp0, "dialogsAdapter", None)
                                listView = get_private_field(vp0, "listView") or getattr(vp0, "listView", None)
                            except Exception:
                                pass
                        if adapter is None or listView is None:
                            try:
                                GetListView = dlg.getClass().getDeclaredMethod("getListView")
                                GetListView.setAccessible(True)
                                listView = GetListView.invoke(dlg)
                                adapter = listView.getAdapter() if listView is not None else None
                            except Exception:
                                pass
                        selected = get_private_field(dlg, "selectedDialogs")
                        if adapter is None or listView is None or selected is None:
                            return

                        DialogsActivityCls2 = dlg.getClass()
                        ShowOrUpdate = None
                        methods = DialogsActivityCls2.getDeclaredMethods()
                        for m in methods:
                            try:
                                if m.getName() == "showOrUpdateActionMode" and len(m.getParameterTypes()) == 2:
                                    ShowOrUpdate = m
                                    break
                            except Exception:
                                pass
                        if ShowOrUpdate is None:
                            return
                        ShowOrUpdate.setAccessible(True)

                        LongClass = find_class("java.lang.Long")
                        DialogInterface = find_class("org.telegram.tgnet.TLRPC$Dialog")

                        state = {"index": 0}
                        state["count"] = adapter.getItemCount()
                        BATCH_SIZE = 24
                        MAX_LOAD_ATTEMPTS = 8
                        state["load_attempts"] = 0
                        initial_adapter = adapter

                        def step():
                            try:
                                if listView.getAdapter() != initial_adapter:
                                    return
                                actionBar2 = getattr(dlg, "actionBar", None)
                                actionMode2 = actionBar2.getActionMode() if actionBar2 is not None else None
                                if actionMode2 is None:
                                    return
                     
                                try:
                                    if not actionBar2.isActionModeShowed():
                                        return
                                except Exception:
                                    pass

                                done = False
                                for _ in range(BATCH_SIZE):
                                    i = state["index"]
                                    if i >= state.get("count", 0):
                                        def _attempt_load_more():
                                            try:
                                                if listView.getAdapter() != initial_adapter:
                                                    return
                                                actionBar3 = getattr(dlg, "actionBar", None)
                                                actionMode3 = actionBar3.getActionMode() if actionBar3 is not None else None
                                                if actionMode3 is None:
                                                    return
                                  
                                                try:
                                                    if not actionBar3.isActionModeShowed():
                                                        return
                                                except Exception:
                                                    pass
                                                try:
                                                    pos = max(0, state.get("count", 0) - 1)
                                                    listView.scrollToPosition(pos)
                                                except Exception:
                                                    pass
                                                def _check_new_count():
                                                    try:
                                                        new_count = adapter.getItemCount()
                                                        if new_count > state.get("count", 0):
                                                            state["count"] = new_count
                                                            state["load_attempts"] = 0
                                                            run_on_ui_thread(step)
                                                        else:
                                                            state["load_attempts"] = state.get("load_attempts", 0) + 1
                                                            if state["load_attempts"] < MAX_LOAD_ATTEMPTS:
                                                                run_on_ui_thread(_attempt_load_more, 200)
                                                            else:
                                                                try:
                                                                    update_counters = dlg.getClass().getDeclaredMethod("updateCounters", find_class("java.lang.Boolean").TYPE)
                                                                    update_counters.setAccessible(True)
                                                                    update_counters.invoke(dlg, True)
                                                                except Exception:
                                                                    pass
                                                    except Exception:
                                                        pass
                                                run_on_ui_thread(_check_new_count, 200)
                                            except Exception:
                                                pass
                                        _attempt_load_more()
                                        return
                                    try:
                                        item = adapter.getItem(i)
                                        state["index"] = i + 1
                                        if item is None:
                                            continue
                                        try:
                                            if not DialogInterface.isInstance(item):
                                                continue
                                        except Exception:
                                            if not str(item.getClass().getName()).startswith("org.telegram.tgnet.TLRPC$"):
                                                continue
                                        did = getattr(item, "id", None)
                                        if did is None:
                                            continue
                                        try:
                                            if selected.contains(LongClass.valueOf(did)):
                                                continue
                                        except Exception:
                                            try:
                                                if selected.contains(jlong(did)):
                                                    continue
                                            except Exception:
                                                pass
                                        holder = listView.findViewHolderForAdapterPosition(i)
                                        cellView = holder.itemView if holder is not None else None
                                        ShowOrUpdate.invoke(dlg, jlong(did), cellView)
                                    except Exception:
                                        pass

                                if done:
                                    try:
                                        update_counters = dlg.getClass().getDeclaredMethod("updateCounters", find_class("java.lang.Boolean").TYPE)
                                        update_counters.setAccessible(True)
                                        update_counters.invoke(dlg, True)
                                    except Exception:
                                        pass
                                else:
                                    run_on_ui_thread(step)
                            except Exception:
                                pass

                        run_on_ui_thread(step)
                    except Exception:
                        pass

            self.hook_method(CreateActionMode, _UT_AddSelectAllMenu(self))
            self.hook_method(OnItemClick, _UT_InterceptSelectAllClick(self), priority=10)
        except Exception as e:
            try:
                pass
            except Exception:
                pass

    def _perform_heavy_operations(self):
        try:
            start_time = time.time()
            timeout = 30
            
            if time.time() - start_time > timeout:
                return
                
            
            if time.time() - start_time > timeout:
                return
                
                    
        except Exception as e:
            pass



    def _create_general_settings(self):
        return [
            self.Quanta_switch("confirm_deeplinks", get_text("confirm_deeplinks", "Confirm Telegram Deep Links"), True, lambda v: self._apply_hooks(), link_alias="confirm_deeplinks"),
            self.Quanta_switch("confirm_ayugram_deeplinks", get_text("confirm_ayugram_deeplinks", "Confirm AyuGram Deep Links"), True, lambda v: self._apply_hooks(), link_alias="confirm_ayugram_deeplinks"),
            Divider(text=get_text("deeplink_confirmation_info", "These toggles add confirmation dialogs before opening deep links to prevent accidental navigation to external content.")),
            self.Quanta_switch("disable_auto_web_login", get_text("disable_auto_web_login", "Disable Auto Web Login"), False, lambda v: self._apply_hooks(), link_alias="disable_auto_web_login"),
            self.Quanta_switch("do_not_share_phone_number", get_text("do_not_share_phone_number", "Do Not Share My Phone Number"), False, lambda v: self._apply_hooks(), link_alias="do_not_share_phone_number"),
            self.Quanta_switch("prefer_common_groups_tab", get_text("prefer_common_groups_tab", "Prefer Common Groups Tab"), False, lambda v: self._apply_hooks(), link_alias="prefer_common_groups_tab"),
            Divider(text=get_text("prefer_common_groups_tab_info", "Automatically selects the Groups tab instead of Gifts tab in user profiles when both are available.")),
            self.Quanta_switch("hide_phone_number", get_text("hide_phone_number", "Hide Phone Number in Profiles"), False, lambda v: self._apply_hooks(), link_alias="hide_phone_number"),
            Divider(text=get_text("hide_phone_number_info", "This will hide the recipient's phone number from their profile.")),
            Header(text=get_text("navigation_controls", "Navigation controls")),
            self.Quanta_switch("prevent_swipe_while_editing", get_text("prevent_swipe_while_editing", "Prevent swipe back while editing"), True, lambda v: self._apply_hooks(), link_alias="prevent_swipe_while_editing"),
            self.Quanta_switch("prevent_swipe_while_typing", get_text("prevent_swipe_while_typing", "Prevent swipe back while typing"), True, lambda v: self._apply_hooks(), link_alias="prevent_swipe_while_typing"),
            self.Quanta_switch("disable_article_viewer_swipe", get_text("disable_article_viewer_swipe", "Disable ArticleViewer swipe to close"), False, lambda v: self._apply_hooks(), link_alias="disable_article_viewer_swipe"),
            self.Quanta_switch("prevent_webapp_swipe_down", get_text("prevent_webapp_swipe_down", "Prevent swipe down in webapp bots"), False, lambda v: self._apply_hooks(), link_alias="prevent_webapp_swipe_down"),
            Divider(text=get_text("navigation_controls_info", "This will prevent the Telegram navigation gestures to work from these scenarios.")),      
            self.Quanta_switch("fab_settings_shortcut", get_text("fab_settings_shortcut", "FAB Shortcut"), False, lambda v: self._apply_hooks(), link_alias="fab_settings_shortcut"),
            self.Quanta_selector("fab_action_selector", get_text("fab_action_selector", "Action"), [get_text("fab_action_uitweaks_settings", "UiTweaks Settings"), get_text("fab_action_archived_chats", "Archived Chats")], 0, lambda v: self._apply_hooks(), link_alias="fab_action_selector") if self.get_setting("fab_settings_shortcut", False) else None,
            Divider(),
            self.Quanta_switch("hide_birthday_alert", get_text("hide_birthday_alert", "Hide Birthday Alert"), False, lambda v: self._apply_hooks(), link_alias="hide_birthday_alert"),
            Divider(text=get_text("hide_birthday_alert_info", "Hides the birthday setup suggestion that appears in the chat list.")),
            self.Quanta_switch("enable_select_all_media", get_text("enable_select_all_media", "Select All Media Button"), True, lambda v: self._apply_hooks(), link_alias="enable_select_all_media"),
            self.Quanta_switch("enable_music_speed_control", get_text("enable_music_speed_control", "Music Speed Control"), False, lambda v: self._apply_hooks(), link_alias="enable_music_speed_control"),
            Divider(text=get_text("music_speed_control_info", "Enable playback speed control for all music files regardless of duration.")) if self.get_setting("enable_music_speed_control", False) else None,

        ]

    def _create_miscellaneous_settings(self):
        return [ 
            self.Quanta_switch("enable_message_preview_enhancement", get_text("message_preview_send_button", "Share media from link preview"), False, lambda v: self._apply_hooks(), link_alias="enable_message_preview_enhancement"),
            self.Quanta_switch("enable_code_formatting", get_text("code_formatting_menu", "Code & Mention Formatting"), False, lambda v: self._apply_hooks(), link_alias="enable_code_formatting"),
            self.Quanta_switch("enable_sender_select_enhancement", get_text("sender_select_improvements", "Send message as menu improvements"), False, lambda v: self._apply_hooks(), link_alias="enable_sender_select_enhancement"),
            Divider(text=get_text("sender_select_subtext", "Show personal account in \"send message as\" menu where you are the owner of the group")),
            self.Quanta_switch("enable_select_all_dialogs", get_text("select_all_dialogs_menu", "Select All Chats"), False, lambda v: self._apply_hooks(), link_alias="enable_select_all_dialogs"),
            self.Quanta_switch("enable_gif_spoiler", get_text("gif_spoiler_caption", "GIF Spoiler & Caption"), False, lambda v: self._apply_hooks(), link_alias="enable_gif_spoiler"),
            self.Quanta_switch("enable_swipe_disable", get_text("disable_swipe_gestures", "Swipe gesture menu improvements"), False, lambda v: self._apply_hooks(), link_alias="enable_swipe_disable"),
            Divider(text=get_text("disable_swipe_subtext", "Add disable option in Telegrams \"Chat list swipe gesture\" menu")),
            self.Quanta_switch("enable_share_sheet_folders", get_text("add_folders_to_share_sheet", "Folders in direct share sheet"), False, lambda v: self._apply_hooks(), link_alias="enable_share_sheet_folders"),
            self.Quanta_switch("enable_account_visibility", get_text("account_visibility", "Account Visibility"), False, lambda v: self._apply_hooks(), link_alias="enable_account_visibility"),
            Divider(text=get_text("account_visibility_subtext", "Hide/show accounts by long-pressing theme button")),
            self.Quanta_switch("enable_non_clickable_preview", get_text("non_clickable_preview", "Non-Clickable Chat Preview"), False, lambda v: self._apply_hooks(), link_alias="enable_non_clickable_preview"),
            self.Quanta_switch("enable_add_to_folder_all_tabs", get_text("add_to_folder_all_tabs", "Add to Folder in All Tabs"), False, lambda v: self._apply_hooks(), link_alias="enable_add_to_folder_all_tabs"),
            Divider(text=get_text("add_to_folder_all_tabs_subtext", "Enables 'Add to folder' option in all folder tabs, not just the All chats tab")),
            self.Quanta_switch("enable_contact_status_in_profile", get_text("contact_status_in_profile", "Mutual Contact in Profile"), False, lambda v: self._apply_hooks(), link_alias="enable_contact_status_in_profile"),
            self.Quanta_switch("enable_safe_mode", get_text("safe_mode", "Safe Mode"), False, lambda v: self._apply_hooks(), link_alias="enable_safe_mode"),
            Divider(text=get_text("safe_mode_subtext", "Press volume down 5 times quickly to enable plugin safe mode ~ In Safe Mode, all plugins are inactive. This allows you to safely find and disable a problematic plugin.")),
            self.Quanta_switch("enable_search_by_user_id", get_text("search_by_user_id", "Search by User ID"), False, lambda v: self._apply_hooks(), link_alias="enable_search_by_user_id"),
            self.Quanta_switch("enable_ai_role_limit", get_text("ai_role_limit", "AI Role Limit Increaser"), False, lambda v: self._apply_hooks(), link_alias="enable_ai_role_limit"),
            self.Quanta_switch("enable_sleep_timer", get_text("sleep_timer", "Music Sleep Timer"), False, lambda v: self._apply_hooks(), link_alias="enable_sleep_timer"),
        ]

    def _create_appearance_settings(self):
        settings = []
        
        settings.extend([
            Header(text=get_text("hide_elements", "Hide elements")),
            self.Quanta_switch("hide_bot_open", get_text("hide_bot_open", "Bot 'Open' button in chat list"), False, lambda v: self._apply_hooks(), link_alias="hide_bot_open"),
            self.Quanta_switch("hide_hd_icon", get_text("hide_hd_icon", "HD icon in media picker"), False, lambda v: self._apply_hooks(), link_alias="hide_hd_icon"),
            Divider(text=get_text("hide_hd_icon_info", "This will only remove the HD icon from the media picker. It will not affect the quality of the media.")),
        ])
        
        settings.extend([
            self.Quanta_switch("always_show_download_manager", get_text("always_show_download_manager", "Always Show Download Manager"), False, lambda v: self._apply_hooks(), link_alias="always_show_download_manager"),
            self.Quanta_switch("always_show_proxy_button", get_text("always_show_proxy_button", "Always Show Proxy Button"), False, lambda v: self._apply_hooks(), link_alias="always_show_proxy_button"),
            Divider(text=get_text("menu_visibility_info", "This will force the buttons to always show in the action bar.")),
        ])
        
        settings.extend([
            self.Quanta_switch("unread_badge_on_back_button", get_text("unread_badge_on_back_button", "Unread Badge on Back Button"), False, lambda v: self._apply_hooks(), link_alias="unread_badge_on_back_button"),
        ])
        
        settings.extend([
            self.Quanta_switch("enable_recent_chats_menu", get_text("enable_recent_chats_menu", "Enable Recent Chats Menu"), True, lambda v: self._apply_hooks(), link_alias="enable_recent_chats_menu"),
            Divider(text=get_text("recent_chats_menu_info", "Shows recent chats when long-pressing the drawer icon in chat list. Stores up to 20 chats.")),
            self.Quanta_switch("quick_access_gift_market", get_text("quick_access_gift_market", "Quick Access to Gift Market"), False, lambda v: self._apply_hooks(), link_alias="quick_access_gift_market"),
        ])
        
        settings.extend([
            Header(text=get_text("manage_folders", "Manage Folders")),
            self.Quanta_switch("unread_chat_count", get_text("unread_chat_count", "Show Unread Chat Count"), False, lambda v: self._apply_hooks(), link_alias="unread_chat_count"),
            self.Quanta_switch("unread_message_count", get_text("unread_message_count", "Show Unread Message Count"), False, lambda v: self._apply_hooks(), link_alias="unread_message_count"),
            self.Quanta_switch("exclude_archived_from_count", get_text("exclude_archived_from_count", "Exclude Archived Chats from Count"), False, lambda v: self._apply_hooks(), link_alias="exclude_archived_from_count"),
            Divider(text=get_text("unread_count_info", "Adjust how unread counters behave in folders. When both are enabled, only non-muted chats are counted.")),
            self.Quanta_switch("hidefolders_enabled", get_text("hide_folders", "Hide Folders"), False, lambda v: self._toggle_hide_folders(v), link_alias="hide_folders"),
            self.Quanta_text(
                text=get_text("select_folders", "Select Folders"),
                on_click=lambda v: self._show_folder_selector(),
                link_alias="select_folders"
            ) if self.get_setting("hidefolders_enabled", False) else None,
            Divider(text=get_text("hide_folders_info", "Hide specific folders from the folder list. Select which folders to hide.")) if self.get_setting("hidefolders_enabled", False) else None,
        ])
        
        
        
        return settings

    def _create_chats_settings(self):
        settings = []
        
        settings.extend([
            Header(text=get_text("hide_chat_controls", "Hide Chat Controls")),
            self.Quanta_switch("hide_bot_button", get_text("hide_bot_button", "Hide Bot Button in Input Field"), False, lambda v: self._apply_hooks(), link_alias="hide_bot_button"),
        ])
        
        settings.extend([
            self.Quanta_switch("hide_archived_chats", get_text("hide_archived_chats", "Hide Archived Chats"), False, lambda v: self._apply_hooks(), link_alias="hide_archived_chats"),
            self.Quanta_switch("hide_archived_from_drawer", get_text("hide_archived_from_drawer", "Hide from drawer"), False, lambda v: self._apply_hooks(), link_alias="hide_archived_from_drawer") if self.get_setting("hide_archived_chats", False) else None,
            Divider(text=get_text("hide_archived_chats_info", "This will remove archived chats cell from the chat list by filtering them out of the dialogs query.")),
            self.Quanta_switch("hide_star_reaction", get_text("hide_star_reaction", "Hide Star Reaction"), False, lambda v: self._apply_hooks(), link_alias="hide_star_reaction"),
            self.Quanta_text(
                text=get_text("star_reaction_hide_location", "Select from where"),
                on_click=lambda v: self._show_star_reaction_selector(),
                link_alias="star_reaction_hide_location"
            ) if self.get_setting("hide_star_reaction", False) else None,
        ])
        
        settings.extend([
            self.Quanta_switch("enable_confirmation_settings", get_text("enable_confirmation_settings", "Enable Confirmation Settings"), True, lambda v: self._apply_hooks(), link_alias="enable_confirmation_settings"),
            self.Quanta_text(
                text=get_text("confirmation_settings", "Choose actions"),
                on_click=lambda v: show_confirmation_selector(),
                link_alias="confirmation_settings"
            ) if self.get_setting("enable_confirmation_settings", True) else None,
        ])
        
        settings.extend([
            Header(text=get_text("chat_features", "Chat Features")),
            self.Quanta_switch("dont_auto_play_enabled", get_text("dont_auto_play_enabled", "Don't Auto Play Next"), False, lambda v: self._apply_hooks(), link_alias="dont_auto_play_enabled"),
            self.Quanta_text(
                text=get_text("dont_auto_play_types", "Message Types"),
                on_click=lambda v: self._show_dont_auto_play_selector(),
                link_alias="dont_auto_play_types"
            ) if self.get_setting("dont_auto_play_enabled", False) else None,
            Divider(text=get_text("dont_auto_play_info", "Prevents automatic playback of the next voice or video message in a chat, giving you control over when media plays.")) if self.get_setting("dont_auto_play_enabled", False) else None,
            self.Quanta_switch("progress_timestamp_enabled", get_text("progress_timestamp_enabled", "Progress Timestamp"), True, lambda v: self._apply_hooks(), link_alias="progress_timestamp_enabled"),
            self.Quanta_text(
                text=get_text("progress_timestamp_types", "Message Types"),
                on_click=lambda v: self._show_progress_timestamp_selector(),
                link_alias="progress_timestamp_types"
            ) if self.get_setting("progress_timestamp_enabled", True) else None,
            Divider(text=get_text("progress_timestamp_info", "Shows the current playback time and total duration on voice and video messages for better media control.")) if self.get_setting("progress_timestamp_enabled", True) else None,
            self.Quanta_switch("enable_goto_message", get_text("enable_goto_message", "Search by Message ID"), False, lambda v: self._apply_hooks(), link_alias="enable_goto_message"),
            self.Quanta_switch("enable_reply_private_chat", get_text("enable_reply_private_chat", "Enable Reply in Private Chat"), False, lambda v: self._update_reply_private_chat_menu_item(), link_alias="enable_reply_private_chat"),
            self.Quanta_switch("enable_delete_with_duration", get_text("enable_delete_with_duration", "Delete with Duration Selection"), False, lambda v: self._apply_delete_with_duration_hooks(), link_alias="enable_delete_with_duration"),
            Divider(text=get_text("delete_with_duration_info", "Adds duration selection when banning/restricting users after deleting their messages.")) if self.get_setting("enable_delete_with_duration", False) else None,
            self.Quanta_switch("send_comments_after_forward", get_text("send_comments_after_forward", "Send Comments After Forward"), False, lambda v: self._apply_hooks(), link_alias="send_comments_after_forward"),
            self.Quanta_switch("enable_no_quote_forward", get_text("enable_no_quote_forward", "Enable No-Quote Forward"), True, lambda v: self._update_no_quote_forward_menu_item(), link_alias="enable_no_quote_forward"),
            Divider(text=get_text("context_menu_info", "These will add items to the context menu that appears when you tap on any message.")),
            self.Quanta_switch("typing_instead_sticker", get_text("typing_instead_sticker", "Typing Instead of Choosing Sticker"), False, lambda v: self._apply_hooks(), link_alias="typing_instead_sticker"),
            self.Quanta_switch("always_visible_schedule_button", get_text("always_visible_schedule_button", "Always Visible Schedule Button"), False, lambda v: self._apply_hooks(), link_alias="always_visible_schedule_button"),
        ])
        
        settings.extend([
            self.Quanta_switch("enable_ai_summarize", get_text("enable_ai_summarize", "Summarize Chat"), False, lambda v: self._apply_hooks(), link_alias="enable_ai_summarize"),
        ])
        
        settings.extend([
            self.Quanta_switch("disable_topics_swipe", get_text("disable_topics_swipe", "Disable Topics Swipe to Hide"), False, lambda v: self._apply_hooks(), link_alias="disable_topics_swipe"),
            self.Quanta_switch("enable_adaptive_audio_length", get_text("enable_adaptive_audio_length", "Adaptive Audio Message Length"), False, lambda v: self._apply_hooks(), link_alias="enable_adaptive_audio_length"),
            Divider(text=get_text("adaptive_audio_length_info", "The audio message bubble length will depend on the recording duration and automatically adjust to the screen width.")) if self.get_setting("enable_adaptive_audio_length", False) else None,
        ])
        
        settings.extend([
            self.Quanta_switch("enable_custom_saved_messages", get_text("enable_custom_saved_messages", "Custom Saved Messages"), False, lambda v: self._apply_hooks(), link_alias="enable_custom_saved_messages"),
        ])
        
        if self.get_setting("enable_custom_saved_messages", False):
            settings.append(
                Text(
                    text=get_text("selected_chat", "Selected Chat") + f": {self._get_custom_saved_chat_name()}",
                    on_click=lambda v: self._select_custom_saved_chat(),
                    link_alias="select_custom_saved_chat"
                )
            )
        
        return settings

    def _create_others_settings(self):
        settings = []
        
        show_branch_selector = self.get_setting("show_branch_selector", False)
        
        settings.extend([
            Header(text=get_text("support", "Support Development")),
            Text(text=get_text("boosty", "Boosty"), icon="boosty_icon", on_click=lambda v: self._open_boosty()),
            Text(text=get_text("ton_keeper", "Ton Keeper"), icon="ton_icon", on_click=lambda v: self._copy_ton_address()),
            Text(text=get_text("know_more", "Know more"), icon="msg_info", accent=True, on_click=lambda v: self._show_donation_info()),
            Divider(text=get_text("another_services", "If the provided services are not available in your country, you can contact me via [direct message](https://t.me/luvztroy)")),

            Text(text=get_text("export_settings", "Export Settings"), icon="msg_photo_rotate_solar", on_click=lambda v: self._export_settings()),
            
            Text(text=get_text("reset_shared_preferences", "Reset Shared Preferences"), icon="msg_delete", red=True, on_click=lambda v: self._reset_all_preferences()),
            Divider(text=get_text("reset_preferences_description", "Reset all application settings including themes, language, notifications, and user configurations. This action cannot be undone.")),
        ])
        
        if show_branch_selector:
            settings.extend([
                Header(text=get_text("auto_update", "Auto Update")),
                self.Quanta_selector("update_branch", get_text("update_branch", "Update Branch"), [get_text("branch_main", "Main"), get_text("branch_beta", "Beta")], 0, link_alias="update_branch"),
                self.Quanta_selector("localization_branch", get_text("localization_branch", "Localization Branch"), [get_text("branch_main", "Main"), get_text("branch_beta", "Beta")], 0, link_alias="localization_branch"),
                Divider(text=get_text("update_branch_info", "Select which branch to receive updates and download localization files from. Beta may contain experimental features and newer translations."))
            ])
        
        settings.extend([
            Header(text=get_text("links", "Links")),
            Text(text=get_text("channel", "Channel"), icon="msg_channel_solar", on_click=lambda v: self._open_channel()),
            Text(text=get_text("chats", "Chats"), icon="msg_groups_solar", on_click=lambda v: self._open_group()),
            Text(text=get_text("tips_and_tricks", "Tips and Tricks"), icon="menu_feature_reactions_solar", on_click=lambda v: self._open_tips()),
            Text(text=get_text("translate", "Translate"), icon="msg_translate_solar", on_click=lambda v: self._open_translation(), on_long_click=lambda v: self._toggle_branch_selector()),
        ])
        
        
        return settings

    def Quanta_switch(self, key, text, default=True, on_change=None, subtext=None, link_alias=None):
        try:
            return Switch(key=key, text=text, link_alias=link_alias, default=default, on_change=on_change, subtext=subtext) if link_alias else Switch(key=key, text=text, default=default, on_change=on_change, subtext=subtext)
        except Exception:
            return Switch(key=key, text=text, default=default, on_change=on_change, subtext=subtext) if subtext else Switch(key=key, text=text, default=default)

    def Quanta_selector(self, key, text, items, default=0, on_change=None, subtext=None, link_alias=None):
        try:
            return Selector(key=key, text=text, items=items, link_alias=link_alias, default=default, on_change=on_change, subtext=subtext) if link_alias else Selector(key=key, text=text, items=items, default=default, on_change=on_change, subtext=subtext)
        except Exception:
            return Selector(key=key, text=text, items=items, default=default, on_change=on_change, subtext=subtext) if subtext else Selector(key=key, text=text, items=items, default=default)

    def Quanta_text(self, text, icon=None, link_alias=None, create_sub_fragment=None, on_click=None, accent=None):
        try:
            return Text(text=text, icon=icon, link_alias=link_alias, create_sub_fragment=create_sub_fragment, on_click=on_click, accent=accent) if link_alias else Text(text=text, icon=icon, create_sub_fragment=create_sub_fragment, on_click=on_click, accent=accent)
        except Exception:
            return Text(text=text, icon=icon, create_sub_fragment=create_sub_fragment, on_click=on_click, accent=accent) if any([icon, create_sub_fragment, on_click, accent]) else Text(text=text, icon=icon)

    def create_settings(self):
        return [
            Header(text=get_text("uitweaks_settings", "Categories")),
            
            self.Quanta_text(
                text=get_text("general", "General"),
                icon="msg_media_solar",
                link_alias="general",
                create_sub_fragment=self._create_general_settings
            ),
            
            self.Quanta_text(
                text=get_text("appearance", "Appearance"), 
                icon="msg_theme",
                link_alias="appearance",
                create_sub_fragment=self._create_appearance_settings   
            ),
            
            self.Quanta_text(
                text=get_text("chats", "Chats"),
                icon="msg_msgbubble3_solar",
                link_alias="chats",
                create_sub_fragment=self._create_chats_settings 
            ),
            
            self.Quanta_text(
                text=get_text("miscellaneous", "Miscellaneous"),
                icon="msg_reactions_solar",
                link_alias="miscellaneous",
                create_sub_fragment=self._create_miscellaneous_settings
            ),

            self.Quanta_text(
                text=get_text("others", "Others"),
                icon="msg_fave_solar",
                link_alias="others",
                create_sub_fragment=self._create_others_settings   
            ),
            
            
            Text(
                text=get_text("performance_warning", "Performance Warning"),
                icon="msg_info_solar",
                accent=True,
                on_click=lambda view: self._show_performance_warning()
            ),
            
            Divider(),
            Divider(text=get_text("thank_you_message", "Thank you for using UiTweaks! Feedback?\nJoin: @QuantaPlugins"))
        ]

    def _collect_all_settings_with_values(self):
        settings = {}
        
        def extract_settings(items):
            for item in items or []:
                if hasattr(item, 'key') and item.key:
                    settings[item.key] = self.get_setting(item.key, getattr(item, 'default', None))
                if hasattr(item, 'create_sub_fragment'):
                    try:
                        extract_settings(item.create_sub_fragment())
                    except:
                        pass
        
        extract_settings(self.create_settings())
        
        if hasattr(self, '_multi_selector_settings'):
            for key in self._multi_selector_settings:
                if key not in settings:
                    settings[key] = self.get_setting(key, False)
        
        return settings
    
    def _export_settings(self):
        export_plugin_settings("ui_tweaks", "UiTweaks", __version__)
    
    def _toggle_branch_selector(self):
        current = self.get_setting("show_branch_selector", False)
        self.set_setting("show_branch_selector", not current, reload_settings=True)
        
        if not current:
            BulletinHelper.show_success(get_text("branch_selector_enabled", "Branch selector enabled!"))
        else:
            BulletinHelper.show_info(get_text("branch_selector_disabled", "Branch selector hidden"))
    
    def _setup_quanta_file_hook(self):
        try:
            from java.lang import Class
            from java import jclass
            AndroidUtilitiesClass = Class.forName("org.telegram.messenger.AndroidUtilities")
            MessageObjectClass = Class.forName("org.telegram.messenger.MessageObject")
            ActivityClass = Class.forName("android.app.Activity")
            ResourcesProviderClass = Class.forName("org.telegram.ui.ActionBar.Theme$ResourcesProvider")
            open_for_view = AndroidUtilitiesClass.getDeclaredMethod(
                "openForView",
                MessageObjectClass,
                ActivityClass,
                ResourcesProviderClass,
                jclass("java.lang.Boolean").TYPE,
            )
            open_for_view.setAccessible(True)
            class OpenForViewHook:
                def __init__(hook_self):
                    hook_self.plugin = self
                def before_hooked_method(hook_self, param):
                    try:
                        if len(param.args) >= 1:
                            msg = param.args[0]
                            if msg and hasattr(msg, "getDocumentName"):
                                name = msg.getDocumentName()
                                if name and str(name).lower().endswith(".quanta"):
                                    hook_self.plugin._show_import_bottom_sheet(msg)
                                    param.setResult(False)
                    except Exception as e:
                        pass
            self.hook_method(open_for_view, OpenForViewHook())
        except Exception as e:
            pass
    
    def _show_import_bottom_sheet(self, message_object):
        def show_sheet():
            try:
                from com.exteragram.messenger.utils import ChatUtils
                from file_utils import read_file
                
                changes_count = 0
                try:
                    file_path = ChatUtils.getInstance().getPathToMessage(message_object)
                    if file_path:
                        content = read_file(file_path)
                        if content:
                            backup_data = json.loads(content)
                            
                            if backup_data.get("plugin") != "UiTweaks":
                                BulletinHelper.show_error(get_text("not_uitweaks_settings_file", "Not a UiTweaks settings file"))
                                return
                            
                            settings = backup_data.get("settings", {})
                            controller = PluginsController.getInstance()
                            engine = controller.getPluginEngine("ui_tweaks")
                            
                            if engine and settings:
                                current_settings = engine.getAllPluginSettings("ui_tweaks")
                                for key, value in settings.items():
                                    current_value = current_settings.get(key) if current_settings else None
                                    if current_value != value:
                                        changes_count += 1
                except Exception:
                    changes_count = 1
                
                if changes_count == 0:
                    BulletinHelper.show_error(get_text("settings_same_as_current", "It looks like the settings are the same as the current ones."))
                    return
                
                subtitle = get_text("changes_will_be_applied_singular", "{count} change will be applied to the current settings.").format(count=changes_count) if changes_count == 1 else get_text("changes_will_be_applied_plural", "{count} changes will be applied to the current settings.").format(count=changes_count)
                
                def on_import_click():
                    self._import_from_message(message_object)
                
                showupdatebottomsheet(
                    title=get_text("apply_settings_confirmation", "Are you sure you want to apply these settings?"),
                    subtitle=subtitle,
                    button_text=get_text("yes_apply", "Yes, apply"),
                    button2_text=get_text("no_leave_as_is", "No, leave as is"),
                    show_close_button=False,
                    raw_resource=R_tg.raw.email_check_inbox,
                    on_button_click=on_import_click,
                    on_button2_click=lambda: None
                )
                
            except Exception as e:
                pass
        
        run_on_ui_thread(show_sheet)
    
    def _import_from_message(self, message_object):
        try:
            from com.exteragram.messenger.utils import ChatUtils
            from file_utils import read_file
            
            file_path = ChatUtils.getInstance().getPathToMessage(message_object)
            if not file_path:
                return
            
            content = read_file(file_path)
            if not content:
                return
            
            backup_data = json.loads(content)

            if backup_data.get("plugin") != "UiTweaks":
                BulletinHelper.show_error(get_text("not_uitweaks_settings_file", "Not a UiTweaks settings file"))
                return
            
            settings = backup_data.get("settings", {})
            controller = PluginsController.getInstance()
            engine = controller.getPluginEngine("ui_tweaks")
            imported_count = 0
            
            if engine and settings:
                for key, value in settings.items():
                    try:
                        engine.setPluginSetting("ui_tweaks", key, value)
                        imported_count += 1
                    except Exception:
                        pass
                
                controller.loadPluginSettings("ui_tweaks")
            
            BulletinHelper.show_success(get_text("imported_settings_count", "Imported {count} settings").format(count=imported_count))
            
        except Exception as e:
            BulletinHelper.show_error(get_text("failed_to_import_settings", "Failed to import settings"))
    
    def _reset_all_preferences(self):
        fragment = get_last_fragment()
        if not fragment:
            return

        builder = AlertDialogBuilder(fragment.getParentActivity())
        builder.set_title(get_text("warning", "Warning"))
        builder.set_message(get_text("reset_confirmation", "Are you sure you want to reset?"))
        builder.set_positive_button(get_text("reset_all", "Reset All"), lambda bld, which: (self._perform_reset(), bld.dismiss()))
        builder.set_negative_button(get_text("cancel", "Cancel"), lambda bld, which: bld.dismiss())
        builder.show()

    def _perform_reset(self):
        try:
            from org.telegram.messenger import UserConfig
            account = UserConfig.selectedAccount
            
            settings = jclass("org.telegram.messenger.MessagesController").getInstance(account).getMainSettings()
            count = settings.getAll().size()
            log(f"Total preferences found: {count}")
            
            def perform_reset():
                settings.edit().clear().apply()
                jclass("org.telegram.messenger.BirthdayController").getInstance(account).check()
                log(f"Successfully cleared {count} preferences")
                from quantahut import restart_app
                restart_app()
            
            def undo_reset():
                log("Reset operation cancelled by user")
            
            BulletinHelper.show_undo(
                get_text("shared_preferences_reset_success", "Reset {count} preferences? App will restart.").format(count=count),
                on_undo=undo_reset,
                on_action=perform_reset,
                fragment=get_last_fragment()
            )
            
        except Exception as e:
            log(f"Reset failed: {str(e)}")
            BulletinHelper.show_error(get_text("reset_failed", "Reset failed: {error}").format(error=str(e)))
    
    def _restart_after_bulletin(self):
        from quantahut import restart_app
        restart_app()
    
    def _open_boosty(self):
        from android.content import Intent
        from android.net import Uri
        
        intent = Intent(Intent.ACTION_VIEW)
        intent.setData(Uri.parse("https://boosty.to/luvztroy/donate"))
        get_last_fragment().getParentActivity().startActivity(intent)
    
    def _copy_ton_address(self):
        clipboard = get_last_fragment().getParentActivity().getSystemService(Context.CLIPBOARD_SERVICE)
        clipboard.setPrimaryClip(ClipData.newPlainText("TON Address", "UQAZFPWF06gVehwcXlYDj3AWgx6i0x0VwUZOOUJ0A_gTcshN"))
        BulletinHelper.show_copied_to_clipboard(get_text("ton_address_copied", "TON address copied to clipboard"))
    
    def _open_channel(self):
        try:
            from client_utils import get_last_fragment
            from java import jclass
            fragment = get_last_fragment()
            if fragment:
                MessagesController = jclass("org.telegram.messenger.MessagesController")
                messages_controller = MessagesController.getInstance(0)
                messages_controller.openByUserName("QuantaPlugins", fragment, 1)
        except Exception as e:
            self.log(f"Error opening channel: {e}")
    
    def _open_group(self):
        try:
            from client_utils import get_last_fragment
            from java import jclass
            fragment = get_last_fragment()
            if fragment:
                MessagesController = jclass("org.telegram.messenger.MessagesController")
                messages_controller = MessagesController.getInstance(0)
                messages_controller.openByUserName("QuantaPlayground", fragment, 1)
        except Exception as e:
            self.log(f"Error opening group: {e}")
    
    def _open_tips(self):
        from android.content import Intent
        from android.net import Uri
        intent = Intent(Intent.ACTION_VIEW, Uri.parse("https://t.me/QuantaTips"))
        get_last_fragment().getParentActivity().startActivity(intent)
    
    def _open_translation(self):
        from android.content import Intent
        from android.net import Uri
        intent = Intent(Intent.ACTION_VIEW, Uri.parse("https://github.com/luvztroy/UiTweaks"))
        get_last_fragment().getParentActivity().startActivity(intent)
    
    def _show_donation_info(self):
        showupdatebottomsheet(
            title=get_text("donation_info_title", "About Donations"),
            subtitle=get_text("donation_info_subtitle", "Supporting UiTweaks Development"),
            description=get_text("donation_info_description", 
                "Donations are a way to appreciate the effort behind this Plugin. They dont grant special privileges, though you may request a feature as thanks."),
            github_url=None,
            plugin_name="UiTweaks_DonationInfo",
            sticker_pack="luvztroyIcons",
            sticker_index=15,
            button_text=get_text("understood", "Understood"),
            bottom_text=get_text("donation_info_footer", "Thank you for considering supporting the development of UiTweaks!"),
            show_language_selector=False,
            show_user_avatar=False,
            description_centered=True
        )
    
    def on_app_event(self, event_type: AppEvent):
        if event_type == AppEvent.START:
            if self.get_setting("hidefolders_enabled", False):
                try:
                    self._hook_folder_visibility()
                    
                    from android.os import Handler, Looper
                    from android_utils import R
                    
                    def post_notification():
                        try:
                            NotificationCenter.getInstance(UserConfig.selectedAccount).postNotificationName(
                                NotificationCenter.dialogFiltersUpdated
                            )
                        except Exception:
                            pass
                    
                    Handler(Looper.getMainLooper()).postDelayed(R(post_notification), 100)
                except Exception:
                    pass
        
        elif event_type == AppEvent.RESUME:
            if self.get_setting("hide_archived_chats", False) and self.get_setting("hide_archived_from_drawer", False):
                try:
                    from android.os import Handler, Looper
                    from android_utils import R
                    
                    def refresh_drawer():
                        try:
                            from org.telegram.ui import LaunchActivity
                            if (hasattr(LaunchActivity, 'instance') and LaunchActivity.instance):
                                drawer_adapter = get_private_field(LaunchActivity.instance, "drawerLayoutAdapter")
                                if drawer_adapter and hasattr(drawer_adapter, 'notifyDataSetChanged'):
                                    drawer_adapter.notifyDataSetChanged()
                        except Exception:
                            pass
                    
                    Handler(Looper.getMainLooper()).postDelayed(R(refresh_drawer), 500)
                except Exception:
                    pass

    def _check_for_updates_on_load(self):
        def delayed_check():
            time.sleep(5)
            
            try:
                if hasattr(quantahut, 'QuantaHut'):
                    qh_instance = quantahut.QuantaHut.instance if hasattr(quantahut.QuantaHut, 'instance') else None
                    if qh_instance and hasattr(qh_instance, 'update_available') and qh_instance.update_available:
                        self.log("QuantaHut update is available, skipping UiTweaks update check")
                        return
            except Exception:
                pass
            
            self.log("Auto-checking for UiTweaks updates...")
            self._check_for_updates(show_on_load=True)
        
        thread = threading.Thread(target=delayed_check)
        thread.daemon = True
        thread.start()
    
    def _check_for_updates(self, show_on_load=False):
        if self.checking_update:
            self.log("Already checking for updates...")
            return
        
        self.checking_update = True
        
        def check_thread():
            try:
                self.log("Checking for UiTweaks updates from GitHub...")
                
                branch_index = self.get_setting("update_branch", 0)
                branch = "main" if branch_index == 0 else "Beta"
                
                version_url = f"https://raw.githubusercontent.com/luvztroy/Auto-Update/refs/heads/{branch}/changelog.json"
                self.log(f"Fetching from {branch} branch: {version_url}")
                
                with urllib.request.urlopen(version_url, timeout=10) as response:
                    if response.getcode() != 200:
                        raise Exception(f"HTTP {response.getcode()}")
                    
                    version_data = json.loads(response.read().decode('utf-8'))
                    
                    self.latest_version = version_data.get("version", "0.0.0")
                    self.changelog = version_data.get("changelog_text", "No changelog available")
                    sticker_pack = version_data.get("sticker_pack")
                    sticker_index = version_data.get("sticker_index")
                    sticker_circle = version_data.get("sticker_circle", False)
                    sticker_size = version_data.get("sticker_size", 160)
                    
                    self.download_url = f"https://raw.githubusercontent.com/luvztroy/Auto-Update/refs/heads/{branch}/UiTweaks.plugin"
                    
                    self.log(f"Latest version: {self.latest_version}")
                    self.log(f"Current version: {__version__}")
                    
                    if self._is_newer_version(self.latest_version, __version__):
                        self.update_available = True
                        self.log("UiTweaks update available!")
                        
                        if show_on_load:
                            run_on_ui_thread(lambda: self._show_update_bottom_sheet(
                                sticker_pack, sticker_index, sticker_circle, sticker_size
                            ))
                    else:
                        self.update_available = False
                        self.log("UiTweaks is up to date")
                
            except Exception as e:
                self.log(f"Error checking UiTweaks updates: {e}")
            finally:
                self.checking_update = False
        
        thread = threading.Thread(target=check_thread)
        thread.daemon = True
        thread.start()
    
    def _compare_versions(self, version1: str, version2: str) -> int:
        try:
            def clean_version(version):
                version = version.split('-')[0].split(' ')[0].strip()
                return version
            
            v1_clean = clean_version(version1)
            v2_clean = clean_version(version2)
            
            v1_parts = [int(x) for x in v1_clean.split('.')]
            v2_parts = [int(x) for x in v2_clean.split('.')]
            
            max_len = max(len(v1_parts), len(v2_parts))
            v1_parts += [0] * (max_len - len(v1_parts))
            v2_parts += [0] * (max_len - len(v2_parts))
            
            if v1_parts > v2_parts:
                return 1
            elif v1_parts < v2_parts:
                return -1
            else:
                return 0
        except Exception as e:
            self.log(f"Error comparing versions: {e}")
            return 0
    
    def _is_newer_version(self, latest: str, current: str) -> bool:
        return self._compare_versions(latest, current) > 0
    
    def _show_update_bottom_sheet(self, sticker_pack, sticker_index, sticker_circle, sticker_size):
        if not self.update_available:
            return
        
        self.log("Showing UiTweaks update bottom sheet")
        
        try:
            showupdatebottomsheet(
                title=f"UiTweaks Update: v{self.latest_version}",
                subtitle=f"Current version: {__version__}",
                description=self.changelog,
                sticker_pack=sticker_pack,
                sticker_index=sticker_index,
                sticker_circle=sticker_circle,
                sticker_size=sticker_size,
                button_text="Update Now",
                show_close_button=False,
                on_button_click=self._download_and_install_update
            )
        except Exception as e:
            self.log(f"Error showing UiTweaks update sheet: {e}")
    
    def _download_and_install_update(self):
        self.log("Starting UiTweaks update download...")
        BulletinHelper.show_info("Downloading UiTweaks update...")
        
        def download_thread():
            try:
                self.log(f"Downloading from: {self.download_url}")
                
                with urllib.request.urlopen(self.download_url, timeout=30) as response:
                    if response.getcode() != 200:
                        raise Exception(f"HTTP {response.getcode()}")
                    
                    plugin_content = response.read()
                    self.log(f"Downloaded {len(plugin_content)} bytes")
                
                from com.exteragram.messenger.plugins import PluginsController
                from org.telegram.messenger import ApplicationLoader
                
                app_context = ApplicationLoader.applicationContext
                files_dir = app_context.getFilesDir()
                plugins_dir = os.path.join(str(files_dir), "plugins")
                
                plugin_file = os.path.join(plugins_dir, "ui_tweaks.py")
                
                self.log(f"Installing to: {plugin_file}")
                
                with open(plugin_file, 'wb') as f:
                    f.write(plugin_content)
                
                self.log("UiTweaks updated successfully!")
                
                try:
                    from org.telegram.messenger import LocaleController
                    current_language = LocaleController.getInstance().getCurrentLocaleInfo().getLangCode()
                    if current_language != "en":
                        quantahut.github_localization.download_localization("UiTweaks", current_language)
                        self.log(f"Updated localization for {current_language}")
                except Exception as loc_e:
                    self.log(f"Localization update failed (non-critical): {loc_e}")
                
                run_on_ui_thread(self._show_restart_prompt)
                
            except Exception as e:
                error_msg = f"UiTweaks update failed: {str(e)}"
                self.log(f"Error downloading update: {e}")
                run_on_ui_thread(lambda msg=error_msg: BulletinHelper.show_error(msg))
        
        thread = threading.Thread(target=download_thread)
        thread.daemon = True
        thread.start()
    
    def _show_restart_prompt(self):
        try:
            from quantahut import show_restart_bulletin
            show_restart_bulletin(
                message=get_text("restart_to_apply_uitweaks_update", "Restart app to apply UiTweaks update"),
                button_text=get_text("restart", "Restart")
            )
        except Exception as e:
            self.log(f"Error showing restart bulletin: {e}")

    def on_plugin_unload(self):
        self.memory_check_running = False
        
        for ref_attr in (
            "hook_dialogs_ref",
            "hook_dialogs_destroy_ref",
            "hook_dialog_cell_ref",
            "hook_photo_cell_ref",
            "hook_photo_cell_set_entry_ref",
            "hook_swipe_prevention_ref",
            "hook_star_reaction_menu_ref",
            "hook_star_reaction_visible_list_ref",
            "hook_star_reaction_gradient_ref",
            "hook_star_reaction_layout_draw_ref",
            "hook_link_confirmation_ref",
            "hook_article_viewer_ref",
            "hook_webapp_swipe_prevention_ref",
            "hook_download_manager_ref",
            "hook_proxy_button_ref",
            "hook_phone_number_ref",
            "hook_messages_controller_ref",
            "hook_update_bot_button_ref",
            "hook_voice_message_control_ref",
            "hook_voice_message_time_display_ref",
            "hook_video_message_control_ref",
            "hook_unread_badge_ref",
            "hook_back_button_draw_ref",
            "hook_forward_confirmation_ref",
            "hook_join_confirmation_ref",
            "hook_no_quote_create_buttons_ref",
            "hook_no_quote_update_bottom_panel_ref",
            "hook_send_typing_refs",
            "hook_gif_spoiler_ref",
            "hook_gif_dismiss_ref",
            "hook_process_external_url_ref",
            "hook_fill_action_mode_menu_ref",
            "hook_perform_menu_action_ref",
            "hook_recent_chats_activity_ref",
            "hook_recent_profile_activity_ref",
            "hook_recent_topics_fragment_ref",
            "hook_drawer_icon_ref",
            "hook_call_buttons_ref",
            "hook_group_voice_chat_icon_ref",
            "hook_message_preview_view_ref",
            "hook_browser_open_url_ref",
            "hook_disable_auto_web_login_ref",
            "hook_do_not_share_phone_number_ref",
            "hook_prefer_common_groups_tab_ref",
            "hook_non_clickable_dispatch_ref",
            "hook_non_clickable_present_ref",
            "hook_non_clickable_present_ref2",
            "hook_birthday_alert_ref",
            "hook_code_formatting_ref",
            "hook_sender_select_popup_ref",
            "hook_swipe_disable_ref",
            "hook_share_sheet_folders_ref",
            "hook_disable_topic_swipe_ref",
            "hook_account_visibility_drawer_ref",
            "hook_account_visibility_profile_ref",
            "contact_status_update_rows_hook",
            "contact_status_get_item_view_type_hook",
            "contact_status_create_view_holder_hook",
            "contact_status_bind_view_holder_hook",
            "safe_mode_hook_ref",
            "hook_folder_visibility_ref",
            "hook_search_by_user_id_ref",
            "hook_gift_drawer_reset_ref",
            "hook_gift_drawer_click_ref",
            "hook_gift_drawer_cell_ref",
            "hook_ai_summarize_create_view_ref",
            "hook_ai_summarize_item_click_ref",
            "delete_with_duration_fillitems_ref",
            "delete_with_duration_onclick_ref",
            "hook_ai_role_limit_constructor_ref",
            "hook_ai_role_limit_settext_ref",
            "hook_select_all_media_ref",
            "hook_always_visible_schedule_button_ref",
            "hook_sleep_timer_ref",
            "hook_adaptive_audio_ref",
            "hook_music_speed_control_ref",
            "hook_custom_saved_messages_ref",
        ):
            ref = getattr(self, ref_attr, None)
            if ref:
                if isinstance(ref, list):
                    for r in ref:
                        if r:
                            self.unhook_method(r)
                else:
                    self.unhook_method(ref)
                setattr(self, ref_attr, None)

        for ref_attr in ("hook_open_link_internally_ref",):
            ref = getattr(self, ref_attr, None)
            if ref:
                self.unhook_method(ref)
                setattr(self, ref_attr, None)
        
        if self.unhook_send_message:
            self.unhook_method(self.unhook_send_message)
            self.unhook_send_message = None
        if hasattr(self, 'unhook_deeplink') and self.unhook_deeplink:
            self.unhook_method(self.unhook_deeplink)
            self.unhook_deeplink = None
        if hasattr(self, 'unhook_set_command') and self.unhook_set_command:
            self.unhook_method(self.unhook_set_command)
            self.unhook_set_command = None
        
        self._remove_reply_private_chat_menu_item()
        self._remove_no_quote_forward_menu_item()
        self._no_quote_buttons_created.clear()
        
        if hasattr(self, '_goto_plugin_menu_id') and self._goto_plugin_menu_id:
            self.remove_menu_item(self._goto_plugin_menu_id)
            self._goto_plugin_menu_id = None
        
        if hasattr(self, 'hook_gif_spoiler_ref') and self.hook_gif_spoiler_ref:
            if hasattr(self.hook_gif_spoiler_ref, 'cleanup_menu_items'):
                self.hook_gif_spoiler_ref.cleanup_menu_items()
        
        try:
            from quantahut import cleanup_quantahut_hooks
            cleanup_quantahut_hooks(self)
        except Exception:
            pass
            
        if hasattr(self, 'recent_manager') and self.recent_manager:
            self.recent_manager.cleanup()
            self.recent_manager.recent_dialogs.clear()
        
        if hasattr(self, 'popup_manager') and self.popup_manager:
            self.popup_manager.destroy()
        
        self._cleanup_activity_resources()
        
        if hasattr(self, 'contact_status_activity_state'):
            self.contact_status_activity_state.clear()

    def on_send_message_hook(self, account: int, params: any):
        from base_plugin import HookResult, HookStrategy
        message = getattr(params, "message", "")
        
        if not isinstance(message, str) or not message:
            return HookResult()
        
        if self.get_setting("send_comments_after_forward", False) and not self._send_comments_bypass:
            if not hasattr(params, "message") or not isinstance(params.message, str):
                return HookResult()
            if not params.message:
                return HookResult()
            if not hasattr(params, "peer") or not params.peer:
                return HookResult()
            try:
                LaunchActivity = jclass("org.telegram.ui.LaunchActivity")
                ChatActivity = jclass("org.telegram.ui.ChatActivity")
                DialogsActivity = jclass("org.telegram.ui.DialogsActivity")
                fragment = LaunchActivity.getLastFragment()
            except Exception:
                return HookResult()
            if fragment is None:
                return HookResult()
            should_intercept = False
            try:
                if isinstance(fragment, ChatActivity):
                    preview = get_private_field(fragment, "messagePreviewParams")
                    if preview is not None:
                        forward = getattr(preview, "forwardMessages", None)
                        if forward is not None:
                            messages = getattr(forward, "messages", None)
                            try:
                                has_forward = messages is not None and not messages.isEmpty()
                            except Exception:
                                has_forward = False
                            if has_forward:
                                should_intercept = True
                elif isinstance(fragment, DialogsActivity):
                    dialogs_type = get_private_field(fragment, "dialogsType")
                    forward_type = getattr(DialogsActivity, "DIALOGS_TYPE_FORWARD", None)
                    if dialogs_type == forward_type:
                        should_intercept = True
            except Exception:
                should_intercept = False
            if not should_intercept:
                return HookResult()
            peer = params.peer
            self.log(f"hook_text {peer} {params.message[:30]}")
            self._send_comments_pending[peer] = (params, account)
            return HookResult(strategy=HookStrategy.CANCEL)
        
        try:
            decoded = base64.b64decode(message).decode()
            data = json.loads(decoded)
            if data.get("plugin") == "UiTweaks" and "settings" in data:
                entities = getattr(params, "entities", None)
                if entities is None:
                    from java.util import ArrayList
                    entities = ArrayList()
                
                blockquote_entity = TLRPC.TL_messageEntityBlockquote()
                blockquote_entity.collapsed = True
                blockquote_entity.offset = 0
                blockquote_entity.length = len(message.encode('utf-16-le')) // 2
                entities.add(0, blockquote_entity)
                params.entities = entities
                
                return HookResult(strategy=HookStrategy.MODIFY, params=params)
        except:
            pass
        
        return HookResult()

    def _cleanup_activity_resources(self):
        try:
            if hasattr(self, 'hooked_activities'):
                self.hooked_activities.clear()
                self.log("Cleared hooked_activities set")
        except Exception as e:
            self.log(f"Error cleaning up activity resources: {e}")

    def _open_archived_chats(self, context):
        from client_utils import get_last_fragment
        from java import jclass
        
        fragment = get_last_fragment()
        if fragment:
            bundle = jclass("android.os.Bundle")()
            bundle.putInt("folderId", 1)
            
            dialogs_activity = jclass("org.telegram.ui.DialogsActivity")(bundle)
            fragment.presentFragment(dialogs_activity)
    
    def _open_archived_chats_from_fab(self, dialogs_activity):
        from java import jclass
        
        try:
            bundle = jclass("android.os.Bundle")()
            bundle.putInt("folderId", 1)
            
            archived_dialogs_activity = jclass("org.telegram.ui.DialogsActivity")(bundle)
            dialogs_activity.presentFragment(archived_dialogs_activity)
        except Exception as e:
            pass


    def _apply_hooks(self):
        self.on_plugin_unload()
        try:
            if (self.get_setting("hide_bot_open", False) or 
                self.get_setting("enable_recent_chats_menu", True) or
                self.get_setting("fab_settings_shortcut", False)):
                self._hook_dialogs_activity()
                if self.get_setting("hide_bot_open", False):
                    self._hook_dialog_cell()
            if self.get_setting("hide_hd_icon", False):
                self._hook_photo_cell()
            if self.get_setting("prevent_swipe_while_editing", True) or self.get_setting("prevent_swipe_while_typing", True):
                self._hook_swipe_prevention()
            if self.get_setting("disable_article_viewer_swipe", False):
                self._hook_article_viewer()
            if self.get_setting("prevent_webapp_swipe_down", False):
                self._hook_webapp_swipe_prevention()
            if self.get_setting("enable_code_formatting", False):
                self._hook_code_formatting()
            if self.get_setting("hide_star_reaction", False):
                hide_menu = self.get_setting("star_reaction_hide_menu", False)
                hide_cells = self.get_setting("star_reaction_hide_cells", False)
                
                if hide_menu: 
                    self._hook_star_reaction_menu()
                
                if hide_cells: 
                    self._hook_star_reaction_layout()
            else:
                self._remove_star_reaction_hooks()
            if self.get_setting("always_show_download_manager", False):
                self._hook_download_manager()
            if self.get_setting("always_show_proxy_button", False):
                self._hook_proxy_button()
            if self.get_setting("hide_phone_number", False):
                self._hook_phone_number()
            if self.get_setting("hide_archived_chats", False):
                if self.get_setting("hide_archived_from_drawer", False):
                    self._hook_messages_controller()
                else:
                    self._hook_messages_controller()
                    self._hook_chat_utils_has_archived()
                    self._hook_extera_config_archived()
            if self.get_setting("enable_ai_summarize", False):
                self._hook_ai_summarize()
            if self.get_setting("enable_goto_message", False):
                self._hook_goto_message()
            if self.get_setting("enable_delete_with_duration", False):
                self._hook_delete_with_duration()
            if self.get_setting("dont_auto_play_enabled", False):
                if self.get_setting("dont_auto_play_next_voice", False):
                    self._hook_voice_message_control()
                if self.get_setting("dont_auto_play_next_video", False):
                    self._hook_video_message_control()
            if self.get_setting("progress_timestamp_enabled", True):
               self._hook_voice_message_time_display()
            if self.get_setting("unread_badge_on_back_button", False):
                self._hook_unread_badge()
            if self.get_setting("hide_bot_button", False):
                self._hook_update_bot_button()
            if self.get_setting("confirm_forward", True):
                self._hook_forward_confirmation()
            if self.get_setting("confirm_join_chat", False):
                self._hook_join_confirmation()
            if self.get_setting("enable_no_quote_forward", True):
                self._hook_no_quote_label_and_custom_button()
                self._hook_no_quote_update_bottom_panel()
            if self.get_setting("typing_instead_sticker", False):
                self._hook_send_typing_method()
            if self.get_setting("enable_recent_chats_menu", True):
                self._hook_recent_chats_activities()
            if self.get_setting("hide_birthday_alert", False):
                self._hook_birthday_alert()
            
            if self.get_setting("disable_auto_web_login", False):
                self._hook_disable_auto_web_login()
            if self.get_setting("do_not_share_phone_number", False):
                self._hook_do_not_share_phone_number()
            if self.get_setting("prefer_common_groups_tab", False):
                self._hook_prefer_common_groups_tab()
            
            if self.get_setting("enable_gif_spoiler", False):
                self._hook_gif_spoiler()
            
            if self.get_setting("enable_confirmation_settings", True) and self.get_setting("confirm_external_links", False):
                self._hook_process_external_url()
            
            if self.get_setting("enable_message_preview_enhancement", False):
                self._hook_message_preview_view()
            
            if self.get_setting("enable_sender_select_enhancement", False):
                self._hook_sender_select_popup()
            
            if self.get_setting("enable_swipe_disable", False):
                self._hook_swipe_disable()
            
            if self.get_setting("enable_share_sheet_folders", False):
                self._hook_share_sheet_folders()
            
            if self.get_setting("enable_non_clickable_preview", False):
                self._hook_non_clickable_preview()
            
            if self.get_setting("disable_topics_swipe", False):
                self._hook_disable_topic_swipe()
            
            if self.get_setting("enable_account_visibility", False):
                self._hook_account_visibility()
            
            if self.get_setting("enable_add_to_folder_all_tabs", False):
                self._hook_add_to_folder_all_tabs()
            
            if self.get_setting("unread_chat_count", False) or self.get_setting("unread_message_count", False) or self.get_setting("exclude_archived_from_count", False):
                self._hook_unread_count()
            
            if self.get_setting("enable_contact_status_in_profile", False):
                self._hook_contact_status_in_profile()
            
            if self.get_setting("enable_safe_mode", False):
                self._hook_safe_mode()
            
            if self.get_setting("hidefolders_enabled", False):
                self._hook_folder_visibility()
            
            if self.get_setting("enable_search_by_user_id", False):
                self._hook_search_by_user_id()
            
            if self.get_setting("quick_access_gift_market", False):
                self._hook_gift_drawer()
            
            if self.get_setting("enable_ai_role_limit", False):
                self._hook_ai_role_limit()
            
            if self.get_setting("enable_select_all_media", True):
                self._hook_select_all_media()
            
            if self.get_setting("always_visible_schedule_button", False):
                self._hook_always_visible_schedule_button()

            if self.get_setting("enable_sleep_timer", False):
                self._hook_sleep_timer()
            
            if self.get_setting("enable_adaptive_audio_length", False):
                self._hook_adaptive_audio_length()
            
            if self.get_setting("enable_music_speed_control", False):
                self._hook_music_speed_control()
            
            if self.get_setting("enable_custom_saved_messages", False):
                self._hook_custom_saved_messages()

        except Exception as e:
            pass


    
    
    def _add_reply_private_chat_menu_item(self):
        try:
            self.reply_private_chat_menu_handle = quantahut.utilities.register_message_menu_item(
                text=get_text("reply_in_private_chat", "Reply in private chat"),
                option_id=2033,
                icon_res=R_tg.drawable.msg_reply_solar,
                condition_predicate=lambda m: (m is not None and not m.isOut() and self._is_group_chat(m) and hasattr(m.messageOwner.from_id, 'user_id') and m.messageOwner.from_id.user_id),
                on_click=self._on_reply_private_chat_click,
                insert_at_top=True
            )
        except Exception:
            pass

    def _remove_reply_private_chat_menu_item(self):
        try:
            if hasattr(self, 'reply_private_chat_menu_handle') and self.reply_private_chat_menu_handle:
                quantahut.utilities.unregister_message_menu_item(self.reply_private_chat_menu_handle)
                self.reply_private_chat_menu_handle = None
        except Exception:
            pass

    def _update_reply_private_chat_menu_item(self):
        if self.get_setting("enable_reply_private_chat", False):
            if not hasattr(self, 'reply_private_chat_menu_item_id') or not self.reply_private_chat_menu_item_id:
                self._add_reply_private_chat_menu_item()
        else:
            self._remove_reply_private_chat_menu_item()

    def _is_group_chat(self, message):
        try:
            if not message or not message.messageOwner:
                return False
            chat_id = message.messageOwner.peer_id.channel_id if hasattr(message.messageOwner.peer_id, 'channel_id') and message.messageOwner.peer_id.channel_id else message.messageOwner.peer_id.chat_id if hasattr(message.messageOwner.peer_id, 'chat_id') and message.messageOwner.peer_id.chat_id else 0
            return chat_id != 0
        except Exception:
            return False
    
    def _on_reply_private_chat_click(self, chat_activity, message):
        try:
            if not message or not chat_activity:
                return
            sender_id = message.messageOwner.from_id.user_id if message.messageOwner.from_id else 0
            if not sender_id:
                return
            from android.os import Bundle
            chat_args = Bundle()
            chat_args.putLong("user_id", sender_id)
            private_chat = ChatActivity(chat_args)
            chat_activity.presentFragment(private_chat)
            try:
                if (getattr(private_chat, 'chatActivityEnterView', None) is not None and 
                    getattr(chat_activity, 'chatActivityEnterView', None) is not None):
                    original_text = chat_activity.chatActivityEnterView.getFieldText()
                    if original_text:
                        private_chat.chatActivityEnterView.setFieldText(original_text)
                private_chat.replyingTopMessage = message
                private_chat.showFieldPanelForReplyQuote(message, None)
            except Exception:
                pass
        except Exception:
            pass
    
    def _add_no_quote_forward_menu_item(self):
        try:
            self.no_quote_forward_menu_handle = quantahut.utilities.register_message_menu_item(
                text=get_text("no_quote_forward", "NoQuote forward"),
                option_id=9999,
                icon_res=R_tg.drawable.media_share,
                condition_predicate=lambda m: m is not None and not self._is_service_message(m) and not self._is_failed_message(m),
                on_click=self._on_no_quote_forward_click,
                insert_at_top=True
            )
        except Exception:
            pass

    def _is_service_message(self, message):
        try:
            from org.telegram.tgnet import TLRPC
            return message and hasattr(message, 'messageOwner') and isinstance(message.messageOwner, TLRPC.TL_messageService)
        except Exception:
            return False
    
    def _is_failed_message(self, message):
        try:
            if not message or not hasattr(message, 'messageOwner') or not message.messageOwner:
                return False
            
            message_owner = message.messageOwner
            return (hasattr(message_owner, 'send_state') and message_owner.send_state == 2) or \
                   (hasattr(message_owner, 'id') and message_owner.id < 0)
        except Exception:
            return False

    def _remove_no_quote_forward_menu_item(self):
        try:
            if hasattr(self, 'no_quote_forward_menu_handle') and self.no_quote_forward_menu_handle:
                quantahut.utilities.unregister_message_menu_item(self.no_quote_forward_menu_handle)
                self.no_quote_forward_menu_handle = None
        except Exception:
            pass

    def _update_no_quote_forward_menu_item(self):
        if self.get_setting("enable_no_quote_forward", True):
            if not hasattr(self, 'no_quote_forward_menu_handle') or not self.no_quote_forward_menu_handle:
                self._add_no_quote_forward_menu_item()
        else:
            self._remove_no_quote_forward_menu_item()

    def _on_no_quote_forward_click(self, chat_activity, message):
        self.no_quote_requested = True
        self.log("NoQuote: Set no_quote_requested = True")
        
        if not chat_activity:
            return
            
        from java.util import ArrayList
        messages_to_forward = ArrayList()
        try:
            collected = self._collect_selected_messages(chat_activity)
        except Exception:
            collected = None
        if collected is not None:
            try:
                size = collected.size()
                for i in range(size):
                    obj = collected.get(i)
                    try:
                        if isinstance(obj, MessageObject):
                            messages_to_forward.add(obj)
                        else:
                            messages_to_forward.add(obj)
                    except Exception:
                        messages_to_forward.add(obj)
            except Exception:
                pass
        if messages_to_forward.size() == 0 and hasattr(chat_activity, 'selectedObjects') and chat_activity.selectedObjects:
            for obj in chat_activity.selectedObjects:
                try:
                    if isinstance(obj, MessageObject):
                        messages_to_forward.add(obj)
                    else:
                        messages_to_forward.add(obj)
                except Exception:
                    messages_to_forward.add(obj)
        if messages_to_forward.size() == 0 and message:
            messages_to_forward.add(message)
        
        if not messages_to_forward:
            return
        
        if hasattr(chat_activity, 'getCurrentChat') and chat_activity.getCurrentChat():
            current_chat = chat_activity.getCurrentChat()
            if chat_activity.getMessagesController().isChatNoForwards(current_chat):
                return
        
        from android.os import Bundle
        
        args = Bundle()
        args.putBoolean("onlySelect", True)
        args.putBoolean("canSelectTopics", True)
        args.putInt("dialogsType", 3)
        
        dialogs_fragment = DialogsActivity(args)
        
        from java import dynamic_proxy
        
        class NoQuoteForwardDelegate(dynamic_proxy(DialogsActivity.DialogsActivityDelegate)):
            def __init__(self, messages, chat_activity, plugin_instance):
                super().__init__()
                self.messages = messages
                self.chat_activity = chat_activity
                self.plugin_ref = weakref.ref(plugin_instance)
            
            def didSelectDialogs(self, fragment1, dids, message_text, param, notify, scheduleDate, topicsFragment):
                plugin = self.plugin_ref()
                if plugin is None:
                    return
                if dids.size() > 1 or dids.get(0).dialogId == self.chat_activity.getUserConfig().getClientUserId() or message_text:
                    for i in range(dids.size()):
                        dialog = dids.get(i)
                        did = dialog.dialogId
                        
                        send_helper = self.chat_activity.getSendMessagesHelper()
                        if send_helper:
                            send_helper.sendMessage(self.messages, did, True, False, True, 0, 0)
                    
                    fragment1.finishFragment()
                    
                else:
                    did = dids.get(0).dialogId
                    args1 = Bundle()

                    args1.putBoolean("scrollToTopOnResume", True)
                    
                    if DialogObject.isEncryptedDialog(did):
                        args1.putInt("enc_id", DialogObject.getEncryptedChatId(did))
                    elif DialogObject.isUserDialog(did):
                        args1.putLong("user_id", did)
                    else:
                        args1.putLong("chat_id", -did)
                    
                    if not self.chat_activity.getMessagesController().checkCanOpenChat(args1, fragment1):
                        return True
                    
                    self.chat_activity.getNotificationCenter().postNotificationName(NotificationCenter.closeChats)
                    
                    new_chat_activity = ChatActivity(args1)
                    
                    fragment1.presentFragment(new_chat_activity, True)

                    new_chat_activity.showFieldPanelForForward(True, self.messages)
                    params = get_private_field(new_chat_activity, "messagePreviewParams")
                    if params is not None:
                        try:
                            set_private_field(params, "hideForwardSendersName", True)
                        except Exception:
                            pass
                
                return True
            
            def canSelectStories(self):
                return False
        
        delegate = NoQuoteForwardDelegate(messages_to_forward, chat_activity, self)
        dialogs_fragment.setDelegate(delegate)
        
        try:
            DialogsActivityClass = find_class("org.telegram.ui.DialogsActivity")
            onPauseMethod = DialogsActivityClass.getClass().getDeclaredMethod("onPause")
            onPauseMethod.setAccessible(True)
            
            class DialogsPauseHook:
                def __init__(self, plugin_instance):
                    self.plugin = plugin_instance
                
                def before_hooked_method(self, param):
                    self.plugin.no_quote_requested = False
            
            pause_hook = DialogsPauseHook(self)
            self.hook_method(onPauseMethod, pause_hook)
        except Exception:
            pass
        
        chat_activity.presentFragment(dialogs_fragment)

    def _collect_selected_messages(self, chat_activity):
        try:
            from java.util import ArrayList
            selectedIds = get_private_field(chat_activity, "selectedMessagesIds")
            messagesDict = get_private_field(chat_activity, "messagesDict")
            arr = ArrayList()
            if selectedIds is not None and messagesDict is not None:
                for a in range(2):
                    ids = selectedIds[a]
                    if ids is None:
                        continue
                    size = ids.size()
                    keys = []
                    for idx in range(size):
                        keys.append(ids.keyAt(idx))
                    try:
                        keys.sort()
                    except Exception:
                        pass
                    for key in keys:
                        msg = messagesDict[a].get(key)
                        if msg is not None:
                            arr.add(msg)
            return arr
        except Exception:
            return None

    def _ensure_no_quote_custom_left_button(self, chat):
        try:
            chat_id = id(chat)
            
            if chat_id in self._no_quote_button_cache:
                cached_button = self._no_quote_button_cache[chat_id]
                if cached_button and cached_button.getVisibility() == cached_button.VISIBLE:
                    return
                elif cached_button:
                    cached_button.setVisibility(cached_button.VISIBLE)
                    return
            
            bottom = get_private_field(chat, "bottomMessagesActionContainer")
            if bottom is None:
                return

            count = bottom.getChildCount()
            for i in range(count):
                v = bottom.getChildAt(i)
                try:
                    tag = v.getTag(CUSTOM_BUTTON_TAG)
                    if tag is not None:
                        v.setVisibility(v.VISIBLE)
                        self._no_quote_button_cache[chat_id] = v
                        self._no_quote_buttons_created.add(chat_id)
                        return
                except Exception:
                    pass
            
            if chat_id not in self._no_quote_buttons_created:
                self._create_no_quote_button(chat, bottom)
                self._no_quote_buttons_created.add(chat_id)
        except Exception:
            pass

    def _create_no_quote_button(self, chat, bottom):
        try:
            Context = chat.getContext()
            TextView = find_class("android.widget.TextView")
            btn = TextView(Context)
            btn.setText(get_text("no_quote", "NoQuote"))
            try:
                from android.util import TypedValue
                btn.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 15)
            except Exception:
                pass
            try:
                btn.setPadding(AndroidUtilities.dp(14), 0, AndroidUtilities.dp(21), 0)
            except Exception:
                pass
            btn.setClickable(True)
            try:
                from android.view import Gravity
                btn.setGravity(Gravity.CENTER_VERTICAL)
            except Exception:
                pass
            try:
                btn.setBackgroundDrawable(Theme.createSelectorDrawable(chat.getThemedColor(Theme.key_actionBarActionModeDefaultSelector), 3))
                btn.setTextColor(chat.getThemedColor(Theme.key_actionBarActionModeDefaultIcon))
            except Exception:
                pass
            try:
                from android.widget import FrameLayout
                lp = FrameLayout.LayoutParams(FrameLayout.LayoutParams.WRAP_CONTENT, FrameLayout.LayoutParams.MATCH_PARENT)
                from android.view import Gravity as Grav
                lp.gravity = Grav.CENTER
                bottom.addView(btn, lp)
            except Exception:
                bottom.addView(btn)
            try:
                btn.setTag(CUSTOM_BUTTON_TAG, True)
            except Exception:
                pass
            OnClickInterface = find_class("android.view.View$OnClickListener")
            OnClick = dynamic_proxy(OnClickInterface)
            plugin_ref = weakref.ref(self)
            class ClickImpl(OnClick):
                def __init__(self, host):
                    super().__init__()
                    self.host = host
                def onClick(self, v):
                    plugin = plugin_ref()
                    if plugin is None:
                        return
                    plugin._on_no_quote_forward_click(self.host, None)
            btn.setOnClickListener(ClickImpl(chat))
            chat_id = id(chat)
            self._no_quote_button_cache[chat_id] = btn
        except Exception:
            pass

    def _hook_no_quote_label_and_custom_button(self):
        try:
            ChatActivity = find_class("org.telegram.ui.ChatActivity")
            method = ChatActivity.getClass().getDeclaredMethod("createBottomMessagesActionButtons")
            method.setAccessible(True)
            class Hook:
                def __init__(self, plugin):
                    self.plugin = plugin
                def after_hooked_method(self, param):
                    chat = param.thisObject
                    self.plugin._ensure_no_quote_custom_left_button(chat)
            self.hook_no_quote_create_buttons_ref = self.hook_method(method, Hook(self))
        except Exception:
            pass

    def _hook_no_quote_update_bottom_panel(self):
        try:
            ChatActivity = find_class("org.telegram.ui.ChatActivity")
            BooleanTYPE = find_class("java.lang.Boolean").TYPE
            method = ChatActivity.getClass().getDeclaredMethod("updateBottomPanel", BooleanTYPE)
            method.setAccessible(True)
            class UpdateHook:
                def __init__(self, plugin):
                    self.plugin = plugin
                def after_hooked_method(self, param):
                    chat = param.thisObject
                    self.plugin._ensure_no_quote_custom_left_button(chat)
            self.hook_no_quote_update_bottom_panel_ref = self.hook_method(method, UpdateHook(self))
        except Exception:
            pass
    
    def _hook_add_to_folder_all_tabs(self):
        try:
            DialogsActivityClass = find_class("org.telegram.ui.DialogsActivity")
            if not DialogsActivityClass:
                return
            
            try:
                BooleanTYPE = find_class("java.lang.Boolean").TYPE
                updateCountersMethod = DialogsActivityClass.getClass().getDeclaredMethod("updateCounters", BooleanTYPE)
            except:
                try:
                    updateCountersMethod = DialogsActivityClass.getClass().getDeclaredMethod("updateCounters")
                except:
                    IntegerTYPE = find_class("java.lang.Integer").TYPE
                    updateCountersMethod = DialogsActivityClass.getClass().getDeclaredMethod("updateCounters", IntegerTYPE)
            
            updateCountersMethod.setAccessible(True)
            
            self.hook_add_to_folder_all_tabs_ref = self.hook_method(
                updateCountersMethod,
                AddToFolderAllTabsHook(self),
                priority=0
            )
            
        except Exception:
            pass
    
    def _hook_unread_count(self):
        try:
            MessagesStorageClass = find_class("org.telegram.messenger.MessagesStorage")
            if not MessagesStorageClass:
                return

            BooleanTYPE = find_class("java.lang.Boolean").TYPE
            calcUnreadCountersMethod = MessagesStorageClass.getClass().getDeclaredMethod("calcUnreadCounters", BooleanTYPE)
            calcUnreadCountersMethod.setAccessible(True)

            self.hook_unread_count_ref = self.hook_method(calcUnreadCountersMethod, UnreadCountHook(self), priority=0)

            if self.get_setting("exclude_archived_from_count", False):
                try:
                    from org.telegram.messenger import UserConfig
                    current_account = UserConfig.selectedAccount
                    messages_storage = MessagesStorageClass.getInstance(current_account)
                    calcUnreadCountersMethod.invoke(messages_storage, True)
                except Exception:
                    pass

        except Exception:
            pass
    
    def _hook_contact_status_in_profile(self):
        try:
            ProfileActivity = find_class("org.telegram.ui.ProfileActivity")
            if not ProfileActivity:
                return

            java_class = ProfileActivity.getClass()

            try:
                update_rows = java_class.getDeclaredMethod("updateRowsIds")
                update_rows.setAccessible(True)
                self.contact_status_update_rows_hook = self.hook_method(
                    update_rows,
                    ContactStatusUpdateRowsIdsHook(self),
                    priority=0,
                )
            except Exception:
                pass

            ListAdapter = find_class("org.telegram.ui.ProfileActivity$ListAdapter")
            if not ListAdapter:
                return

            try:
                int_type = jclass("java.lang.Integer").TYPE
                view_group = jclass("android.view.ViewGroup")
                view_holder = jclass("androidx.recyclerview.widget.RecyclerView$ViewHolder")

                list_adapter_class = ListAdapter.getClass()

                get_item_view_type = list_adapter_class.getDeclaredMethod("getItemViewType", int_type)
                get_item_view_type.setAccessible(True)
                self.contact_status_get_item_view_type_hook = self.hook_method(
                    get_item_view_type,
                    ContactStatusListAdapterGetItemViewTypeHook(self),
                    priority=0,
                )

                on_create_view_holder = list_adapter_class.getDeclaredMethod(
                    "onCreateViewHolder",
                    view_group,
                    int_type,
                )
                on_create_view_holder.setAccessible(True)
                self.contact_status_create_view_holder_hook = self.hook_method(
                    on_create_view_holder,
                    ContactStatusListAdapterCreateViewHolderHook(self),
                    priority=0,
                )

                on_bind_view_holder = list_adapter_class.getDeclaredMethod(
                    "onBindViewHolder",
                    view_holder,
                    int_type,
                )
                on_bind_view_holder.setAccessible(True)
                self.contact_status_bind_view_holder_hook = self.hook_method(
                    on_bind_view_holder,
                    ContactStatusListAdapterBindViewHolderHook(self),
                    priority=0,
                )
            except Exception:
                pass

        except Exception:
            pass
    
    def _hook_safe_mode(self):
        try:
            LaunchActivityClass = find_class("org.telegram.ui.LaunchActivity")
            if not LaunchActivityClass:
                return
            
            methods = LaunchActivityClass.getClass().getDeclaredMethods()
            dispatch_method = None
            for method in methods:
                if method.getName() == "dispatchKeyEvent":
                    dispatch_method = method
                    break
            
            if not dispatch_method:
                return
            
            dispatch_method.setAccessible(True)
            self.safe_mode_hook_ref = self.hook_method(dispatch_method, SafeModeHook(self))
        except Exception:
            pass
    
    def _on_safe_mode_detected(self):
        try:
            run_on_ui_thread(self._enable_safe_mode)
        except Exception:
            pass
    
    def _enable_safe_mode(self):
        try:
            from com.exteragram.messenger import ExteraConfig
            from com.exteragram.messenger.plugins import PluginsController
            from android.content import Context
            from org.telegram.messenger import ApplicationLoader
            
            ExteraConfig.pluginsSafeMode = True
            editor = ExteraConfig.editor
            editor.putBoolean("pluginsSafeMode", True).apply()
            
            context = ApplicationLoader.applicationContext
            plugin_prefs = context.getSharedPreferences("plugin_settings", Context.MODE_PRIVATE)
            plugin_prefs.edit().putBoolean("had_crash", True).putString("crashed_plugin_id", "manual!").apply()
            
            PluginsController.getInstance().restart()
            
            try:
                SafeModeBottomSheet = find_class("com.exteragram.messenger.plugins.ui.components.SafeModeBottomSheet")
                fragment = get_last_fragment()
                if fragment and SafeModeBottomSheet:
                    SafeModeBottomSheet(fragment).show()
            except Exception:
                pass
        except Exception:
            pass
    
  
    def _load_hidden_folders(self):
        try:
            data_str = self.get_setting("hidefolders_data", "{}")
            self.hidden_folders_data = json.loads(data_str)
            
            all_chats_str = self.get_setting("hidefolders_allchats", "{}")
            self.hide_all_chats_folder = json.loads(all_chats_str)
        except Exception:
            self.hidden_folders_data = {}
            self.hide_all_chats_folder = {}
    
    def _save_hidden_folders(self):
        try:
            self.set_setting("hidefolders_data", json.dumps(self.hidden_folders_data))
            self.set_setting("hidefolders_allchats", json.dumps(self.hide_all_chats_folder))
        except Exception:
            pass
    
    def _get_account_key(self):
        try:
            user_id = UserConfig.getInstance(UserConfig.selectedAccount).getClientUserId()
            return f"_{user_id}"
        except Exception:
            return "_default"
    
    def _get_hidden_folders_for_account(self):
        key = self._get_account_key()
        if key not in self.hidden_folders_data:
            self.hidden_folders_data[key] = []
        return self.hidden_folders_data[key]
    
    def _is_folder_hidden(self, filter_id):
        hidden_folders = self._get_hidden_folders_for_account()
        return filter_id in hidden_folders
    
    def _is_all_chats_hidden(self):
        key = self._get_account_key()
        return self.hide_all_chats_folder.get(key, False)
    
    def _show_folder_selector(self):
        try:
            controller = MessagesController.getInstance(UserConfig.selectedAccount)
            filters_field = controller.getClass().getDeclaredField("dialogFilters")
            filters_field.setAccessible(True)
            filters = filters_field.get(controller)

            if filters is None:
                filters = controller.getDialogFilters()

            hidden_folders = self._get_hidden_folders_for_account()

            items = []
            keys = []
            key_to_folder = {}

            for i in range(filters.size()):
                filter_obj = filters.get(i)
                if filter_obj.isDefault():
                    continue

                key = f"hidefolders_folder_{filter_obj.id}"
                keys.append(key)
                items.append(str(filter_obj.name))
                key_to_folder[key] = filter_obj.id

            if not items:
                return

            for key in keys:
                folder_id = key_to_folder[key]
                self.set_setting(key, folder_id in hidden_folders)

            def on_selection_change(selected_keys):
                try:
                    account_key = self._get_account_key()
                    new_hidden = [key_to_folder[key] for key in selected_keys if key in key_to_folder]
                    self.hidden_folders_data[account_key] = new_hidden
                    self._save_hidden_folders()
                    self._hook_folder_visibility(post_notification=True)
                    return False
                except Exception:
                    return False

            showmultiselector(
                items=items,
                title=get_text("hide_folders_title", "Hide Folders"),
                subtitle=get_text("hide_folders_subtitle", "Select folders to hide"),
                setting_keys=keys,
                plugin_instance=self,
                on_selection_change=on_selection_change,
                action_text=get_text("apply", "Apply")
            )
        except Exception:
            pass
    
    def _toggle_hide_folders(self, enabled):
        self.set_setting("hidefolders_enabled", enabled)
        self._hook_folder_visibility(post_notification=True)
    
    def _post_update_notification(self):
        try:
            from android.os import Handler, Looper
            from android_utils import R
            
            def post_update():
                try:
                    NotificationCenter.getInstance(UserConfig.selectedAccount).postNotificationName(
                        NotificationCenter.dialogFiltersUpdated
                    )
                except:
                    pass
            
            Handler(Looper.getMainLooper()).post(R(post_update))
        except Exception:
            pass
    
    def _hook_folder_visibility(self, post_notification=False):
        try:
            if not self.get_setting("hidefolders_enabled", False):
                return
                
            MessagesControllerClass = find_class("org.telegram.messenger.MessagesController")
            if not MessagesControllerClass:
                return
            
            from org.telegram.messenger import UserConfig
            current_account = UserConfig.selectedAccount
            controller = MessagesControllerClass.getInstance(current_account)
            
            hidden_folders = self._get_hidden_folders_for_account()
            hide_all_chats = self._is_all_chats_hidden()
            
            if not hidden_folders and not hide_all_chats:
                frozen_field = controller.getClass().getDeclaredField("frozenDialogFilters")
                frozen_field.setAccessible(True)
                frozen_field.set(controller, None)
                return
            
            dialog_filters_field = controller.getClass().getDeclaredField("dialogFilters")
            dialog_filters_field.setAccessible(True)
            original_filters = dialog_filters_field.get(controller)
            
            if original_filters is None or original_filters.size() == 0:
                return
            
            from java.util import ArrayList
            filtered_list = ArrayList()
            for i in range(original_filters.size()):
                filter_item = original_filters.get(i)
                try:
                    is_default = filter_item.isDefault()
                except:
                    is_default = False
                if is_default and hide_all_chats:
                    continue
                if not is_default and filter_item.id in hidden_folders:
                    continue
                filtered_list.add(filter_item)
            
            frozen_field = controller.getClass().getDeclaredField("frozenDialogFilters")
            frozen_field.setAccessible(True)
            frozen_field.set(controller, filtered_list)
            
            if post_notification:
                self._post_update_notification()
            
        except Exception:
            pass
    
    def _hook_search_by_user_id(self):
        try:
            MentionsAdapterClass = find_class("org.telegram.ui.Adapters.MentionsAdapter")
            if not MentionsAdapterClass:
                return
            
            IntegerClass = find_class("java.lang.Integer")
            BooleanClass = find_class("java.lang.Boolean")
            
            java_class = MentionsAdapterClass.getClass()
            search_method = java_class.getDeclaredMethod(
                "searchUsernameOrHashtag",
                find_class("java.lang.CharSequence"),
                IntegerClass.TYPE,
                find_class("java.util.ArrayList"),
                BooleanClass.TYPE,
                BooleanClass.TYPE
            )
            search_method.setAccessible(True)
            
            class SearchHook:
                def __init__(self, plugin):
                    self.plugin = plugin
                
                def before_hooked_method(self, param):
                    try:
                        if not hasattr(self, 'pending_user'):
                            self.pending_user = None
                        if not hasattr(self, 'pending_chat'):
                            self.pending_chat = None
                        
                        char_sequence = param.args[0]
                        for_search = param.args[4] if len(param.args) > 4 else False
                        
                        if not for_search or char_sequence is None:
                            self.pending_user = None
                            self.pending_chat = None
                            return
                        
                        if isinstance(char_sequence, str):
                            text = char_sequence.strip()
                        else:
                            text = str(char_sequence).strip()
                        
                        if text.startswith("@"):
                            text = text[1:]
                        
                        if text and text.isdigit() and len(text) <= 20:
                            try:
                                user_id = int(text)
                                current_account = UserConfig.selectedAccount
                                user = MessagesController.getInstance(current_account).getUser(user_id)
                                chat = MessagesController.getInstance(current_account).getChat(user_id)
                                
                                if chat is None and text.startswith("100") and len(text) > 10:
                                    chat_id = int(text[3:])
                                    chat = MessagesController.getInstance(current_account).getChat(chat_id)
                                
                                if user is not None:
                                    self.pending_user = user
                                elif chat is not None:
                                    self.pending_chat = chat
                                
                            except:
                                pass
                                
                    except:
                        pass
                
                def after_hooked_method(self, param):
                    try:
                        if self.pending_user is None and self.pending_chat is None:
                            return
                        
                        adapter = param.thisObject
                        
                        try:
                            parent_fragment_field = adapter.getClass().getDeclaredField("parentFragment")
                            parent_fragment_field.setAccessible(True)
                            chat_activity = parent_fragment_field.get(adapter)
                            
                            if chat_activity:
                                search_user_method = chat_activity.getClass().getDeclaredMethod(
                                    "searchUserMessages",
                                    find_class("org.telegram.tgnet.TLRPC$User"),
                                    find_class("org.telegram.tgnet.TLRPC$Chat")
                                )
                                search_user_method.setAccessible(True)
                                
                                if self.pending_user:
                                    search_user_method.invoke(chat_activity, self.pending_user, None)
                                elif self.pending_chat:
                                    search_user_method.invoke(chat_activity, None, self.pending_chat)
                                
                        except:
                            pass
                        
                        self.pending_user = None
                        self.pending_chat = None
                                
                    except:
                        pass
            
            self.hook_search_by_user_id_ref = self.hook_method(search_method, SearchHook(self))
            
        except:
            pass
    
    def _hook_ai_role_limit(self):
        try:
            NEW_LIMIT = 9999
            
            CodepointsLengthInputFilterClass = find_class("org.telegram.ui.Components.CodepointsLengthInputFilter")
            if not CodepointsLengthInputFilterClass:
                return
            
            class LimitHook:
                def __init__(self, plugin):
                    self.plugin = plugin
                
                def after_hooked_method(self, param):
                    try:
                        obj = param.thisObject
                        obj_class = obj.getClass()
                        superclass = obj_class.getSuperclass()
                        mMax_field = superclass.getDeclaredField("mMax")
                        mMax_field.setAccessible(True)
                        current_max = mMax_field.getInt(obj)
                        
                        if current_max == 1024:
                            from java.lang.reflect import Field, Modifier
                            modifiers_field = Field.getClass().getDeclaredField("accessFlags")
                            modifiers_field.setAccessible(True)
                            modifiers_field.setInt(mMax_field, mMax_field.getModifiers() & ~Modifier.FINAL)
                            mMax_field.setInt(obj, NEW_LIMIT)
                    except:
                        pass
            
            from java.lang import Integer
            java_class = CodepointsLengthInputFilterClass.getClass()
            constructor = java_class.getDeclaredConstructor(Integer.TYPE)
            self.hook_ai_role_limit_constructor_ref = self.hook_method(constructor, LimitHook(self))
            
            class SetTextHook:
                def before_hooked_method(self, param):
                    try:
                        if len(param.args) > 0 and param.args[0]:
                            text = str(param.args[0])
                            if "1024" in text:
                                new_text = text.replace("1024", str(NEW_LIMIT))
                                param.args[0] = new_text
                    except:
                        pass
            
            OutlineTextContainerViewClass = find_class("org.telegram.ui.Components.OutlineTextContainerView")
            if OutlineTextContainerViewClass:
                StringClass = find_class("java.lang.String")
                setText_method = OutlineTextContainerViewClass.getClass().getDeclaredMethod("setText", StringClass)
                self.hook_ai_role_limit_settext_ref = self.hook_method(setText_method, SetTextHook())
            
        except:
            pass
    
    def _hook_sleep_timer(self):
        try:
            AudioPlayerAlert = find_class("org.telegram.ui.Components.AudioPlayerAlert")
            if not AudioPlayerAlert:
                return
            Context = jclass("android.content.Context")
            Theme_ResourcesProvider = jclass("org.telegram.ui.ActionBar.Theme$ResourcesProvider")
            
            constructor = AudioPlayerAlert.getClass().getDeclaredConstructor(Context, Theme_ResourcesProvider)
            constructor.setAccessible(True)
            
            self.hook_sleep_timer_ref = self.hook_method(constructor, SleepTimerHook(self))
        except:
            pass
    
    def _hook_adaptive_audio_length(self):
        try:
            ChatMessageCellClass = find_class("org.telegram.ui.Cells.ChatMessageCell")
            if not ChatMessageCellClass:
                return
            
            self.hook_adaptive_audio_ref = self.hook_all_methods(
                ChatMessageCellClass,
                "setMessageContent",
                AdaptiveAudioHook(self),
                priority=50
            )
        except:
            pass
    
    def _hook_music_speed_control(self):
        try:
            FragmentContextViewClass = find_class("org.telegram.ui.Components.FragmentContextView")
            if not FragmentContextViewClass:
                return
            
            methods = FragmentContextViewClass.getClass().getDeclaredMethods()
            for m in methods:
                if m.getName() == "checkPlayer" and len(m.getParameterTypes()) == 1:
                    self.hook_music_speed_control_ref = self.hook_method(m, MusicSpeedControlHook(self))
                    break
        except:
            pass
    
    def _hook_custom_saved_messages(self):
        ChatActivityClass = find_class("org.telegram.ui.ChatActivity")
        if not ChatActivityClass:
            return
        
        from java import jclass
        method = ChatActivityClass.getClass().getDeclaredMethod(
            "forwardMessages",
            jclass("java.util.ArrayList"),
            jclass("java.lang.Boolean").TYPE,
            jclass("java.lang.Boolean").TYPE,
            jclass("java.lang.Boolean").TYPE,
            jclass("java.lang.Integer").TYPE,
            jclass("java.lang.Long").TYPE,
            jclass("java.lang.Long").TYPE
        )
        method.setAccessible(True)
        
        plugin_ref = weakref.ref(self)
        
        class CustomSavedMessagesHook:
            def before_hooked_method(self, param):
                plugin = plugin_ref()
                if plugin and len(param.args) >= 6:
                    client_id = param.thisObject.getUserConfig().getClientUserId()
                    if param.args[5] == client_id:
                        custom_id = plugin._get_custom_saved_chat_id()
                        if custom_id != client_id:
                            param.args[5] = custom_id
        
        self.hook_custom_saved_messages_ref = self.hook_method(method, CustomSavedMessagesHook())
    
    def _get_custom_saved_chat_id(self):
        if self.get_setting("enable_custom_saved_messages", False) and self.custom_saved_chat_id:
            return self.custom_saved_chat_id
        return UserConfig.getInstance(UserConfig.selectedAccount).clientUserId
    
    def _select_custom_saved_chat(self):
        fragment = get_last_fragment()
        if not fragment:
            return
        
        args = Bundle()
        args.putBoolean("onlySelect", True)
        args.putBoolean("allowGlobalSearch", False)
        args.putBoolean("resetDelegate", False)
        args.putBoolean("closeFragment", True)
        
        dialogs_activity = DialogsActivity(args)
        
        from java import dynamic_proxy
        plugin_ref = weakref.ref(self)
        
        class CustomSavedChatDelegate(dynamic_proxy(DialogsActivity.DialogsActivityDelegate)):
            def __init__(self, plugin_instance):
                super().__init__()
                self.plugin_ref = weakref.ref(plugin_instance)
            
            def didSelectDialogs(self, fragment, dids, message, param, notify, scheduleDate, topicsFragment):
                plugin = self.plugin_ref()
                if plugin and dids and dids.size() > 0:
                    plugin.custom_saved_chat_id = dids.get(0).dialogId
                    plugin.set_setting("custom_saved_chat_id", plugin.custom_saved_chat_id, reload_settings=True)
                    fragment.finishFragment(True)
                return True
            
            def canSelectStories(self):
                return False
        
        dialogs_activity.setDelegate(CustomSavedChatDelegate(self))
        fragment.presentFragment(dialogs_activity)
    
    def _get_custom_saved_chat_name(self):
        if not self.custom_saved_chat_id:
            return "Not selected"
        
        mc = MessagesController.getInstance(UserConfig.selectedAccount)
        if self.custom_saved_chat_id < 0:
            chat = mc.getChat(-self.custom_saved_chat_id)
            return getattr(chat, 'title', "Unknown") if chat else "Unknown"
        
        user = mc.getUser(self.custom_saved_chat_id)
        if user:
            return f"{getattr(user, 'first_name', '') or ''} {getattr(user, 'last_name', '') or ''}".strip() or "Unknown"
        return "Unknown"
    
    def _hook_select_all_media(self):
        try:
            SharedMediaLayoutClass = find_class("org.telegram.ui.Components.SharedMediaLayout")
            if not SharedMediaLayoutClass:
                return
            
            plugin_ref = weakref.ref(self)
            
            class SharedMediaLayoutHook:
                def after_hooked_method(self, param):
                    try:
                        plugin = plugin_ref()
                        if plugin:
                            plugin._add_select_all_button(param.thisObject)
                    except:
                        pass
            
            for constructor in SharedMediaLayoutClass.getClass().getDeclaredConstructors():
                if len(constructor.getParameterTypes()) >= 5:
                    constructor.setAccessible(True)
                    self.hook_select_all_media_ref = self.hook_method(constructor, SharedMediaLayoutHook())
                    break
        except:
            pass
    
    def _add_select_all_button(self, shared_media_layout):
        try:
            action_mode_layout = get_private_field(shared_media_layout, "actionModeLayout")
            action_mode_views = get_private_field(shared_media_layout, "actionModeViews")
            if not action_mode_layout or action_mode_views is None:
                return
            
            select_all_item = ActionBarMenuItem(
                action_mode_layout.getContext(), None,
                Theme.getColor(Theme.key_actionBarActionModeDefaultSelector),
                Theme.getColor(Theme.key_actionBarActionModeDefaultIcon), False
            )
            select_all_item.setIcon(R_tg.drawable.msg_select_between_solar)
            select_all_item.setContentDescription("Select All")
            select_all_item.setDuplicateParentStateEnabled(False)
            select_all_item.setOnClickListener(OnClickListener(lambda v: self._select_all_media(shared_media_layout)))
            
            action_mode_layout.addView(select_all_item, 2, LinearLayout.LayoutParams(AndroidUtilities.dp(54), LinearLayout.LayoutParams.MATCH_PARENT))
            action_mode_views.add(2, select_all_item)
        except:
            pass
    
    def _scroll_and_select(self, shared_media_layout, current_page, selected_files, dialog_id, shared_media_data, media_type):
        try:
            list_view = get_private_field(current_page, "listView")
            if not list_view:
                return
            
            messages = get_private_field(shared_media_data[media_type], "messages")
            total_count = get_private_field(shared_media_data[media_type], "totalCount")
            
            state = {"index": 0, "count": messages.size() if messages else 0, "load_attempts": 0}
            BATCH_SIZE = 20
            MAX_LOAD_ATTEMPTS = 5
            MAX_SELECTION = 100
            
            plugin_ref = weakref.ref(self)
            shared_media_ref = weakref.ref(shared_media_layout)
            
            def step():
                try:
                    plugin = plugin_ref()
                    shared_media = shared_media_ref()
                    if not plugin or not shared_media:
                        return
                    
                    messages_now = get_private_field(shared_media_data[media_type], "messages")
                    if not messages_now:
                        return
                    
                    done = False
                    for _ in range(BATCH_SIZE):
                        i = state["index"]
                        if i >= state["count"]:
                            if state["count"] < total_count and state["count"] < MAX_SELECTION:
                                def attempt_load():
                                    try:
                                        pos = max(0, state["count"] - 1)
                                        list_view.scrollToPosition(pos)
                                        
                                        def check_new_count():
                                            try:
                                                new_messages = get_private_field(shared_media_data[media_type], "messages")
                                                new_count = new_messages.size() if new_messages else 0
                                                if new_count > state["count"]:
                                                    state["count"] = new_count
                                                    state["load_attempts"] = 0
                                                    run_on_ui_thread(step)
                                                else:
                                                    state["load_attempts"] += 1
                                                    if state["load_attempts"] < MAX_LOAD_ATTEMPTS:
                                                        run_on_ui_thread(attempt_load, 300)
                                            except:
                                                pass
                                        run_on_ui_thread(check_new_count, 300)
                                    except:
                                        pass
                                attempt_load()
                            else:
                                def scroll_to_start():
                                    try:
                                        list_view.scrollToPosition(0)
                                    except:
                                        pass
                                run_on_ui_thread(scroll_to_start, 200)
                            return
                        
                        if selected_files[0].size() + selected_files[1].size() >= MAX_SELECTION:
                            def scroll_to_start():
                                try:
                                    list_view.scrollToPosition(0)
                                except:
                                    pass
                            run_on_ui_thread(scroll_to_start, 200)
                            return
                        
                        try:
                            message_obj = messages_now.get(i)
                            state["index"] = i + 1
                            if message_obj:
                                load_index = 0 if message_obj.getDialogId() == dialog_id else 1
                                if selected_files[load_index].indexOfKey(message_obj.getId()) < 0:
                                    selected_files[load_index].put(message_obj.getId(), message_obj)
                        except:
                            pass
                    
                    selected_messages_count_text_view = get_private_field(shared_media, "selectedMessagesCountTextView")
                    if selected_messages_count_text_view:
                        selected_messages_count_text_view.setNumber(selected_files[0].size() + selected_files[1].size(), True)
                    
                    adapter = list_view.getAdapter()
                    if adapter:
                        adapter.notifyDataSetChanged()
                    
                    run_on_ui_thread(step)
                except:
                    pass
            
            run_on_ui_thread(step)
        except:
            pass
    
    def _select_all_media(self, shared_media_layout):
        try:
            media_pages = get_private_field(shared_media_layout, "mediaPages")
            if not media_pages:
                return
            
            scroll_sliding_tab = get_private_field(shared_media_layout, "scrollSlidingTextTabStrip")
            current_tab_id = scroll_sliding_tab.getCurrentTabId() if scroll_sliding_tab else 0
            
            current_page = None
            for page in media_pages:
                if page and get_private_field(page, "selectedType") == current_tab_id:
                    current_page = page
                    break
            
            if not current_page:
                return
            
            list_view = get_private_field(current_page, "listView")
            selected_files = get_private_field(shared_media_layout, "selectedFiles")
            dialog_id = get_private_field(shared_media_layout, "dialog_id")
            shared_media_data = get_private_field(shared_media_layout, "sharedMediaData")
            
            if not list_view or not selected_files or not shared_media_data:
                return
            
            media_type = get_private_field(current_page, "selectedType")
            if media_type >= len(shared_media_data):
                return
            
            messages = get_private_field(shared_media_data[media_type], "messages")
            if not messages:
                return
            
            total_count = get_private_field(shared_media_data[media_type], "totalCount")
            
            self._scroll_and_select(shared_media_layout, current_page, selected_files, dialog_id, shared_media_data, media_type)
        except:
            pass
    
    def _hook_always_visible_schedule_button(self):
        try:
            ChatActivityEnterViewClass = find_class("org.telegram.ui.Components.ChatActivityEnterView")
            if not ChatActivityEnterViewClass:
                return
            
            update_schedule_button_method = ChatActivityEnterViewClass.getClass().getDeclaredMethod(
                "updateScheduleButton",
                find_class("java.lang.Boolean").TYPE
            )
            update_schedule_button_method.setAccessible(True)
            self.hook_always_visible_schedule_button_ref = self.hook_method(update_schedule_button_method, AlwaysVisibleScheduleButtonHook(self))
        except Exception as e:
            self.log(f"Error hooking always visible schedule button: {e}")
    
    def _hook_gift_drawer(self):
        try:
            DrawerLayoutAdapter = jclass("org.telegram.ui.Adapters.DrawerLayoutAdapter")
            resetItems_method = DrawerLayoutAdapter.getClass().getDeclaredMethod("resetItems")
            resetItems_method.setAccessible(True)
            
            class DrawerResetHook:
                def __init__(self, plugin):
                    self.plugin = plugin
                
                def after_hooked_method(self, param):
                    try:
                        adapter = param.thisObject
                        items_field = adapter.getClass().getDeclaredField("items")
                        items_field.setAccessible(True)
                        items = items_field.get(adapter)
                        
                        if items is None:
                            return
                        
                        insert_position = -1
                        found_bots = False
                        
                        for i in range(items.size()):
                            item = items.get(i)
                            if item is not None:
                                try:
                                    bot_field = item.getClass().getDeclaredField("bot")
                                    bot_field.setAccessible(True)
                                    bot = bot_field.get(item)
                                    if bot is not None:
                                        found_bots = True
                                except:
                                    pass
                            elif found_bots and item is None:
                                insert_position = i
                                break
                        
                        if insert_position == -1:
                            insert_position = 0
                        
                        current_account = UserConfig.selectedAccount
                        if not UserConfig.getInstance(current_account).isClientActivated():
                            return
                        
                        Item = jclass("org.telegram.ui.Adapters.DrawerLayoutAdapter$Item")
                        gift_icon = R_tg.drawable.menu_gift
                        gift_text = LocaleController.getString(R_tg.string.Gift2TitleSelf1)
                        gift_item = Item(1003, gift_text, gift_icon)
                        items.add(insert_position, gift_item)
                        
                    except Exception:
                        pass
            
            self.hook_gift_drawer_reset_ref = self.hook_method(resetItems_method, DrawerResetHook(self))
            self._hook_gift_drawer_click()
            self._hook_gift_drawer_cell()
            
        except Exception:
            pass
    
    def _hook_gift_drawer_click(self):
        try:
            DrawerLayoutAdapter = jclass("org.telegram.ui.Adapters.DrawerLayoutAdapter")
            click_method = DrawerLayoutAdapter.getClass().getDeclaredMethod("click", 
                jclass("android.view.View"), 
                jclass("java.lang.Integer").TYPE)
            click_method.setAccessible(True)
            
            class DrawerClickHook:
                def __init__(self, plugin):
                    self.plugin = plugin
                
                def before_hooked_method(self, param):
                    try:
                        adapter = param.thisObject
                        position = int(param.args[1])
                        
                        getId_method = adapter.getClass().getDeclaredMethod("getId", jclass("java.lang.Integer").TYPE)
                        getId_method.setAccessible(True)
                        
                        from java.lang import Integer
                        item_id = getId_method.invoke(adapter, Integer(position))
                        
                        if item_id == 1003:
                            self._open_gift_sheet()
                            param.setResult(True)
                            
                    except Exception:
                        pass
                
                def _open_gift_sheet(self):
                    try:
                        def open_sheet():
                            try:
                                current_account = UserConfig.selectedAccount
                                client_user_id = UserConfig.getInstance(current_account).getClientUserId()
                                
                                if not hasattr(LaunchActivity, 'instance') or LaunchActivity.instance is None:
                                    return
                                
                                launch_activity = LaunchActivity.instance
                                
                                getSafeLastFragment_method = launch_activity.getClass().getDeclaredMethod("getSafeLastFragment")
                                getSafeLastFragment_method.setAccessible(True)
                                last_fragment = getSafeLastFragment_method.invoke(launch_activity)
                                
                                if last_fragment is None or last_fragment.getContext() is None:
                                    return
                                
                                GiftSheet = jclass("org.telegram.ui.Gifts.GiftSheet")
                                gift_sheet = GiftSheet(
                                    last_fragment.getContext(),
                                    current_account,
                                    client_user_id,
                                    None,
                                    None
                                )
                                gift_sheet.show()
                                
                            except Exception:
                                pass
                        
                        run_on_ui_thread(open_sheet)
                        
                    except Exception:
                        pass
            
            self.hook_gift_drawer_click_ref = self.hook_method(click_method, DrawerClickHook(self))
            
        except Exception:
            pass
    
    def _hook_gift_drawer_cell(self):
        try:
            DrawerActionCell = jclass("org.telegram.ui.Cells.DrawerActionCell")
            onDraw_method = DrawerActionCell.getClass().getDeclaredMethod("onDraw", jclass("android.graphics.Canvas"))
            onDraw_method.setAccessible(True)
            
            class DrawerCellDrawHook:
                def __init__(self, plugin):
                    self.plugin = plugin
                
                def after_hooked_method(self, param):
                    try:
                        cell = param.thisObject
                        canvas = param.args[0]
                        
                        currentId_field = cell.getClass().getDeclaredField("currentId")
                        currentId_field.setAccessible(True)
                        current_id = currentId_field.getInt(cell)
                        
                        if current_id != 1003:
                            return
                        
                        from org.telegram.ui.Stars import StarsController
                        from android.graphics import RectF
                        
                        current_account = UserConfig.selectedAccount
                        balance = StarsController.getInstance(current_account).getBalance()
                        if balance is None:
                            return
                        
                        counter = balance.amount
                        text = str(counter)
                        
                        star_drawable = cell.getContext().getResources().getDrawable(R_tg.drawable.star_small_inner).mutate()
                        star_size = AndroidUtilities.dp(17)
                        
                        countTop = AndroidUtilities.dp(12.5)
                        textWidth = int(Theme.dialogs_countTextPaint.measureText(text))
                        countWidth = max(AndroidUtilities.dp(10), textWidth + star_size + AndroidUtilities.dp(4))
                        countLeft = cell.getMeasuredWidth() - countWidth - AndroidUtilities.dp(25)
                        
                        x = countLeft - AndroidUtilities.dp(5.5)
                        
                        rect = RectF()
                        rect.set(x, countTop, x + countWidth + AndroidUtilities.dp(14), countTop + AndroidUtilities.dp(23))
                        
                        canvas.drawRoundRect(rect, 11.5 * AndroidUtilities.density, 11.5 * AndroidUtilities.density, Theme.dialogs_countGrayPaint)
                        
                        text_x = rect.left + (rect.width() - textWidth - star_size - AndroidUtilities.dp(4)) / 2
                        canvas.drawText(text, text_x, countTop + AndroidUtilities.dp(16), Theme.dialogs_countTextPaint)
                        
                        star_x = int(text_x + textWidth + AndroidUtilities.dp(4))
                        star_y = int(countTop + (AndroidUtilities.dp(23) - star_size) / 2)
                        star_drawable.setBounds(star_x, star_y, star_x + star_size, star_y + star_size)
                        star_drawable.draw(canvas)
                        
                    except Exception:
                        pass
            
            self.hook_gift_drawer_cell_ref = self.hook_method(onDraw_method, DrawerCellDrawHook(self))
            
        except Exception:
            pass
    
    def pre_request_hook(self, request_name: str, account: int, request):
        if request_name == "TL_messages_forwardMessages" and self.no_quote_requested and hasattr(request, 'drop_author'):
            request.drop_author = True
            self.no_quote_requested = False
            return HookResult(strategy=HookStrategy.MODIFY, request=request)
        
        if request_name == "TL_messages_forwardMessages" and self.get_setting("send_comments_after_forward", False):
            if not hasattr(request, "to_peer") or request.to_peer is None:
                return HookResult()
            try:
                peer = DialogObject.getPeerDialogId(request.to_peer)
            except Exception:
                return HookResult()
            if not peer:
                return HookResult()
            entry = self._send_comments_pending.pop(peer, None)
            if entry is not None:
                params, acc = entry
                self.log(f"forward_match {peer}")
                def after_forward():
                    def send_on_main_thread():
                        self._send_comments_bypass = True
                        try:
                            SendMessagesHelper.getInstance(acc).sendMessage(params)
                        finally:
                            self._send_comments_bypass = False
                    run_on_ui_thread(send_on_main_thread)
                run_on_queue(after_forward, PLUGINS_QUEUE, 400)
            return HookResult()
        
        return HookResult()
    


    def _show_performance_warning(self):
        try:
            client_name = "AyuGram"
            try:
                ctx = ApplicationLoader.applicationContext
                pkg = ctx.getPackageName()
                if pkg == "com.exteragram.messenger":
                    client_name = "exteraGram"
            except Exception:
                pass
            
            description_template = get_text("performance_warning_description", 
                "UiTweaks adds advanced features in {client_name} but may impact device performance over time.")
            description_text = description_template.replace("{client_name}", client_name)

            memory_warning_enabled = self.get_setting("enable_memory_warning", True)
            button_text = get_text("disable_memory_warning", "Disable Memory Warning") if memory_warning_enabled else get_text("enable_memory_warning", "Enable Memory Warning")

            def on_button_click():
                current_setting = self.get_setting("enable_memory_warning", True)
                self.set_setting("enable_memory_warning", not current_setting)
                self._apply_hooks()

            def on_sticker_long_click(bottom_sheet_instance=None):
                self._perform_haptic()
                current_debug_setting = self.get_setting("show_logs", False)
                new_debug_setting = not current_debug_setting
                self.set_setting("show_logs", new_debug_setting)
                
                if bottom_sheet_instance and hasattr(bottom_sheet_instance, 'update_status'):
                    enabled_text = get_text("enabled", "Enabled")
                    disabled_text = get_text("disabled", "Disabled")
                    debug_logging_text = get_text("debug_logging", "Debug logging")
                    status_text = f"{debug_logging_text}: {enabled_text if new_debug_setting else disabled_text}"
                    bottom_sheet_instance.update_status(status_text)

            showupdatebottomsheet(
                title=get_text("performance_warning", "Performance Warning"),
                subtitle=get_text("performance_warning_subtitle", "Important Information"),
                description=description_text,
                github_url=None,
                plugin_name="UiTweaks_PerformanceInfo",
                sticker_pack="lidreron",
                sticker_index=26,
                button_text=button_text,
                on_button_click=on_button_click,
                on_sticker_long_click=on_sticker_long_click,
                bottom_text=get_text("performance_warning_footer", 
                    "For optimal performance, consider reviewing your enabled features regularly and keeping only what you need active."),
                show_language_selector=False,
                show_user_avatar=False,
                description_centered=True
            )
        except Exception as e:
            self.log(f"Error showing performance warning: {e}")

    def _show_confirmation_selector(self):
        confirmation_items = [
            get_text("item_stickers", "Stickers"),
            get_text("item_voice_messages", "Voice Messages"), 
            get_text("item_bot_commands", "Bot Commands"),
            get_text("item_video_messages", "Video Messages"),
            get_text("item_video_files", "Video Files"),
            get_text("item_photos", "Photos"),
            get_text("item_documents", "Documents"),
            get_text("item_gifs", "GIFs"),
            get_text("item_forward", "Forward"),
            get_text("item_join_chat", "Join Chat"),
            get_text("item_external_links", "External Links")
        ]
        
        confirmation_keys = [
            "confirm_stickers", "confirm_voice", "confirm_commands", "confirm_round_video",
            "confirm_video_file", "confirm_photo", "confirm_document", "confirm_gif", 
            "confirm_forward", "confirm_join_chat", "confirm_external_links"
        ]
        
        showmultiselector(
            items=confirmation_items,
            title=get_text("confirmation_settings", "Confirmation Settings"),
            subtitle=get_text("select_items", "Select which actions require confirmation"),
            setting_keys=confirmation_keys,
            plugin_instance=self,
            action_text=get_text("apply", "Apply")
        )

    def _show_star_reaction_selector(self):
        star_reaction_items = [
            get_text("item_reaction_menu", "Reaction Menu"),
            get_text("item_message_cells", "Message Cells")
        ]
        
        star_reaction_keys = [
            "star_reaction_hide_menu", "star_reaction_hide_cells"
        ]
        
        showmultiselector(
            items=star_reaction_items,
            title=get_text("star_reaction_hide_location", "Hide Star Reactions From"),
            subtitle=get_text("select_items", "Select where to hide star reactions"),
            setting_keys=star_reaction_keys,
            plugin_instance=self,
            action_text=get_text("apply", "Apply")
        )

    def _show_progress_timestamp_selector(self):
        progress_timestamp_items = [
            get_text("progress_timestamp_voice", "Voice Messages"),
            get_text("progress_timestamp_video", "Video Messages")
        ]
        
        progress_timestamp_keys = [
            "voice_message_time_display", "round_video_time_display"
        ]
        
        showmultiselector(
            items=progress_timestamp_items,
            title=get_text("progress_timestamp_types", "Message Types"),
            subtitle=get_text("progress_timestamp_subtitle", "Select message types"),
            setting_keys=progress_timestamp_keys,
            plugin_instance=self,
            action_text=get_text("apply", "Apply")
        )

    def _show_dont_auto_play_selector(self):
        dont_auto_play_items = [
            get_text("dont_auto_play_voice", "Voice Messages"),
            get_text("dont_auto_play_video", "Video Messages")
        ]
        
        dont_auto_play_keys = [
            "dont_auto_play_next_voice", "dont_auto_play_next_video"
        ]
        
        showmultiselector(
            items=dont_auto_play_items,
            title=get_text("dont_auto_play_types", "Message Types"),
            subtitle=get_text("dont_auto_play_subtitle", "Select message types"),
            setting_keys=dont_auto_play_keys,
            plugin_instance=self,
            action_text=get_text("apply", "Apply")
        )

    def _setup_confirmation_hooks(self):
        try:
            send_helper_instance = get_send_messages_helper()
            if not send_helper_instance:
                pass
                return
            send_helper_class = send_helper_instance.getClass()

            send_params_class = jclass("org.telegram.messenger.SendMessagesHelper$SendMessageParams")

            send_message_method = send_helper_class.getDeclaredMethod("sendMessage", send_params_class)
            send_message_method.setAccessible(True)

            self.unhook_send_message = self.hook_method(send_message_method, self.hook_handler)
            pass
            
            chat_enter_view_class = find_class("org.telegram.ui.Components.ChatActivityEnterView")
            set_command_method = chat_enter_view_class.getClass().getDeclaredMethod("setCommand", 
                find_class("org.telegram.messenger.MessageObject").getClass(),
                find_class("java.lang.String").getClass(),
                find_class("java.lang.Boolean").TYPE,
                find_class("java.lang.Boolean").TYPE)
            set_command_method.setAccessible(True)
            
            self.unhook_set_command = self.hook_method(set_command_method, SetCommandHook(self))
            
        except Exception as e:
            pass

    def _setup_deeplink_hooks(self):
        try:
            if self.get_setting("confirm_deeplinks", True) or self.get_setting("confirm_ayugram_deeplinks", True):
                launch_activity_cls = find_class("org.telegram.ui.LaunchActivity")
                
                method = launch_activity_cls.getClass().getDeclaredMethod("handleIntent", 
                    find_class("android.content.Intent").getClass(),
                    find_class("java.lang.Boolean").TYPE,
                    find_class("java.lang.Boolean").TYPE,
                    find_class("java.lang.Boolean").TYPE,
                    find_class("org.telegram.messenger.browser.Browser$Progress").getClass(),
                    find_class("java.lang.Boolean").TYPE,
                    find_class("java.lang.Boolean").TYPE)
                method.setAccessible(True)
                
                self.unhook_deeplink = self.hook_method(method, DeepLinkHook(self))
                pass
                
        except Exception as e:
            pass


    def _hook_dialogs_activity(self):
        try:
            cls = find_class("org.telegram.ui.DialogsActivity")
            method = cls.getClass().getDeclaredMethod("onResume")
            ref = self.hook_method(method, DialogsActivityHook(self))
            self.hook_dialogs_ref = ref
            
            try:
                destroy_method = cls.getClass().getDeclaredMethod("onDestroy")
                destroy_ref = self.hook_method(destroy_method, DialogsActivityDestroyHook(self))
                self.hook_dialogs_destroy_ref = destroy_ref
            except Exception:
                pass
                
        except Exception as e:
            pass

    def _hook_dialog_cell(self):
        try:
            cls = find_class("org.telegram.ui.Cells.DialogCell")
            boolean_class = find_class("java.lang.Boolean").TYPE
            method = cls.getClass().getDeclaredMethod("setOpenBotButton", boolean_class)
            if method is not None:
                ref = self.hook_method(method, DialogCellHook(self))
                self.hook_dialog_cell_ref = ref
            pass
        except Exception as e:
            pass

    def _hook_photo_cell(self):
        try:
            if self.get_setting("hide_hd_icon", False):
                hook_instance = SendImageWithHighQualityByDefault(self)
                hook_instance.onHook()
        except Exception as e:
            pass





    def _hook_swipe_prevention(self):
        try:
            cls = find_class("org.telegram.ui.ChatActivity")
            if cls:
                method = cls.getClass().getDeclaredMethod("isSwipeBackEnabled", 
                    find_class("android.view.MotionEvent").getClass())
                method.setAccessible(True)
                ref = self.hook_method(method, SwipePreventionHook(self))
                self.hook_swipe_prevention_ref = ref
            pass
        except Exception as e:
            pass

    def _setup_fab_settings_listener(self, dialogs_activity):
        try:
            large_btn = get_private_field(dialogs_activity, "floatingButtonContainer")
            if large_btn is None:
                return
            
            if hasattr(large_btn, '_uitweaks_listener_set'):
                return
            
            def handle_fab_long_press(*args):
                try:
                    try:
                        root = dialogs_activity.getParentActivity().getWindow().getDecorView()
                        flags = HapticFeedbackConstants.FLAG_IGNORE_VIEW_SETTING | HapticFeedbackConstants.FLAG_IGNORE_GLOBAL_SETTING
                        root.performHapticFeedback(HapticFeedbackConstants.KEYBOARD_TAP, flags)
                    except:
                        pass
                    
                    action = self.get_setting("fab_action_selector", 0)
                    
                    if self.get_setting("hide_archived_chats", False) and not self.get_setting("hide_archived_from_drawer", False):
                        action = 0
                    
                    if action == 0:
                        java_plugin = PluginsController.getInstance().plugins.get(__id__)
                        if java_plugin:
                            dialogs_activity.presentFragment(PluginSettingsActivity(java_plugin))
                    elif action == 1:
                        self._open_archived_chats_from_fab(dialogs_activity)
                except Exception as e:
                    pass
            
            large_btn.setOnLongClickListener(OnLongClickListener(handle_fab_long_press))
            large_btn._uitweaks_listener_set = True
        except Exception as e:
            pass

    def _hook_article_viewer(self):
        try:
            from android.view import MotionEvent
            cls = find_class("org.telegram.ui.ArticleViewer$WindowView")
            method = cls.getClass().getDeclaredMethod("handleTouchEvent", MotionEvent)
            method.setAccessible(True)
            ref = self.hook_method(method, ArticleViewerFixHook(self))
            self.hook_article_viewer_ref = ref
            pass
        except Exception as e:
            pass

    def _hook_webapp_swipe_prevention(self):
        try:
            swipe_cls = find_class("org.telegram.ui.bots.ChatAttachAlertBotWebViewLayout$WebViewSwipeContainer")
            context_class = jclass("android.content.Context")
            method = swipe_cls.getClass().getDeclaredConstructor(context_class)
            ref = self.hook_method(method, WebAppSwipePreventionHook(self))
            self.hook_webapp_swipe_prevention_ref = ref
        except Exception as e:
            pass

    def _hook_download_manager(self):
        try:
            from java import jclass
            cls = jclass("org.telegram.messenger.DownloadController")
            method = cls.getClass().getDeclaredMethod("hasUnviewedDownloads")
            ref = self.hook_method(method, DownloadManagerHook(self))
            self.hook_download_manager_ref = ref
            pass
        except Exception as e:
            pass

    def _hook_birthday_alert(self):
        try:
            DialogsActivityClass = find_class("org.telegram.ui.DialogsActivity")
            if not DialogsActivityClass:
                return
            
            updateDialogsHintMethod = DialogsActivityClass.getClass().getDeclaredMethod("updateDialogsHint")
            updateDialogsHintMethod.setAccessible(True)
            
            ref = self.hook_method(updateDialogsHintMethod, BirthdayAlertHook(self))
            self.hook_birthday_alert_ref = ref
        except Exception as e:
            pass

    def _hook_proxy_button(self):
        try:
            from java import jclass
            cls = jclass("org.telegram.ui.DialogsActivity")
            method = cls.getClass().getDeclaredMethod("updateProxyButton", jclass("java.lang.Boolean").TYPE, jclass("java.lang.Boolean").TYPE)
            ref = self.hook_method(method, ProxyButtonHook(self))
            self.hook_proxy_button_ref = ref
            pass
        except Exception as e:
            pass

    def _hook_star_reaction_menu(self):
        try:
            reaction_menu_class = find_class("org.telegram.ui.Components.ReactionsContainerLayout")
            method = reaction_menu_class.getClass().getDeclaredMethod("setMessage", 
                find_class("org.telegram.messenger.MessageObject").getClass(),
                find_class("org.telegram.tgnet.TLRPC$ChatFull").getClass(),
                find_class("java.lang.Boolean").TYPE)
            method.setAccessible(True)
            ref = self.hook_method(method, StarReactionMenuHook(self))
            self.hook_star_reaction_menu_ref = ref
            
            method2 = reaction_menu_class.getClass().getDeclaredMethod("setVisibleReactionsList", 
                find_class("java.util.List").getClass(),
                find_class("java.lang.Boolean").TYPE)
            method2.setAccessible(True)
            ref2 = self.hook_method(method2, StarReactionVisibleListHook(self))
            self.hook_star_reaction_visible_list_ref = ref2
            
            method3 = reaction_menu_class.getClass().getDeclaredMethod("dispatchDraw", 
                find_class("android.graphics.Canvas").getClass())
            method3.setAccessible(True)
            ref3 = self.hook_method(method3, StarReactionGradientHook(self))
            self.hook_star_reaction_gradient_ref = ref3
            pass
            
        except Exception as e:
            pass

    def _hook_star_reaction_layout(self):
        try:
            reactions_layout_class = find_class("org.telegram.ui.Components.Reactions.ReactionsLayoutInBubble")
            set_message_method = reactions_layout_class.getClass().getDeclaredMethod("setMessage", 
                find_class("org.telegram.messenger.MessageObject").getClass(),
                find_class("java.lang.Boolean").TYPE,
                find_class("java.lang.Boolean").TYPE,
                find_class("org.telegram.ui.ActionBar.Theme$ResourcesProvider").getClass())
            set_message_method.setAccessible(True)
            ref = self.hook_method(set_message_method, StarReactionLayoutDrawHook(self))
            self.hook_star_reaction_layout_draw_ref = ref
        except Exception as e:
            pass

    def _remove_star_reaction_hooks(self):
        for ref_attr in ("hook_star_reaction_menu_ref", "hook_star_reaction_visible_list_ref", "hook_star_reaction_gradient_ref", "hook_star_reaction_layout_draw_ref"):
            ref = getattr(self, ref_attr, None)
            if ref:
                self.unhook_method(ref)
                setattr(self, ref_attr, None)


    def _hide_elements_on_start(self):
        try:
            fragment = get_last_fragment()
            
            if fragment is not None and fragment.getClass().getSimpleName() == "DialogsActivity":
                action_bar_field = fragment.getClass().getSuperclass().getDeclaredField("actionBar")
                action_bar_field.setAccessible(True)
                action_bar = action_bar_field.get(fragment)
                
                if action_bar is not None:
                    pass
        except Exception as e:
            pass


    def _hide_bot_open_buttons_on_resume(self, dialogs_activity):
        try:
            pass
        except Exception as e:
            pass






    def _setup_open_link_internally_hook(self):
        try:
            chat_activity_class = find_class("org.telegram.ui.ChatActivity")
            chat_message_cell_class = find_class("org.telegram.ui.Cells.ChatMessageCell")
            character_style_class = find_class("android.text.style.CharacterStyle")
            
            string_class = find_class("java.lang.String")
            int_class = find_class("java.lang.Integer").TYPE
            
            try:
                method = chat_activity_class.getClass().getDeclaredMethod(
                    "openLinkInternally",
                    string_class.getClass(),
                    chat_message_cell_class.getClass(),
                    character_style_class.getClass(),
                    int_class,
                    int_class
                )
                method.setAccessible(True)
                self.hook_open_link_internally_ref = self.hook_method(method, OpenLinkInternallyHook(self))
                pass
            except Exception as e:
                pass
                
        except Exception as e:
            pass

    def _setup_browser_open_url_hook(self):
        try:
            browser_class = find_class("org.telegram.messenger.browser.Browser")
            context_class = find_class("android.content.Context")
            uri_class = find_class("android.net.Uri")
            progress_class = find_class("org.telegram.messenger.browser.Browser$Progress")
            method = browser_class.getClass().getDeclaredMethod(
                "openUrl",
                context_class.getClass(),
                uri_class.getClass(),
                bool,
                bool,
                bool,
                progress_class.getClass(),
                str,
                bool,
                bool,
                bool
            )
            method.setAccessible(True)
            self.hook_browser_open_url_ref = self.hook_method(method, BrowserOpenUrlHook(self))
            pass
        except Exception as e:
            pass


    def _setup_open_profile_hooks(self):

        pass

    def _hook_phone_number(self):
        try:
            PhoneFormat = jclass("org.telegram.PhoneFormat.PhoneFormat")
            method = PhoneFormat.getClass().getDeclaredMethod("format", jclass("java.lang.String"))
            method.setAccessible(True)
            self.hook_phone_number_ref = self.hook_method(method, PhoneFormatHook(self))
        except:
            pass

    def _hook_messages_controller(self):
        try:
            from java import jclass
            
            method = jclass("org.telegram.messenger.MessagesController").getClass().getDeclaredMethod("getDialogs", jclass("java.lang.Integer").TYPE)
            method.setAccessible(True)
            ref = self.hook_method(method, MessagesControllerGetDialogsHook(self))
            
            self.hook_messages_controller_ref = ref
            pass

                
        except Exception as e:
            pass

    def _hook_chat_utils_has_archived(self):
        try:
            from java import jclass
            
            chat_utils_class = jclass("com.exteragram.messenger.utils.ChatUtils")
            method = chat_utils_class.getClass().getDeclaredMethod("hasArchivedChats")
            method.setAccessible(True)
            ref = self.hook_method(method, ChatUtilsHasArchivedHook(self))
            
            self.hook_chat_utils_has_archived_ref = ref
        except Exception as e:
            pass

    def _hook_extera_config_archived(self):
        try:
            from java import jclass
            
            extera_config_class = jclass("com.exteragram.messenger.ExteraConfig")
            method = extera_config_class.getClass().getDeclaredMethod("setObj", jclass("java.lang.String"), jclass("java.lang.Boolean").TYPE)
            method.setAccessible(True)
            ref = self.hook_method(method, ExteraConfigArchivedHook(self))
            
            self.hook_extera_config_archived_ref = ref
        except Exception as e:
            pass

    def _hook_send_typing_method(self):
        try:
            from java import jclass
            from java.lang import Long, Integer, String as JString
            
            method = jclass("org.telegram.messenger.MessagesController").getClass().getDeclaredMethod(
                "sendTyping", 
                Long.TYPE, Long.TYPE, Integer.TYPE, JString, Integer.TYPE
            )
            method.setAccessible(True)
            ref = self.hook_method(method, MessagesControllerSendTypingHook(self))
            
            if not hasattr(self, 'hook_send_typing_refs'):
                self.hook_send_typing_refs = []
            self.hook_send_typing_refs.append(ref)
        except Exception:
            pass

    def _hook_update_bot_button(self):
        try:
            ChatActivityEnterView = find_class("org.telegram.ui.Components.ChatActivityEnterView")
            boolean_class = find_class("java.lang.Boolean").TYPE
            method = ChatActivityEnterView.getClass().getDeclaredMethod("updateBotButton", boolean_class)
            method.setAccessible(True)
            self.hook_update_bot_button_ref = self.hook_method(method, UpdateBotButtonHook(self))
            pass
        except Exception as e:
            pass



    def _hook_voice_message_control(self):
        try:
            MediaControllerClass = jclass("org.telegram.messenger.MediaController")
            java_class = MediaControllerClass.getClass()
            
            method = java_class.getDeclaredMethod(
                "cleanupPlayer", 
                jclass("java.lang.Boolean").TYPE,
                jclass("java.lang.Boolean").TYPE,
                jclass("java.lang.Boolean").TYPE,
                jclass("java.lang.Boolean").TYPE
            )
            method.setAccessible(True)
            self.hook_voice_message_control_ref = self.hook_method(method, VoiceMessageControlHook(self))
            pass
            
        except Exception as e:
            pass

    def _hook_video_message_control(self):
        try:
            MediaControllerClass = jclass("org.telegram.messenger.MediaController")
            java_class = MediaControllerClass.getClass()
            
            method = java_class.getDeclaredMethod(
                "cleanupPlayer", 
                jclass("java.lang.Boolean").TYPE,
                jclass("java.lang.Boolean").TYPE,
                jclass("java.lang.Boolean").TYPE,
                jclass("java.lang.Boolean").TYPE
            )
            method.setAccessible(True)
            self.hook_video_message_control_ref = self.hook_method(method, VideoMessageControlHook(self))
            pass
            
        except Exception as e:
            pass

    def _apply_delete_with_duration_hooks(self):
        if hasattr(self, 'delete_with_duration_fillitems_ref') and self.delete_with_duration_fillitems_ref:
            self.unhook_method(self.delete_with_duration_fillitems_ref)
            self.delete_with_duration_fillitems_ref = None
        if hasattr(self, 'delete_with_duration_onclick_ref') and self.delete_with_duration_onclick_ref:
            self.unhook_method(self.delete_with_duration_onclick_ref)
            self.delete_with_duration_onclick_ref = None
        
        if self.get_setting("enable_delete_with_duration", False):
            self._hook_delete_with_duration()

    def _hook_delete_with_duration(self):
        try:
            DeleteMessagesBottomSheet = find_class("org.telegram.ui.Components.DeleteMessagesBottomSheet")
            ArrayList = find_class("java.util.ArrayList")
            UniversalAdapter = find_class("org.telegram.ui.Components.UniversalAdapter")
            UItem = find_class("org.telegram.ui.Components.UItem")
            View = find_class("android.view.View")
            Integer = find_class("java.lang.Integer")
            Float = find_class("java.lang.Float")
            
            if not DeleteMessagesBottomSheet:
                self.log("Failed to find DeleteMessagesBottomSheet class")
                return
            
            fillItems_method = DeleteMessagesBottomSheet.getClass().getDeclaredMethod("fillItems", ArrayList.getClass(), UniversalAdapter.getClass())
            fillItems_method.setAccessible(True)
            
            onClick_method = DeleteMessagesBottomSheet.getClass().getDeclaredMethod("onClick", UItem.getClass(), View.getClass(), Integer.TYPE, Float.TYPE, Float.TYPE)
            onClick_method.setAccessible(True)
            
            self.delete_with_duration_fillitems_ref = self.hook_method(fillItems_method, DeleteWithDurationFillItemsHook(self))
            self.delete_with_duration_onclick_ref = self.hook_method(onClick_method, DeleteWithDurationOnClickHook(self))
            
        except Exception as e:
            self.log(f"Failed to hook delete with duration: {e}")
            import traceback
            traceback.print_exc()

    def _hook_voice_message_time_display(self):
        try:
            ChatMessageCellClass = jclass("org.telegram.ui.Cells.ChatMessageCell")
            updatePlayingMessageProgressMethod = ChatMessageCellClass.getClass().getDeclaredMethod("updatePlayingMessageProgress")
            updatePlayingMessageProgressMethod.setAccessible(True)
            
            self.hook_voice_message_time_display_ref = self.hook_method(updatePlayingMessageProgressMethod, VoiceMessageTimeDisplayHook(self))
        except Exception as e:
            pass

    def _hook_unread_badge(self):
        try:
            ChatActivityClass = jclass("org.telegram.ui.ChatActivity")
            chat_java_class = ChatActivityClass.getClass()
            
            onResume_method = chat_java_class.getDeclaredMethod("onResume")
            onResume_method.setAccessible(True)
            self.hook_unread_badge_ref = self.hook_method(onResume_method, UnreadBadgeHook(self))
            pass
            
        except Exception as e:
            pass

    def _hook_gif_spoiler(self):
        try:
            SHOW_SHEET_RUNNABLE = find_class("org.telegram.ui.ContentPreviewViewer$1")
            method = SHOW_SHEET_RUNNABLE.getClass().getDeclaredMethod("run")
            method.setAccessible(True)
            self.hook_gif_spoiler_ref = self.hook_method(method, GifSpoilerHook(self))
            
            ContentPreviewViewer = find_class("org.telegram.ui.ContentPreviewViewer")
            dismiss_method = ContentPreviewViewer.getClass().getDeclaredMethod("dismissPopupWindow")
            dismiss_method.setAccessible(True)
            self.hook_gif_dismiss_ref = self.hook_method(dismiss_method, GifDismissHook(self))
            self.log("GIF Menu: Hooked both show and dismiss methods")
        except Exception as e:
            self.log(f"GIF Menu: Error hooking GIF methods: {e}")
            pass

    def _hook_process_external_url(self):
        try:
            ChatActivityClass = find_class("org.telegram.ui.ChatActivity")
            method = ChatActivityClass.getClass().getDeclaredMethod(
                "processExternalUrl", 
                find_class("java.lang.Integer").TYPE,
                find_class("java.lang.String").getClass(),
                find_class("android.text.style.CharacterStyle").getClass(),
                find_class("org.telegram.ui.Cells.ChatMessageCell").getClass(),
                find_class("java.lang.Boolean").TYPE,
                find_class("java.lang.Boolean").TYPE
            )
            method.setAccessible(True)
            self.hook_process_external_url_ref = self.hook_method(method, ProcessExternalUrlHook(self))
        except Exception as e:
            pass


    def _hook_forward_confirmation(self):
        try:
            if getattr(self, 'hook_forward_confirmation_ref', None):
                return
            chat_cls = find_class("org.telegram.ui.ChatActivity")
            method = chat_cls.getClass().getDeclaredMethod(
                "forwardMessages",
                find_class("java.util.ArrayList").getClass(),
                find_class("java.lang.Boolean").TYPE,
                find_class("java.lang.Boolean").TYPE,
                find_class("java.lang.Boolean").TYPE,
                find_class("java.lang.Integer").TYPE,
                find_class("java.lang.Long").TYPE
            )
            method.setAccessible(True)
            self.hook_forward_confirmation_ref = self.hook_method(method, ForwardConfirmationHook(self, method))
            pass
        except Exception as e:
            pass

    def _hook_join_confirmation(self):
        try:
            if getattr(self, 'hook_join_confirmation_ref', None):
                return
            chat_activity_class = find_class("org.telegram.ui.ChatActivity")
            context_class = find_class("android.content.Context")
            
            if not chat_activity_class or not context_class:
                return

            create_view_method = chat_activity_class.getClass().getDeclaredMethod("createView", context_class)
            self.hook_join_confirmation_ref = self.hook_method(create_view_method, JoinConfirmationHook(self))
            
        except Exception as e:
            pass

    def _hook_code_formatting(self):
        try:
            ChatActivity = find_class("org.telegram.ui.ChatActivity")
            EditTextCaption = find_class("org.telegram.ui.Components.EditTextCaption")
            
            if ChatActivity is None or EditTextCaption is None:
                return
            
            boolean_type = find_class("java.lang.Boolean").TYPE
            fillActionModeMenu_method = ChatActivity.getClass().getDeclaredMethod("fillActionModeMenu", 
                find_class("android.view.Menu"), 
                jclass("org.telegram.tgnet.TLRPC$EncryptedChat"), 
                boolean_type)
            fillActionModeMenu_method.setAccessible(True)
            
            performMenuAction_method = EditTextCaption.getClass().getDeclaredMethod("performMenuAction", 
                find_class("java.lang.Integer").TYPE)
            performMenuAction_method.setAccessible(True)
            
            self.hook_fill_action_mode_menu_ref = self.hook_method(fillActionModeMenu_method, FillActionModeMenuHook(self))
            self.hook_perform_menu_action_ref = self.hook_method(performMenuAction_method, PerformMenuActionHook(self))
            
        except Exception as e:
            traceback.print_exc()

    def _make_selected_code(self, edit_text):
        try:
            start = edit_text.getSelectionStart()
            end = edit_text.getSelectionEnd()
            
            if start < 0 or end < 0 or start == end:
                return
            
            context = edit_text.getContext()
            
            language_edit_text = EditTextBoldCursor(context)
            language_edit_text.setHint("Language")
            language_edit_text.setInputType(InputType.TYPE_CLASS_TEXT)
            language_edit_text.setMaxLines(1)
            language_edit_text.setSingleLine(True)
            language_edit_text.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 16)
            language_edit_text.setTextColor(Theme.getColor(Theme.key_dialogTextBlack))
            language_edit_text.setHintTextColor(Theme.getColor(Theme.key_dialogTextHint))
            language_edit_text.setBackground(None)
            language_edit_text.setCursorColor(Theme.getColor(Theme.key_dialogTextLink))
            language_edit_text.setCursorWidth(1.5)
            language_edit_text.setPadding(AndroidUtilities.dp(12), AndroidUtilities.dp(12), AndroidUtilities.dp(12), AndroidUtilities.dp(12))
            
            try:
                text = edit_text.getText()
                if text:
                    code_spans = text.getSpans(start, end, CodeHighlighting.Span)
                    if code_spans:
                        for span in code_spans:
                            if span.lng:
                                language_edit_text.setText(span.lng)
                                break
            except:
                pass
            
            def on_ok_click(dialog, which):
                language = language_edit_text.getText().toString()
                self._apply_code_formatting(edit_text, start, end, language)
                dialog.dismiss()
            
            builder = AlertDialogBuilder(context)
            builder.set_title(get_text("create_code_dialog_title", "Create Code"))
            builder.set_view(language_edit_text)
            builder.set_positive_button(get_text("ok", "OK"), on_ok_click)
            builder.set_negative_button(get_text("cancel", "Cancel"), lambda d, w: d.dismiss())
            builder.show()
            
        except Exception as e:
            traceback.print_exc()
    
    def _apply_code_formatting(self, edit_text, start, end, language):
        try:
            editable = edit_text.getText()
            if editable is None:
                return
            
            try:
                code_spans = editable.getSpans(start, end, CodeHighlighting.Span)
                if code_spans:
                    for span in code_spans:
                        editable.removeSpan(span)
            except:
                pass
            
            code_span = CodeHighlighting.Span(True, 0, None, language, editable.subSequence(start, end).toString())
            editable.setSpan(code_span, start, end, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE)
            
            try:
                delegate = get_private_field(edit_text, "delegate")
                if delegate and hasattr(delegate, 'onSpansChanged'):
                    delegate.onSpansChanged()
            except:
                pass
            
        except Exception as e:
            traceback.print_exc()
    
    def _make_selected_mention(self, edit_text):
        try:
            start = edit_text.getSelectionStart()
            end = edit_text.getSelectionEnd()
            
            if start < 0 or end < 0 or start == end:
                return
            
            context = edit_text.getContext()
            
            mention_edit_text = EditTextBoldCursor(context)
            mention_edit_text.setHint(get_text("mention_id_hint", "ID"))
            mention_edit_text.setInputType(InputType.TYPE_CLASS_TEXT)
            mention_edit_text.setMaxLines(1)
            mention_edit_text.setSingleLine(True)
            mention_edit_text.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 18)
            mention_edit_text.setTextColor(Theme.getColor(Theme.key_dialogTextBlack))
            mention_edit_text.setHintTextColor(Theme.getColor(Theme.key_dialogTextHint))
            mention_edit_text.setBackground(None)
            mention_edit_text.setCursorColor(Theme.getColor(Theme.key_dialogTextLink))
            mention_edit_text.setCursorWidth(1.5)
            mention_edit_text.setPadding(AndroidUtilities.dp(12), AndroidUtilities.dp(12), AndroidUtilities.dp(12), AndroidUtilities.dp(12))
            
            try:
                text = edit_text.getText()
                if text:
                    mention_spans = text.getSpans(start, end, URLSpanUserMention)
                    if mention_spans:
                        for span in mention_spans:
                            if span.getURL():
                                mention_edit_text.setText(span.getURL())
                                break
            except:
                pass
            
            class DialogOkClick:
                def __init__(self, plugin, edit_text_ref, start, end, mention_edit_text):
                    self.plugin_ref = weakref.ref(plugin)
                    self.edit_text_ref = weakref.ref(edit_text)
                    self.start = start
                    self.end = end
                    self.mention_edit_text = mention_edit_text

                def __call__(self, dialog, which):
                    plugin = self.plugin_ref()
                    edit_text = self.edit_text_ref()

                    if plugin is None or edit_text is None:
                        dialog.dismiss()
                        return

                    mention_id = self.mention_edit_text.getText().toString()
                    plugin._apply_mention_formatting(edit_text, self.start, self.end, mention_id)
                    dialog.dismiss()

            on_ok_click_listener = DialogOkClick(self, edit_text, start, end, mention_edit_text)
            
            builder = AlertDialogBuilder(context)
            builder.set_title(get_text("create_mention_dialog_title", "Create Mention"))
            builder.set_view(mention_edit_text)
            builder.set_positive_button(get_text("ok", "OK"), on_ok_click_listener)
            builder.set_negative_button(get_text("cancel", "Cancel"), lambda d, w: d.dismiss())
            builder.show()
            
        except Exception as e:
            traceback.print_exc()
    
    def _apply_mention_formatting(self, edit_text, start, end, mention_id):
        try:
            editable = edit_text.getText()
            if editable is None:
                return
            
            try:
                character_spans = editable.getSpans(start, end, CharacterStyle)
                if character_spans:
                    for span in character_spans:
                        span_start = editable.getSpanStart(span)
                        span_end = editable.getSpanEnd(span)
                        editable.removeSpan(span)
                        if span_start < start:
                            editable.setSpan(span, span_start, start, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE)
                        if span_end > end:
                            editable.setSpan(span, end, span_end, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE)
            except:
                pass
            
            try:
                mention_span = URLSpanUserMention(mention_id, 3)
                editable.setSpan(mention_span, start, end, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE)
            except:
                pass
            
            try:
                delegate = get_private_field(edit_text, "delegate")
                if delegate and hasattr(delegate, 'onSpansChanged'):
                    delegate.onSpansChanged()
            except:
                pass
            
        except Exception as e:
            traceback.print_exc()

    def _preload_recent_chats(self):
        current_account = UserConfig.selectedAccount
        self.recent_manager.get_recent_dialogs(current_account)
    
    def refresh_recent_chats(self, account_id: int):
        self.recent_manager.force_reload(account_id)

    def _setup_recent_chats_back_button_listener(self, dialogs_activity):
        action_bar = dialogs_activity.getActionBar()
        if action_bar:
            back_button = action_bar.getBackButton()
            if back_button:
                def long_click_handler(*args):
                    try:
                        view = args[0] if len(args) > 0 else back_button
                        self._perform_haptic(dialogs_activity)
                        return self._on_recent_chats_drawer_button_long_click(dialogs_activity, view)
                    except Exception as e:
                        return False
                
                back_button.setOnLongClickListener(OnLongClickListener(long_click_handler))
    
    def _on_recent_chats_drawer_button_long_click(self, dialogs_activity, drawer_button):
        if self._can_show_recent_menu(dialogs_activity):
            current_account = dialogs_activity.getCurrentAccount()
            self.popup_manager.show(current_account, dialogs_activity, drawer_button)
            return True
        return False
    
    def _can_show_recent_menu(self, dialogs_activity):
        searching = get_private_field(dialogs_activity, "searching")
        if searching:
            return False
        
        filter_tabs_view = get_private_field(dialogs_activity, "filterTabsView")
        if filter_tabs_view and filter_tabs_view.isEditing():
            return False
        
        action_bar = dialogs_activity.getActionBar()
        if action_bar and action_bar.isActionModeShowed():
            return False
        
        return True


    def _hook_recent_chats_activities(self):
        ChatActivity = find_class("org.telegram.ui.ChatActivity")
        if ChatActivity:
            method = ChatActivity.getClass().getDeclaredMethod("onResume")
            method.setAccessible(True)
            self.hook_recent_chats_activity_ref = self.hook_method(method, self._create_recent_chats_chat_activity_hook())
        
        ProfileActivity = find_class("org.telegram.ui.ProfileActivity")
        if ProfileActivity:
            method = ProfileActivity.getClass().getDeclaredMethod("onResume")
            method.setAccessible(True)
            self.hook_recent_profile_activity_ref = self.hook_method(method, self._create_recent_chats_profile_activity_hook())
        
        TopicsFragment = find_class("org.telegram.ui.TopicsFragment")
        if TopicsFragment:
            method = TopicsFragment.getClass().getDeclaredMethod("onResume")
            method.setAccessible(True)
            self.hook_recent_topics_fragment_ref = self.hook_method(method, self._create_recent_chats_topics_fragment_hook())
    
    def _create_recent_chats_chat_activity_hook(self):
        class ChatActivityHook:
            def __init__(self, plugin_instance):
                self.plugin_ref = weakref.ref(plugin_instance)
            
            def after_hooked_method(self, param):
                try:
                    plugin = self.plugin_ref()
                    if plugin is None:
                        return
                    chat_activity = param.thisObject
                    if chat_activity:
                        dialog_id = chat_activity.getDialogId()
                        current_account = chat_activity.getCurrentAccount()
                        plugin.recent_manager.add_to_recent_dialogs(current_account, dialog_id)
                except:
                    pass
        
        return ChatActivityHook(self)
    
    def _create_recent_chats_profile_activity_hook(self):
        class ProfileActivityHook:
            def __init__(self, plugin_instance):
                self.plugin_ref = weakref.ref(plugin_instance)
            
            def after_hooked_method(self, param):
                try:
                    plugin = self.plugin_ref()
                    if plugin is None:
                        return
                    profile_activity = param.thisObject
                    if profile_activity:
                        dialog_id = profile_activity.getDialogId()
                        current_account = profile_activity.getCurrentAccount()
                        plugin.recent_manager.add_to_recent_dialogs(current_account, dialog_id)
                except:
                    pass
        
        return ProfileActivityHook(self)
    
    def _create_recent_chats_topics_fragment_hook(self):
        class TopicsFragmentHook:
            def __init__(self, plugin_instance):
                self.plugin_ref = weakref.ref(plugin_instance)
            
            def after_hooked_method(self, param):
                try:
                    plugin = self.plugin_ref()
                    if plugin is None:
                        return
                    topics_fragment = param.thisObject
                    if topics_fragment:
                        chat_id = topics_fragment.getChatId()
                        current_account = topics_fragment.getCurrentAccount()
                        plugin.recent_manager.add_to_recent_dialogs(current_account, -chat_id)
                except:
                    pass
        
        return TopicsFragmentHook(self)

    def _hook_message_preview_view(self):
        try:
            if getattr(self, 'hook_message_preview_view_ref', None):
                return
                
            cls = find_class("org.telegram.ui.Components.MessagePreviewView")
            context_class = jclass("android.content.Context")
            chat_activity_class = find_class("org.telegram.ui.ChatActivity")
            params_class = find_class("org.telegram.messenger.MessagePreviewParams")
            user_class = find_class("org.telegram.tgnet.TLRPC$User")
            chat_class = find_class("org.telegram.tgnet.TLRPC$Chat")
            int_class = jclass("java.lang.Integer").TYPE
            boolean_class = jclass("java.lang.Boolean").TYPE
            resources_class = find_class("org.telegram.ui.Components.MessagePreviewView$ResourcesDelegate")
            
            method = cls.getClass().getDeclaredConstructor(
                context_class, chat_activity_class, params_class, user_class, 
                chat_class, int_class, resources_class, int_class, boolean_class
            )
            self.hook_message_preview_view_ref = self.hook_method(method, MessagePreviewViewHook(self))
        except:
            pass

    def _add_send_media_button(self, preview_view):
        try:
            message_preview_params = get_private_field(preview_view, "messagePreviewParams")
            if not message_preview_params or not message_preview_params.webpage:
                return

            webpage = message_preview_params.webpage
            if not (webpage.photo or webpage.document):
                return

            context = preview_view.getContext()
            resources_provider = get_private_field(preview_view, "resourcesProvider")
            
            ActionBarMenuSubItem = jclass("org.telegram.ui.ActionBar.ActionBarMenuSubItem")
            send_button = ActionBarMenuSubItem(context, False, False, resources_provider)
            
            R = jclass("org.telegram.messenger.R")
            
            if webpage.document:
                if hasattr(message_preview_params, 'isVideo') and message_preview_params.isVideo:
                    text = get_text("send_video", "Send Video")
                else:
                    text = get_text("send_file", "Send File")
            else:
                text = get_text("send_photo", "Send Photo")
            
            send_button.setTextAndIcon(text, R.drawable.msg_send)
            send_button.setVisibility(1 if (webpage.document or webpage.photo) else 8)
            
            def send_media(view=None):
                run_on_ui_thread(lambda: self._send_media(preview_view, webpage))
            
            send_button.setOnClickListener(OnClickListener(send_media))
            
            menu = self._find_send_media_menu(preview_view)
            if menu and hasattr(menu, 'addView'):
                LayoutHelper = jclass("org.telegram.ui.Components.LayoutHelper")
                menu.addView(send_button, LayoutHelper.createLinear(-1, 48))
                self.added_send_media_buttons.add(preview_view)
        except:
            pass

    def _find_send_media_menu(self, view):
        try:
            if hasattr(view, 'getChildCount'):
                for i in range(view.getChildCount()):
                    child = view.getChildAt(i)
                    if child:
                        if "ActionBarPopupWindowLayout" in child.getClass().getSimpleName() and hasattr(child, 'addView'):
                            return child
                        menu = self._find_send_media_menu(child)
                        if menu:
                            return menu
            return None
        except:
            return None

    def _send_media(self, preview_view, webpage):
        try:
            from client_utils import get_last_fragment
            current_fragment = get_last_fragment()
            if not current_fragment:
                return

            dialog_id_field = current_fragment.getClass().getDeclaredField("dialog_id")
            dialog_id_field.setAccessible(True)
            dialog_id = dialog_id_field.getLong(current_fragment)
            if not dialog_id:
                return

            message_preview_params = get_private_field(preview_view, "messagePreviewParams")
            is_video = False
            if message_preview_params and hasattr(message_preview_params, 'isVideo'):
                is_video = message_preview_params.isVideo
            if is_video and webpage.document:
                params = SendMessagesHelper.SendMessageParams.of(
                    webpage.document, None, None, dialog_id, None, None, None, None, None, None, True, 0, 0, webpage, None, False
                )
            elif webpage.photo:
                params = SendMessagesHelper.SendMessageParams.of(
                    webpage.photo, None, dialog_id, None, None, None, None, None, None, True, 0, 0, webpage, False
                )
            elif webpage.document:
                params = SendMessagesHelper.SendMessageParams.of(
                    webpage.document, None, None, dialog_id, None, None, None, None, None, None, True, 0, 0, webpage, None, False
                )
            else:
                return

            send_helper = get_send_messages_helper()
            if send_helper:
                send_helper.sendMessage(params)
                try:
                    if hasattr(preview_view, 'dismiss'):
                        preview_view.dismiss(True)
                except:
                    pass
        except:
            pass

    def show_goto_message_dialog(self, chat_activity):
        try:
            if not chat_activity:
                return
                
            fragment = self._resolve_target_fragment(chat_activity)
            if not fragment:
                return
                
            activity = fragment.getParentActivity()
            if not activity:
                return
            
            current_activity = chat_activity
            message_id_edit_text = EditTextBoldCursor(activity)
            message_id_edit_text.setHint(get_text("message_id_hint", "Message ID"))
            message_id_edit_text.setInputType(InputType.TYPE_CLASS_NUMBER)
            message_id_edit_text.setMaxLines(1)
            message_id_edit_text.setSingleLine(True)
            message_id_edit_text.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 16)
            message_id_edit_text.setTextColor(Theme.getColor(Theme.key_dialogTextBlack))
            message_id_edit_text.setHintTextColor(Theme.getColor(Theme.key_dialogTextHint))
            message_id_edit_text.setBackground(None)
            message_id_edit_text.setCursorColor(Theme.getColor(Theme.key_dialogTextLink))
            message_id_edit_text.setCursorWidth(1.5)
            message_id_edit_text.setPadding(AndroidUtilities.dp(12), AndroidUtilities.dp(12), AndroidUtilities.dp(12), AndroidUtilities.dp(12))
            
            def close_dialog_and_menu(dialog, message_id=None):
                try:
                    AndroidUtilities.hideKeyboard(message_id_edit_text)
                except Exception:
                    pass
                dialog.dismiss()
                try:
                    if current_activity:
                        header_item = self.header_item_field.get(current_activity) if self.header_item_field else None
                        if header_item:
                            header_item.closeSubMenu()
                except Exception:
                    pass
                if message_id:
                    target_fragment = self._resolve_target_fragment(current_activity) if current_activity else fragment
                    if target_fragment:
                        run_on_ui_thread(lambda: self.scroll_to_message(target_fragment, message_id))
            
            def on_ok_click(dialog, which):
                try:
                    message_id_text = message_id_edit_text.getText().toString()
                    message_id = self._validate_message_id(message_id_text)
                    if message_id:
                        close_dialog_and_menu(dialog, message_id)
                        return
                except Exception as e:
                    uitweaks_log(f"Error in on_ok_click: {e}")
                close_dialog_and_menu(dialog)
            
            def on_cancel_click(dialog, which):
                close_dialog_and_menu(dialog)
            
            builder = AlertDialogBuilder(activity)
            builder.set_title(get_text("enter_message_id", "Enter Message ID"))
            builder.set_view(message_id_edit_text)
            builder.set_positive_button(get_text("ok", "OK"), on_ok_click)
            builder.set_negative_button(get_text("cancel", "Cancel"), on_cancel_click)
            
            dialog = builder.show()
            def focus_input():
                try:
                    message_id_edit_text.requestFocus()
                    AndroidUtilities.showKeyboard(message_id_edit_text)
                except Exception:
                    pass
            
            run_on_ui_thread(focus_input, delay=100)
            
        except Exception as e:
            uitweaks_log(f"Error in show_goto_message_dialog: {e}")
    
    def scroll_to_message(self, chat_activity, message_id):
        try:
            if not message_id or message_id <= 0 or not chat_activity:
                return
            chat_activity.scrollToMessageId(message_id, 0, False, 0, False, 0)
        except Exception as e:
            uitweaks_log(f"Error in scroll_to_message: {e}")
    
    def _resolve_target_fragment(self, chat_activity):
        if not chat_activity:
            return get_last_fragment()
        if hasattr(chat_activity, 'fragment') and chat_activity.fragment:
            return chat_activity.fragment
        elif hasattr(chat_activity, 'getParentActivity'):
            return chat_activity
        return get_last_fragment()
    
    def _validate_message_id(self, message_id_text):
        if not message_id_text or not message_id_text.strip():
            return None
        try:
            message_id = int(message_id_text.strip())
            return message_id if message_id > 0 else None
        except ValueError:
            return None

    def _update_goto_message_menu_item(self):
        try:
            self._goto_items_added.clear()
            self._add_goto_message_plugin_subitem()
        except Exception as e:
            uitweaks_log(f"Error in _update_goto_message_menu_item: {e}")
    
    def cleanup_activity_references(self, activity_id):
        try:
            if hasattr(self, '_goto_items_added'):
                self._goto_items_added.discard(activity_id)
        except Exception as e:
            uitweaks_log(f"Error in cleanup_activity_references: {e}")

    
    def _create_summarizer_role(self):
        try:
            from com.exteragram.messenger.ai import AiController
            from com.exteragram.messenger.ai.data import Role
            
            controller = AiController.getInstance()
            
            role_name = "Quanta!"
            existing_role = None
            
            roles_list = controller.getRoles()
            if roles_list:
                for i in range(roles_list.size()):
                    role = roles_list.get(i)
                    if role and role.getName() == role_name:
                        existing_role = role
                        break
            
            if existing_role is None:
                default_prompt = """You are an expert at summarizing chat conversations. Analyze the messages and create a concise summary using paragraphs with bold headings for different topics. Do not use bullet points. Keep it clear and organized, highlighting key points, decisions, and action items. Mention important participants when relevant. Keep the summary within 3-5 paragraphs."""
                
                new_role = Role(role_name, default_prompt)
                controller.addRole(new_role)
        except:
            pass
    
    def _hook_ai_summarize(self):
        self._create_summarizer_role()
        self._hook_chat_action_bar_items()
    
    def _hook_goto_message(self):
        self._hook_chat_action_bar_items()
    
    def _hook_chat_action_bar_items(self):
        if hasattr(self, 'hook_ai_summarize_create_view_ref') and self.hook_ai_summarize_create_view_ref:
            self.chat_action_bar_hooked_activities.clear()
            return
        
        try:
            ChatActivity = find_class("org.telegram.ui.ChatActivity")
            if not ChatActivity:
                return
            
            createViewMethod = ChatActivity.getClass().getDeclaredMethod("createView", jclass("android.content.Context"))
            createViewMethod.setAccessible(True)
            self.hook_ai_summarize_create_view_ref = self.hook_method(createViewMethod, ChatActionBarItemsHook(self))
        except Exception as e:
            self.log(f"Error hooking Chat Action Bar Items: {e}")

    def _is_private_chat(self, chat_activity):
        try:
            return getattr(chat_activity, 'currentUser', None) is not None and getattr(chat_activity, 'currentChat', None) is None
        except:
            return False

    def _get_available_accounts(self, force_refresh=False):
        if force_refresh or not hasattr(self, '_cached_accounts') or self._cached_accounts is None:
            accounts = []
            for account_id in range(UserConfig.MAX_ACCOUNT_COUNT):
                try:
                    user_config = UserConfig.getInstance(account_id)
                    if user_config.isClientActivated():
                        user = user_config.getCurrentUser()
                        if user:
                            unread_main = 0
                            unread_archive = 0
                            try:
                                unread_main = MessagesStorage.getInstance(account_id).getMainUnreadCount()
                                unread_archive = MessagesStorage.getInstance(account_id).getArchiveUnreadCount()
                            except:
                                pass
                            accounts.append({
                                'id': account_id, 
                                'user': user,
                                'unread_main': unread_main,
                                'unread_archive': unread_archive
                            })
                except:
                    continue
            self._cached_accounts = accounts
        return self._cached_accounts
    def _clear_account_cache(self):
        if hasattr(self, '_cached_accounts'):
            self._cached_accounts = None

    def _dismiss_current_popup(self):
        try:
            if hasattr(self, 'current_popup') and self.current_popup:
                if hasattr(self.current_popup, 'isShowing') and self.current_popup.isShowing():
                    self.current_popup.dismiss()
                    self.log("Account switcher: Dismissed current popup")
        except:
            pass
        finally:
            if hasattr(self, 'current_popup'):
                self.current_popup = None

    def _hook_disable_auto_web_login(self):
        try:
            BrowserClass = find_class("org.telegram.messenger.browser.Browser")
            if not BrowserClass:
                return

            java_browser_class = BrowserClass.getClass()
            
            try:
                method = java_browser_class.getDeclaredMethod("openUrl",
                    find_class("android.content.Context").getClass(),
                    find_class("android.net.Uri").getClass(),
                    find_class("java.lang.Boolean").TYPE,
                    find_class("java.lang.Boolean").TYPE,
                    find_class("java.lang.Boolean").TYPE,
                    find_class("org.telegram.messenger.browser.Browser$Progress").getClass(),
                    find_class("java.lang.String").getClass(),
                    find_class("java.lang.Boolean").TYPE,
                    find_class("java.lang.Boolean").TYPE,
                    find_class("java.lang.Boolean").TYPE)
                method.setAccessible(True)
                self.hook_disable_auto_web_login_ref = self.hook_method(method, DisableAutoWebLoginHook(self))
            except Exception as e:
                pass
                
        except Exception as e:
            pass

    def _hook_do_not_share_phone_number(self):
        try:
            self.do_not_share_hook = DoNotSharePhoneNumberHook(self)
            self.do_not_share_hook.setup()
        except Exception:
            self.do_not_share_hook = None

    def _hook_prefer_common_groups_tab(self):
        try:
            SharedMediaLayoutClass = find_class("org.telegram.ui.Components.SharedMediaLayout")
            if not SharedMediaLayoutClass:
                return

            java_class = SharedMediaLayoutClass.getClass()
            
            try:
                method = java_class.getDeclaredMethod("setUserInfo", 
                    find_class("org.telegram.tgnet.TLRPC$UserFull").getClass())
                method.setAccessible(True)
                self.hook_prefer_common_groups_tab_ref = self.hook_method(method, PreferCommonGroupsTabHook(self))
            except Exception as e:
                pass
                
        except Exception as e:
            pass

    def _hook_sender_select_popup(self):
        try:
            SenderSelectPopupClass = find_class("org.telegram.ui.Components.SenderSelectPopup")
            if not SenderSelectPopupClass:
                return

            constructor = SenderSelectPopupClass.getClass().getDeclaredConstructor(
                jclass("android.content.Context"),
                jclass("org.telegram.ui.ChatActivity"),
                jclass("org.telegram.messenger.MessagesController"),
                jclass("org.telegram.tgnet.TLRPC$ChatFull"),
                jclass("org.telegram.tgnet.TLRPC$TL_channels_sendAsPeers"),
                jclass("org.telegram.ui.Components.SenderSelectPopup$OnSelectCallback")
            )
            constructor.setAccessible(True)
            self.hook_method(constructor, SendAsPopupHook(self))

            MessagesControllerClass = find_class("org.telegram.messenger.MessagesController")
            method = MessagesControllerClass.getClass().getDeclaredMethod("setDefaultSendAs", jclass("java.lang.Long").TYPE, jclass("java.lang.Long").TYPE)
            method.setAccessible(True)
            self.hook_method(method, SetDefaultSendAsHook(self))

        except Exception:
            pass

    def _hook_swipe_disable(self):
        try:
            SwipeGestureSettingsViewClass = find_class("org.telegram.ui.Components.SwipeGestureSettingsView")
            if not SwipeGestureSettingsViewClass:
                return

            try:
                SharedConfigClass = find_class("org.telegram.messenger.SharedConfig")
                if SharedConfigClass:
                    getSwipeMethod = SharedConfigClass.getClass().getDeclaredMethod(
                        "getChatSwipeAction",
                        jclass("java.lang.Integer").TYPE
                    )
                    getSwipeMethod.setAccessible(True)

                    class GetSwipeActionHook:
                        def __init__(self, plugin_instance):
                            self.plugin = plugin_instance

                        def after_hooked_method(self, param):
                            try:
                                currentAccount = param.args[0] if param.args else 0
                                result = param.getResult()
                                if result == 5:
                                    MessagesController = jclass("org.telegram.messenger.MessagesController")
                                    if MessagesController.getInstance(currentAccount).dialogFilters.isEmpty():
                                        param.setResult(6)
                            except Exception:
                                pass

                    self.hook_swipe_disable_ref = self.hook_method(getSwipeMethod, GetSwipeActionHook(self))
            except Exception:
                pass
            
            constructor = SwipeGestureSettingsViewClass.getClass().getDeclaredConstructor(
                jclass("android.content.Context"),
                jclass("java.lang.Integer").TYPE
            )
            constructor.setAccessible(True)
            
            class SwipeGestureSettingsViewHook:
                def __init__(self, plugin_instance):
                    self.plugin = plugin_instance
                
                def after_hooked_method(self, param):
                    instance = param.thisObject
                    if instance is None:
                        return
                    
                    try:
                        strings = get_private_field(instance, "strings")
                        backgroundKeys = get_private_field(instance, "backgroundKeys")
                        icons = get_private_field(instance, "icons")

                        Array = jclass("java.lang.reflect.Array")
                        System = jclass("java.lang.System")

                        stringsComponentType = strings.getClass().getComponentType() if strings else None
                        bgComponentType = backgroundKeys.getClass().getComponentType() if backgroundKeys else None
                        iconsComponentType = icons.getClass().getComponentType() if icons else None

                        if strings and Array.getLength(strings) == 6 and stringsComponentType:
                            new_strings = Array.newInstance(stringsComponentType, 7)
                            System.arraycopy(strings, 0, new_strings, 0, 6)
                            try:
                                Array.set(new_strings, 6, get_text("disable", "Disable"))
                            except Exception:
                                pass
                            set_private_field(instance, "strings", new_strings)
                            strings = new_strings

                        if backgroundKeys and Array.getLength(backgroundKeys) == 6 and bgComponentType:
                            new_background_keys = Array.newInstance(bgComponentType, 7)
                            System.arraycopy(backgroundKeys, 0, new_background_keys, 0, 6)
                            try:
                                first_key = Array.get(backgroundKeys, 5)
                                Array.set(new_background_keys, 6, first_key)
                            except Exception:
                                pass
                            set_private_field(instance, "backgroundKeys", new_background_keys)
                            backgroundKeys = new_background_keys

                        if icons and Array.getLength(icons) == 6 and iconsComponentType:
                            new_icons = Array.newInstance(iconsComponentType, 7)
                            System.arraycopy(icons, 0, new_icons, 0, 6)
                            set_private_field(instance, "icons", new_icons)
                            icons = new_icons

                        picker = get_private_field(instance, "picker")
                        if picker:
                            hasTabs = get_private_field(instance, "hasTabs")
                            try:
                                picker.setWrapSelectorWheel(True)
                                if hasTabs:
                                    picker.setMaxValue(6)
                                    picker.setAllItemsCount(7)
                                else:
                                    if strings and Array.getLength(strings) >= 6:
                                        Array.set(strings, 5, get_text("disable", "Disable"))
                                    picker.setMaxValue(5)
                                    picker.setAllItemsCount(6)
                                SharedConfig = jclass("org.telegram.messenger.SharedConfig")
                                acc = param.args[1] if param.args and len(param.args) >= 2 else get_private_field(instance, "currentAccount") or 0
                                val = SharedConfig.getChatSwipeAction(acc or 0)
                                picker.setValue(5 if not hasTabs and val == 6 else val)
                            except Exception:
                                pass
                    except Exception:
                        pass
            
            hook_handler = SwipeGestureSettingsViewHook(self)
            self.hook_swipe_disable_ref = self.hook_method(constructor, hook_handler)

            try:
                SwipeControllerClass = find_class("org.telegram.ui.DialogsActivity$SwipeController")
                getMovementFlagsMethod = SwipeControllerClass.getClass().getDeclaredMethod(
                    "getMovementFlags",
                    jclass("androidx.recyclerview.widget.RecyclerView"),
                    jclass("androidx.recyclerview.widget.RecyclerView$ViewHolder")
                )
                getMovementFlagsMethod.setAccessible(True)

                class GetMovementFlagsHook:
                    def __init__(self, plugin_instance):
                        self.plugin = plugin_instance

                    def after_hooked_method(self, param):
                        try:
                            dialogsActivity = get_private_field(param.thisObject, "this$0")
                            if not dialogsActivity:
                                return
                            
                            currentAccount = get_private_field(dialogsActivity, "currentAccount") if dialogsActivity else 0
                            SharedConfig = jclass("org.telegram.messenger.SharedConfig")
                            
                            if SharedConfig.getChatSwipeAction(currentAccount) == 6:
                                actionBar = get_private_field(dialogsActivity, "actionBar")
                                if actionBar and actionBar.isActionModeShowed(None):
                                    return
                                
                                param.setResult(jclass("java.lang.Integer")(0))
                        except Exception:
                            pass

                self.hook_swipe_disable_ref = self.hook_method(getMovementFlagsMethod, GetMovementFlagsHook(self))
            except Exception:
                pass
        except Exception:
            pass

    def _hook_share_sheet_folders(self):
        try:
            share_alert_class = find_class("org.telegram.ui.Components.ShareAlert")
            if not share_alert_class:
                return
            
            bottom_sheet_class = find_class("org.telegram.ui.ActionBar.BottomSheet")
            if not bottom_sheet_class:
                return
                
            show_method = bottom_sheet_class.getClass().getDeclaredMethod("show")
            show_method.setAccessible(True)
            
            class ShareAlertShowHook:
                def __init__(self, plugin):
                    self.plugin = plugin
                    self.processed_instances = set()
                
                def after_hooked_method(self, param):
                    try:
                        bottom_sheet_instance = param.thisObject
                        
                        if share_alert_class.getClass().isInstance(bottom_sheet_instance):
                            instance_id = id(bottom_sheet_instance)
                            if instance_id in self.processed_instances:
                                return
                            self.processed_instances.add(instance_id)
                            
                            self.plugin._add_folder_tabs_to_share_alert(bottom_sheet_instance)
                    except:
                        pass
            
            hook = self.hook_method(show_method, ShareAlertShowHook(self))
            if hook:
                self.hook_share_sheet_folders_ref = hook
        except:
            pass

    def _add_folder_tabs_to_share_alert(self, share_alert):
        try:
            search_field = get_private_field(share_alert, "searchView")
            if not search_field or hasattr(search_field, '_folders_added'):
                return
            
            current_account = get_private_field(share_alert, "currentAccount")
            if current_account is None:
                return
            
            folders = MessagesController.getInstance(current_account).getDialogFilters()
            folder_count = folders.size() if folders else 0
            
            has_archived = self._has_archived_chats(current_account)
            total_tabs = folder_count + (1 if has_archived else 0)
            
            if total_tabs <= 1:
                return
            
            context = search_field.getContext()
            
            filter_tabs_view = LinearLayout(context)
            filter_tabs_view.setOrientation(LinearLayout.HORIZONTAL)
            filter_tabs_view.setBackgroundColor(Theme.getColor(Theme.key_dialogBackground))
            filter_tabs_view.setPadding(AndroidUtilities.dp(8), AndroidUtilities.dp(8), AndroidUtilities.dp(8), AndroidUtilities.dp(8))
            
            scroll_view = HorizontalScrollView(context)
            scroll_view.setHorizontalScrollBarEnabled(False)
            scroll_view.setLayoutParams(ViewGroup.LayoutParams(
                ViewGroup.LayoutParams.MATCH_PARENT,
                AndroidUtilities.dp(40)
            ))
            
            tabs_container = LinearLayout(context)
            tabs_container.setOrientation(LinearLayout.HORIZONTAL)
            tabs_container.setLayoutParams(ViewGroup.LayoutParams(
                ViewGroup.LayoutParams.WRAP_CONTENT,
                AndroidUtilities.dp(40)
            ))

            scroll_view.addView(tabs_container)
            filter_tabs_view.addView(scroll_view)
            
            set_private_field(filter_tabs_view, '_tabs_container', tabs_container)
            
            tab_containers = []
            for i in range(total_tabs):
                if i < folder_count:
                    folder = folders.get(i)
                    tab_text = "All Chats" if folder.isDefault() else (folder.name if hasattr(folder, 'name') else f"Folder {i}")
                    folder_obj = folder
                    is_archived = False
                else:
                    tab_text = "Archived"
                    folder_obj = None
                    is_archived = True

                tab_container = LinearLayout(context)
                tab_container.setOrientation(LinearLayout.HORIZONTAL)
                tab_container.setGravity(Gravity.CENTER)
                tab_container.setPadding(AndroidUtilities.dp(12), AndroidUtilities.dp(8), AndroidUtilities.dp(12), AndroidUtilities.dp(8))
                tab_container.setLayoutParams(LinearLayout.LayoutParams(
                    LinearLayout.LayoutParams.WRAP_CONTENT,
                    AndroidUtilities.dp(32)
                ))

                tab_bg = GradientDrawable()
                tab_bg.setShape(GradientDrawable.RECTANGLE)
                tab_bg.setCornerRadius(AndroidUtilities.dp(16))
                
                tab_bg.setColor(Theme.getColor(Theme.key_dialogSearchBackground))
                tab_container.setBackground(tab_bg)

                tab_view = TextView(context)
                tab_view.setText(tab_text)
                tab_view.setTextColor(Theme.getColor(Theme.key_actionBarTabActiveText if i == 0 else Theme.key_actionBarTabUnactiveText))
                tab_view.setTextSize(14)
                tab_view.setTypeface(AndroidUtilities.getTypeface("fonts/rmedium.ttf"))
                tab_view.setPadding(AndroidUtilities.dp(4), 0, AndroidUtilities.dp(4), 0)

                def click_handler(*args, folder_index=i, folder=folder_obj, archived=is_archived):
                    self._on_folder_tab_clicked(share_alert, folder_index, folder, tabs_container, archived)
                
                click_listener = OnClickListener(click_handler)
                tab_container.setOnClickListener(click_listener)

                tab_container.addView(tab_view)
                tabs_container.addView(tab_container)
                tab_containers.append(tab_container)
                if i < total_tabs - 1:
                    margin_view = View(context)
                    margin_view.setLayoutParams(LinearLayout.LayoutParams(
                        AndroidUtilities.dp(4),
                        AndroidUtilities.dp(1)
                    ))
                    tabs_container.addView(margin_view)

            
            set_private_field(filter_tabs_view, '_tab_containers', tab_containers)
            
            search_field.addView(
                filter_tabs_view,
                ViewGroup.LayoutParams(
                    ViewGroup.LayoutParams.MATCH_PARENT, 
                    self._get_folders_padding()
                )
            )
            
            set_private_field(search_field, '_folders_added', True)
            
        except:
            pass
    
    def _get_folders_padding(self):
        return AndroidUtilities.dp(50)
    
    def _update_tab_styles(self, tabs_container, selected_index):
        try:
            tab_containers = []
            child_count = tabs_container.getChildCount()
            for i in range(child_count):
                child = tabs_container.getChildAt(i)
                if isinstance(child, LinearLayout):
                    tab_containers.append(child)
            
            
            for i, tab_container in enumerate(tab_containers):
                text_view = tab_container.getChildAt(0)
                
                tab_bg = GradientDrawable()
                tab_bg.setShape(GradientDrawable.RECTANGLE)
                tab_bg.setCornerRadius(AndroidUtilities.dp(16))
                
                tab_bg.setColor(Theme.getColor(Theme.key_dialogSearchBackground))
                
                text_view.setTextColor(Theme.getColor(Theme.key_actionBarTabActiveText if i == selected_index else Theme.key_actionBarTabUnactiveText))
                
                tab_container.setBackground(tab_bg)
                
        except:
            pass
    
    def _on_folder_tab_clicked(self, share_alert, folder_index, folder, tabs_container, is_archived=False):
        try:
            current_account = get_private_field(share_alert, "currentAccount")
            list_adapter = get_private_field(share_alert, "listAdapter")
            if current_account is None or not list_adapter:
                return

            self._update_tab_styles(tabs_container, folder_index)

            if is_archived:
                self._apply_archived_filter(share_alert, list_adapter, current_account)
            else:
                self._apply_folder_filter(share_alert, list_adapter, folder, current_account)

        except:
            pass
    
    def _apply_folder_filter(self, share_alert, list_adapter, folder, current_account):
        try:
            all_dialogs = MessagesController.getInstance(current_account).getAllDialogs()
            
            dialogs_list = get_private_field(list_adapter, "dialogs")
            dialogs_map = get_private_field(list_adapter, "dialogsMap")
            if not dialogs_list or not dialogs_map:
                return
            
            dialogs_list.clear()
            dialogs_map.clear()
            
            dialog_count = all_dialogs.size()
            for i in range(dialog_count):
                dialog = all_dialogs.get(i)
                if folder.isDefault() or self._dialog_matches_folder(dialog, folder, current_account):
                    if self._can_forward_to_chat(dialog, current_account):
                        dialogs_list.add(dialog)
                        dialogs_map.put(dialog.id, dialog)
            
            list_adapter.notifyDataSetChanged()
            
            self._apply_forced_scroll_offset(share_alert)
                    
        except:
            pass
    
    def _dialog_matches_folder(self, dialog, folder, current_account):
        try:
            if folder.isDefault():
                return True
            
            from org.telegram.messenger import AccountInstance
            return folder.includesDialog(AccountInstance.getInstance(current_account), dialog.id)
            
        except:
            return False
    
    def _has_archived_chats(self, current_account):
        try:
            all_dialogs = MessagesController.getInstance(current_account).getAllDialogs()
            for i in range(all_dialogs.size()):
                if all_dialogs.get(i).folder_id == 1:
                    return True
            return False
        except:
            return False
    
    def _apply_archived_filter(self, share_alert, list_adapter, current_account):
        try:
            all_dialogs = MessagesController.getInstance(current_account).getAllDialogs()
            dialogs_list = get_private_field(list_adapter, "dialogs")
            dialogs_map = get_private_field(list_adapter, "dialogsMap")
            if not dialogs_list or not dialogs_map:
                return
            
            dialogs_list.clear()
            dialogs_map.clear()
            
            for i in range(all_dialogs.size()):
                dialog = all_dialogs.get(i)
                if dialog.folder_id == 1:
                    if self._can_forward_to_chat(dialog, current_account):
                        dialogs_list.add(dialog)
                        dialogs_map.put(dialog.id, dialog)
            
            list_adapter.notifyDataSetChanged()
            
            self._apply_forced_scroll_offset(share_alert)
        except:
            pass
    
    def _can_forward_to_chat(self, dialog, current_account):
        try:
            if not dialog:
                return False
            
            from org.telegram.messenger import DialogObject
            if DialogObject.isEncryptedDialog(dialog.id):
                return True
            
            if DialogObject.isChannel(dialog):
                chat = MessagesController.getInstance(current_account).getChat(-dialog.id)
                if not chat:
                    return False
                
                from org.telegram.messenger import ChatObject
                
                if chat.megagroup:
                    return not chat.gigagroup or ChatObject.hasAdminRights(chat)
                else:
                    return ChatObject.hasAdminRights(chat) and ChatObject.canPost(chat)
            
            return True
        except:
            return False
    
    def _apply_forced_scroll_offset(self, share_alert):
        try:
            grid_view = get_private_field(share_alert, "gridView")
            if not grid_view:
                return
                
            layout_manager = grid_view.getLayoutManager()
            if not layout_manager:
                return
                
            layout_manager.scrollToPositionWithOffset(0, -self.forced_scroll_offset)
        except Exception as e:
            pass

    def _hook_non_clickable_preview(self):
        try:
            BaseFragmentClass = jclass("org.telegram.ui.ActionBar.BaseFragment")
            methods = BaseFragmentClass.getClass().getDeclaredMethods()
            present_method = None
            for m in methods:
                if m.getName() == "presentFragmentAsPreviewWithMenu":
                    present_method = m
                    break
            if present_method is None:
                raise Exception("presentFragmentAsPreviewWithMenu not found on BaseFragment")
            present_method.setAccessible(True)
            self.hook_non_clickable_present_ref = self.hook_method(present_method, NonClickablePreviewPresentFragmentHook())
        except:
            pass

        try:
            ActionBarLayout = jclass("org.telegram.ui.ActionBar.ActionBarLayout")
            methods2 = ActionBarLayout.getClass().getDeclaredMethods()
            present_method2 = None
            for m in methods2:
                if m.getName() == "presentFragmentAsPreviewWithMenu":
                    present_method2 = m
                    break
            if present_method2 is None:
                raise Exception("presentFragmentAsPreviewWithMenu not found on ActionBarLayout")
            present_method2.setAccessible(True)
            self.hook_non_clickable_present_ref2 = self.hook_method(present_method2, NonClickablePreviewPresentFragmentHook())
        except:
            pass

        try:
            ChatActivityClass = jclass("org.telegram.ui.ChatActivity")
            inner_classes = ChatActivityClass.getClass().getDeclaredClasses()
            fragment_view_class = None
            for c in inner_classes:
                if "ChatActivityFragmentView" in c.getSimpleName():
                    fragment_view_class = c
                    break
            if fragment_view_class is None:
                raise Exception("ChatActivityFragmentView not found")
            
            dispatch_method = fragment_view_class.getDeclaredMethod("dispatchTouchEvent", jclass("android.view.MotionEvent"))
            dispatch_method.setAccessible(True)
            self.hook_non_clickable_dispatch_ref = self.hook_method(dispatch_method, NonClickablePreviewDispatchTouchHook())
        except:
            pass

    def _hook_disable_topic_swipe(self):
        try:
            TouchHelperCallbackClass = find_class("org.telegram.ui.TopicsFragment$TouchHelperCallback")
            if not TouchHelperCallbackClass:
                return
            
            getMovementFlagsMethod = TouchHelperCallbackClass.getClass().getDeclaredMethod(
                "getMovementFlags",
                jclass("androidx.recyclerview.widget.RecyclerView"),
                jclass("androidx.recyclerview.widget.RecyclerView$ViewHolder")
            )
            getMovementFlagsMethod.setAccessible(True)
            
            class DisableTopicSwipeHook:
                def __init__(self, plugin_instance):
                    self.plugin = plugin_instance
                
                def before_hooked_method(self, param):
                    param.setResult(jclass("java.lang.Integer")(0))
                    param.returnEarly = True
            
            self.hook_disable_topic_swipe_ref = self.hook_method(getMovementFlagsMethod, DisableTopicSwipeHook(self))
            
        except Exception:
            pass

    def _hook_account_visibility(self):
        try:
            self.hidden_accounts = self.load_hidden_accounts()
            
            if drawer_adapter_class := find_class("org.telegram.ui.Adapters.DrawerLayoutAdapter"):
                self.hook_drawer_adapter(drawer_adapter_class)
            if profile_cell_class := find_class("org.telegram.ui.Cells.DrawerProfileCell"):
                self.hook_profile_cell(profile_cell_class)
        except Exception:
            pass

    def load_hidden_accounts(self):
        try:
            settings = self.get_setting("hidden_accounts", "[]")
            import json
            return json.loads(settings)
        except:
            return []

    def save_hidden_accounts(self):
        import json
        self.set_setting("hidden_accounts", json.dumps(self.hidden_accounts))

    def hook_drawer_adapter(self, drawer_adapter_class):
        try:
            method = drawer_adapter_class.getClass().getDeclaredMethod("notifyDataSetChanged")
            method.setAccessible(True)

            class DrawerAdapterHook:
                def __init__(self, plugin):
                    self.plugin = plugin

                def after_hooked_method(self, param):
                    try:
                        adapter = param.thisObject
                        hidden_accounts = self.plugin.hidden_accounts
                        if not hidden_accounts:
                            return
                        
                        account_numbers = get_private_field(adapter, "accountNumbers")
                        if not account_numbers:
                            return
                        
                        from org.telegram.messenger import UserConfig
                        current_account = UserConfig.selectedAccount
                        iterator = account_numbers.iterator()
                        while iterator.hasNext():
                            account_num = iterator.next()
                            if str(account_num) in hidden_accounts and account_num != current_account:
                                iterator.remove()

                    except:
                        pass

            self.hook_account_visibility_drawer_ref = self.hook_method(method, DrawerAdapterHook(self))
        except:
            pass

    def hook_profile_cell(self, profile_cell_class):
        try:
            constructors = profile_cell_class.getClass().getDeclaredConstructors()
            method = constructors[0]
            method.setAccessible(True)

            class ProfileCellHook:
                def __init__(self, plugin):
                    self.plugin = plugin

                def after_hooked_method(self, param):
                    try:
                        profile_cell = param.thisObject
                        self.plugin.replace_theme_button_listener(profile_cell)
                    except:
                        pass

            self.hook_account_visibility_profile_ref = self.hook_method(method, ProfileCellHook(self))
        except:
            pass

    def replace_theme_button_listener(self, profile_cell):
        try:
            if dark_theme_view := get_private_field(profile_cell, "darkThemeView"):
                def account_visibility_handler(*args):
                    try:
                        self._perform_haptic()
                        self.toggle_all_other_accounts()
                    except:
                        pass
                
                from android_utils import OnLongClickListener
                dark_theme_view.setOnLongClickListener(OnLongClickListener(account_visibility_handler))
        except:
            pass

    def toggle_all_other_accounts(self):
        try:
            accounts = self.get_account_info()
            if len(accounts) <= 1:
                return

            other_accounts = [acc for acc in accounts if not acc['is_current']]
            any_hidden = any(acc['hidden'] for acc in other_accounts)
            
            for account in other_accounts:
                self.toggle_account_visibility(account['number'], not any_hidden)
            
        except:
            pass

    def toggle_account_visibility(self, account_number, hidden):
        account_str = str(account_number)
        if hidden:
            if account_str not in self.hidden_accounts:
                self.hidden_accounts.append(account_str)
        else:
            if account_str in self.hidden_accounts:
                self.hidden_accounts.remove(account_str)
        self.save_hidden_accounts()
        self.refresh_drawer()

    def refresh_drawer(self):
        try:
            from android_utils import run_on_ui_thread
            run_on_ui_thread(self._refresh_drawer_impl, delay=100)
        except:
            pass
    
    def _refresh_drawer_impl(self):
        try:
            from org.telegram.ui import LaunchActivity
            if (hasattr(LaunchActivity, 'instance') and LaunchActivity.instance and 
                (drawer_adapter := get_private_field(LaunchActivity.instance, "drawerLayoutAdapter")) and
                hasattr(drawer_adapter, 'notifyDataSetChanged')):
                drawer_adapter.notifyDataSetChanged()
                return
        except:
            pass
    
    def get_account_info(self):
        accounts = []
        try:
            from org.telegram.messenger import UserConfig
            current_account = UserConfig.selectedAccount
            
            for account_id in range(UserConfig.MAX_ACCOUNT_COUNT):
                try:
                    if (config := UserConfig.getInstance(account_id)).isClientActivated():
                        if user := config.getCurrentUser():
                            first_name = getattr(user, 'first_name', 'Unknown')
                            last_name = getattr(user, 'last_name', '')
                            name = f"{first_name} {last_name}".strip() or f"Account {account_id}"
                            
                            is_current = (account_id == current_account)
                            if is_current:
                                name += " (Current)"
                            
                            accounts.append({
                                'number': account_id,
                                'name': name,
                                'user_id': user.id,
                                'hidden': str(account_id) in self.hidden_accounts,
                                'is_current': is_current
                            })
                except:
                    continue
        except:
            pass
        
        return accounts
    


class SetDefaultSendAsHook:
    def __init__(self, plugin):
        self.plugin = plugin

    def after_hooked_method(self, param):
        try:
            dialog_id, peer_id = param.args[0], param.args[1]
            current_account = UserConfig.selectedAccount
            chat = MessagesController.getInstance(current_account).getChat(-dialog_id)
            
            if not chat or not ChatObject.isMegagroup(chat) or not chat.creator:
                return

            current_user = UserConfig.getInstance(current_account).getCurrentUser()
            if not current_user or not chat.admin_rights:
                return

            self_id = current_user.id
            admin_rights = chat.admin_rights
            admin_rights.anonymous = peer_id != self_id
            rank = MessagesController.getInstance(current_account).getAdminRank(chat.id, self_id)
            MessagesController.getInstance(current_account).setUserAdminRole(
                chat.id, current_user, admin_rights, rank, False, None, False, False, None, None
            )

        except Exception:
            pass


class SendAsPopupHook:
    def __init__(self, plugin):
        self.plugin = plugin

    def after_hooked_method(self, param):
        try:
            send_as_peers, chat_full = param.args[4], param.args[3]
            if not send_as_peers or not chat_full:
                return

            chat_id = chat_full.id
            current_account = UserConfig.selectedAccount
            chat = MessagesController.getInstance(current_account).getChat(chat_id)
            
            if not chat or not ChatObject.isMegagroup(chat) or not chat.creator:
                return

            current_user = UserConfig.getInstance(current_account).getCurrentUser()
            if not current_user:
                return

            self_id = current_user.id
            peers = send_as_peers.peers
            
            for i in range(peers.size()):
                peer = peers.get(i)
                if hasattr(peer, 'peer') and hasattr(peer.peer, 'user_id') and peer.peer.user_id == self_id:
                    return

            personal_peer = TLRPC.TL_sendAsPeer()
            personal_peer.peer = TLRPC.TL_peerUser()
            personal_peer.peer.user_id = self_id
            personal_peer.peer.channel_id = 0
            personal_peer.peer.chat_id = 0
            peers.add(0, personal_peer)

        except Exception:
            pass


class BirthdayAlertHook:
    def __init__(self, plugin):
        self.plugin = plugin
    
    def after_hooked_method(self, param):
        instance = param.thisObject
        if instance is None:
            return
        
        try:
            currentAccount = get_private_field(instance, "currentAccount")
            if currentAccount is None:
                return
            
            MessagesController = jclass("org.telegram.messenger.MessagesController")
            messagesController = MessagesController.getInstance(currentAccount)
            pendingSuggestions = get_private_field(messagesController, "pendingSuggestions")
            
            if pendingSuggestions and pendingSuggestions.contains("BIRTHDAY_SETUP"):
                dialogsHintCell = get_private_field(instance, "dialogsHintCell")
                if dialogsHintCell:
                    dialogsHintCell.setVisibility(8)
        except Exception:
            pass





class ConfirmationHook:
    def __init__(self, plugin: UiTweaksPlugin):
        self.plugin = plugin
        self.pending_params: List[Any] = [] 
        self.pending_group_id: Optional[str] = None 
        self.is_resending = False
        self.pending_sticker_doc = None

    def _reset_pending(self):
        self.pending_params.clear()
        self.pending_group_id = None
        self.pending_sticker_doc = None

    def before_hooked_method(self, param: Any):
        if self.is_resending:
            return

        try:
            send_params = param.args[0]
            if not send_params:
                return

            params_map = getattr(send_params, 'params', None)
            group_id = None
            is_group_final = False
            if params_map is not None:
                group_id = params_map.get("groupId")
                is_group_final = params_map.get("final") == "1"

            msg_text = getattr(send_params, 'message', None)
            is_command = isinstance(msg_text, str) and msg_text.strip().startswith('/')

            is_photo = getattr(send_params, 'photo', None) is not None
            doc = getattr(send_params, 'document', None)

            is_sticker = False
            is_voice = False
            is_round_video = False
            is_video_file = False
            is_gif = False
            is_generic_document = False

            if doc and hasattr(doc, 'attributes'):
                attributes_list = doc.attributes
                has_animated_attr = False
                has_video_attr = False
                has_sticker_attr = False
                
                mime_type = getattr(doc, 'mime_type', '')
                
                for i in range(attributes_list.size()):
                    attr = attributes_list.get(i)
                    if isinstance(attr, TL_documentAttributeSticker):
                        has_sticker_attr = True
                    elif isinstance(attr, TL_documentAttributeAudio) and attr.voice:
                        is_voice = True
                    elif isinstance(attr, TL_documentAttributeAnimated):
                        has_animated_attr = True
                    elif isinstance(attr, TL_documentAttributeVideo):
                        has_video_attr = True
                        if attr.round_message:
                            is_round_video = True
                        else:
                            is_video_file = True
                
                if has_sticker_attr:
                    is_round_video = False
                    is_video_file = False
                    is_sticker = True
                elif has_animated_attr:
                    is_gif = True
                    is_video_file = False
                elif has_video_attr and not is_round_video:
                    is_video_file = True

                if not (is_sticker or is_voice or is_round_video or is_video_file or is_gif):
                    is_generic_document = True

            should_confirm = False
            message_type = ""

            if not self.plugin.get_setting("enable_confirmation_settings", True):
                should_confirm = False
            elif is_command and self.plugin.get_setting("confirm_commands", False):
                if self.plugin.command_from_message_click:
                    should_confirm = True
                    message_type = get_text("message_type_command", "command")
            elif is_photo and self.plugin.get_setting("confirm_photo", False):
                should_confirm = True
                message_type = get_text("message_type_photo", "photo")
            elif is_sticker and self.plugin.get_setting("confirm_stickers", True):
                should_confirm = True
                message_type = get_text("message_type_sticker", "sticker")
                self.pending_sticker_doc = doc
            elif is_voice and self.plugin.get_setting("confirm_voice", True):
                should_confirm = True
                message_type = get_text("message_type_voice_message", "voice message")
            elif is_round_video and self.plugin.get_setting("confirm_round_video", True):
                should_confirm = True
                message_type = get_text("message_type_round_video_message", "round video message")
            elif is_video_file and self.plugin.get_setting("confirm_video_file", False):
                should_confirm = True
                message_type = get_text("message_type_video_file", "video file")
            elif is_gif and self.plugin.get_setting("confirm_gif", False):
                should_confirm = True
                message_type = get_text("message_type_gif", "GIF")
            elif is_generic_document and self.plugin.get_setting("confirm_document", False):
                should_confirm = True
                message_type = get_text("message_type_file", "file")

            if not should_confirm:
                if is_command:
                    self.plugin.command_from_message_click = False
                return 

            if is_command:
                self.pending_params.append(param)
                param.setResult(None)
                
                run_on_ui_thread(lambda: self.show_confirmation_dialog(msg_text.strip()))
                self.plugin.command_from_message_click = False
                return

            if group_id and group_id != "0":
                if self.pending_group_id is None:
                    self.pending_group_id = group_id
                if group_id != self.pending_group_id:
                    return

                self.pending_params.append(param)
                param.setResult(None)

                if is_group_final:
                    count = len(self.pending_params)
                    if count > 1:
                        if is_photo:
                            message_type = get_text("message_type_photo_plural", "photos")
                        elif is_video_file:
                            message_type = get_text("message_type_video_file_plural", "video files")
                        elif is_round_video:
                            message_type = get_text("message_type_round_video_message", "round video messages")
                        elif is_generic_document:
                            message_type = get_text("message_type_file_plural", "files")
                    
                    run_on_ui_thread(lambda: self.show_confirmation_dialog(f"{count} {message_type}"))
                return
            else:
                self.pending_params.append(param)
                param.setResult(None)
                
                run_on_ui_thread(lambda: self.show_confirmation_dialog(message_type, is_sticker, doc if is_sticker else None))

        except Exception as e:
            pass

    def show_confirmation_dialog(self, message_type: str, is_sticker: bool = False, sticker_doc = None):
        fragment = get_last_fragment()
        activity = fragment.getParentActivity() if fragment else None

        if not activity:
            self.proceed_sending(None, 0)
            return

        dialog_ref = None
        
        def cleanup():
            nonlocal dialog_ref
            dialog_ref = None

        builder = AlertDialogBuilder(activity)
        builder.set_title(get_text("confirm_send_title", "Confirm Send"))
        
        confirmation_text = get_text("confirm_send_message", "Do you really want to send this {message_type}?").format(message_type=message_type)

        if is_sticker and sticker_doc:
            try:
                container = LinearLayout(activity)
                container.setOrientation(LinearLayout.VERTICAL)
                container.setPadding(AndroidUtilities.dp(24), AndroidUtilities.dp(16), AndroidUtilities.dp(24), AndroidUtilities.dp(16))

                sticker_view = BackupImageView(activity)
                sticker_view.setRoundRadius(0)
                sticker_size = AndroidUtilities.dp(120)
                sticker_params = LinearLayout.LayoutParams(sticker_size, sticker_size)
                sticker_params.gravity = Gravity.CENTER_HORIZONTAL
                sticker_params.bottomMargin = AndroidUtilities.dp(16)
                sticker_view.setLayoutParams(sticker_params)

                thumb_drawable = None
                if sticker_doc.thumbs and sticker_doc.thumbs.size() > 0:
                    from org.telegram.messenger import ImageLoader
                    for i in range(sticker_doc.thumbs.size()):
                        t = sticker_doc.thumbs.get(i)
                        if hasattr(t, 'bytes') and t.bytes:
                            thumb_drawable = ImageLoader.getStrippedPhotoBitmap(t.bytes, "b")
                            break

                image_location = ImageLocation.getForDocument(sticker_doc)
                if image_location:
                    sticker_view.setImage(image_location, "120_120", thumb_drawable, sticker_doc)

                container.addView(sticker_view)

                builder.set_view(container)
            except Exception:
                builder.set_message(confirmation_text)
        else:
            builder.set_message(confirmation_text)
        
        builder.set_positive_button(get_text("send", "Send"), self.proceed_sending)
        
        builder.set_negative_button(get_text("cancel", "Cancel"), lambda dialog, which: cleanup())
        builder.set_on_cancel_listener(lambda b: (self.cancel_sending(b, 0), cleanup()))
        dialog_ref = builder.show()

    def proceed_sending(self, builder: Optional[AlertDialogBuilder], which: int):
        if builder:
            builder.dismiss()

        if not self.pending_params:
            return

        try:
            for stored_param in self.pending_params:
                original_method = stored_param.method
                arguments = stored_param.args
                instance = stored_param.thisObject
                self.is_resending = True
                original_method.invoke(instance, *arguments)
            
        except Exception as e:
            pass
        finally:
            self.is_resending = False
            self._reset_pending()

    def cancel_sending(self, builder: Optional[AlertDialogBuilder], which: int):
        if builder:
            builder.dismiss()
        
        self._reset_pending()


class DialogsActivityHook:
    def __init__(self, plugin: UiTweaksPlugin):
        self.plugin = plugin

    def after_hooked_method(self, param):
        try:
            dialogs_activity = param.thisObject
            if dialogs_activity is None:
                return
                
            activity_id = id(dialogs_activity)
            
            if self.plugin.get_setting("hide_bot_open", False):
                    try:
                        self.plugin._hide_bot_open_buttons_on_resume(dialogs_activity)
                    except Exception as e:
                        pass
            
            if self.plugin.get_setting("enable_recent_chats_menu", True):
                try:
                    self.plugin._setup_recent_chats_back_button_listener(dialogs_activity)
                except Exception as e:
                    pass
            
            if self.plugin.get_setting("fab_settings_shortcut", False):
                try:
                    self.plugin._setup_fab_settings_listener(dialogs_activity)
                except Exception as e:
                    pass
        except Exception as e:
            pass


class DialogsActivityDestroyHook:
    def __init__(self, plugin: UiTweaksPlugin):
        self.plugin = plugin

    def before_hooked_method(self, param):
        try:
            if hasattr(self.plugin, 'popup_manager') and self.plugin.popup_manager:
                self.plugin.popup_manager.destroy()
        except Exception:
            pass

class DialogCellHook:
    def __init__(self, plugin: UiTweaksPlugin):
        self.plugin_ref = weakref.ref(plugin)

    def after_hooked_method(self, param):
        try:
            plugin = self.plugin_ref()
            if plugin is None:
                return
            if plugin.get_setting("hide_bot_open", True):
                cell = param.thisObject
                if cell is not None:
                    try:
                        open_bot_field = cell.getClass().getDeclaredField("openBot")
                        open_bot_field.setAccessible(True)
                        open_bot_value = open_bot_field.get(cell)
                        
                        if open_bot_value:  
                            open_bot_field.set(cell, False)  
                            
                    except Exception as e:
                        pass
        except Exception as e:
            pass

class SendImageWithHighQualityByDefault:
    def __init__(self, plugin):
        self.plugin = plugin
        self._cached_fields = {}

    def isEnabled(self):
        return True

    def onHook(self):
        try:
            cellClass = find_class("org.telegram.ui.Cells.PhotoAttachPhotoCell")
            
            try:
                setHighQuality_method = cellClass.getClass().getDeclaredMethod("setHighQuality", find_class("java.lang.Boolean").TYPE)
                setHighQuality_method.setAccessible(True)
                self.plugin.hook_method(setHighQuality_method, PhotoCellSetHighQualityHook(self))
            except:
                method_names = ["setQuality", "setHD"]
                for method_name in method_names:
                    try:
                        setHighQuality_method = cellClass.getClass().getDeclaredMethod(method_name, find_class("java.lang.Boolean").TYPE)
                        setHighQuality_method.setAccessible(True)
                        self.plugin.hook_method(setHighQuality_method, PhotoCellSetHighQualityHook(self))
                        break
                    except:
                        continue
        except:
            pass




class PhotoCellSetHighQualityHook:
    def __init__(self, hook_instance):
        self.hook_instance = hook_instance
        self._field_cache = {}

    def _get_cached_field(self, obj, field_name):
        cache_key = f"{id(obj)}_{field_name}"
        if cache_key not in self._field_cache:
            try:
                field = obj.getClass().getDeclaredField(field_name)
                field.setAccessible(True)
                self._field_cache[cache_key] = field
            except:
                self._field_cache[cache_key] = None
        return self._field_cache.get(cache_key)

    def _get_field_value(self, obj, field_name):
        field = self._get_cached_field(obj, field_name)
        if field:
            try:
                return field.get(obj)
            except:
                return None
        return None

    def after_hooked_method(self, param):
        try:
            from android.view import ViewGroup
            from android.view import View
            
            highQuality = param.args[0] if param.args and len(param.args) > 0 else False
            
            if not highQuality:
                return
            
            try:
                photoEntry = self._get_field_value(param.thisObject, "photoEntry")
                if photoEntry:
                    isVideo = self._get_field_value(photoEntry, "isVideo") or False
                    if isVideo:
                        return
                    else:
                        videoInfoContainer = self._get_field_value(param.thisObject, "videoInfoContainer")
                        if videoInfoContainer:
                            videoInfoContainer.setVisibility(View.INVISIBLE)
            except:
                pass
        except:
            pass


class SwipePreventionHook(MethodReplacement):
    def __init__(self, plugin: UiTweaksPlugin):
        self.plugin = plugin

    def replace_hooked_method(self, param):
        try:
            prevent_editing = self.plugin.get_setting("prevent_swipe_while_editing", True)
            prevent_typing = self.plugin.get_setting("prevent_swipe_while_typing", True)
            
            if not prevent_editing and not prevent_typing:
                return True
            
            activity = param.thisObject
            if activity is None:
                return True
            
            swipe_back_enabled = True
            try:
                swipe_back_enabled = get_private_field(activity, "swipeBackEnabled")
                if swipe_back_enabled is None:
                    swipe_back_enabled = True
            except:
                pass
            
            forwarding_preview_view = None
            try:
                forwarding_preview_view = get_private_field(activity, "forwardingPreviewView")
            except:
                pass
            
            if not swipe_back_enabled or (forwarding_preview_view is not None and hasattr(forwarding_preview_view, 'isShowing') and forwarding_preview_view.isShowing()):
                return False
            
            is_editing = False
            is_keyboard_open = False
            
            if prevent_editing:
                try:
                    editing_message = get_private_field(activity, "editingMessageObject")
                    is_editing = editing_message is not None
                except:
                    pass
            
            if prevent_typing:
                try:
                    is_keyboard_open = activity.isKeyboardVisible()
                except:
                    pass
            
            should_prevent = (prevent_editing and is_editing) or (prevent_typing and is_keyboard_open)
            
            if should_prevent:
                return False
            else:
                return True
        except Exception as e:
            return True


class DeepLinkHook:
    def __init__(self, plugin: UiTweaksPlugin):
        self.plugin = plugin
        self.pending_intent = None
        self.pending_param = None
        self.is_processing = False

    def before_hooked_method(self, param):
        try:
            if not self.plugin.get_setting("confirm_deeplinks", True) and not self.plugin.get_setting("confirm_ayugram_deeplinks", True):
                return

            if self.is_processing:
                return

            if len(param.args) < 7:
                return

            intent = param.args[0]
            if not intent:
                return

            for i in range(1, 7):
                if param.args[i] is None:
                    return

            action = intent.getAction()
            if action and "voice" in action.lower():
                return

            data = intent.getData()
            if not data:
                return

            url = str(data)
            if url.startswith("tg://Quanta") or url.startswith("tg://quanta") or url == "tg://refresh":
                return
            elif url.startswith("tg://ayu/"):
                if not self.plugin.get_setting("confirm_ayugram_deeplinks", True):
                    return
                
                excluded_links = ["tg://ayu/prefs", "tg://ayu/db_export", "tg://ayu/db_import"]
                if url in excluded_links:
                    self.pending_intent = intent
                    self.pending_param = param
                    param.setResult(None)  
                    run_on_ui_thread(lambda: self.show_deeplink_confirmation_dialog(url))
                    return
                
                self.pending_intent = intent
                self.pending_param = param
                param.setResult(None)  
                run_on_ui_thread(lambda: self.show_ayugram_warning_dialog(url))
                return
            elif url.startswith("tg://"):
                if not self.plugin.get_setting("confirm_deeplinks", True):
                    return
                    
                self.pending_intent = intent
                self.pending_param = param
                param.setResult(None)  
                run_on_ui_thread(lambda: self.show_deeplink_confirmation_dialog(url))
                return

        except Exception as e:
            pass

    def show_ayugram_warning_dialog(self, url: str):
        try:
            fragment = get_last_fragment()
            activity = fragment.getParentActivity() if fragment else None

            if not activity:
                self.proceed_deeplink()
                return

            builder = AlertDialogBuilder(activity)
            builder.set_title(get_text("ayugram_deeplink_title", "AyuGram Deep Link"))
            builder.set_message(get_text("ayugram_deeplink_message", "This AyuGram link may redirect to auto-playing content with blocked controls."))
            builder.set_positive_button(get_text("proceed_anyway", "Proceed Anyway"), lambda b, w: self.proceed_deeplink())
            builder.set_negative_button(get_text("cancel", "Cancel"), lambda b, w: self.cancel_deeplink())
            builder.set_on_cancel_listener(lambda b: self.cancel_deeplink())
            builder.make_button_red(AlertDialogBuilder.BUTTON_POSITIVE)
            builder.show()

        except Exception as e:
            self.proceed_deeplink()

    def show_deeplink_confirmation_dialog(self, url: str):
        try:
            fragment = get_last_fragment()
            activity = fragment.getParentActivity() if fragment else None

            if not activity:
                self.proceed_deeplink()
                return

            builder = AlertDialogBuilder(activity)
            builder.set_title(get_text("confirm_deeplink_title", "Confirm Deep Link"))
            builder.set_message(get_text("confirm_deeplink_message", "Do you really want to open this deep link?\n{url}").format(url=url))
            builder.set_positive_button(get_text("open", "Open"), lambda b, w: self.proceed_deeplink())
            builder.set_negative_button(get_text("cancel", "Cancel"), lambda b, w: self.cancel_deeplink())
            builder.set_on_cancel_listener(lambda b: self.cancel_deeplink())
            builder.show()

        except Exception as e:
            self.proceed_deeplink()

    def proceed_deeplink(self):
        try:
            if self.pending_param and self.pending_intent:
                
                self.is_processing = True
                
                instance = self.pending_param.thisObject
                original_method = self.pending_param.method
                arguments = [self.pending_intent, True, False, False, None, True, False]
                original_method.invoke(instance, *arguments)
                
                
                self.pending_intent = None
                self.pending_param = None
                self.is_processing = False
        except Exception as e:
            self.is_processing = False
            pass

    def cancel_deeplink(self):
        self.pending_intent = None
        self.pending_param = None
        self.is_processing = False


class SetCommandHook:
    def __init__(self, plugin: UiTweaksPlugin):
        self.plugin = plugin

    def before_hooked_method(self, param):
        try:
            message_object = param.args[0]  
            command = param.args[1] 
            long_press = param.args[2] 
            username = param.args[3] 
            
            if message_object is not None and command is not None and command.startswith('/'):
                self.plugin.command_from_message_click = True
            else:
                self.plugin.command_from_message_click = False
            
        except Exception as e:
            self.plugin.command_from_message_click = False


class StarReactionMenuHook:
    def __init__(self, plugin: UiTweaksPlugin):
        self.plugin = plugin
        self._items_field = None
        self._visible_reactions_field = None

    def before_hooked_method(self, param):
        try:
            if not self.plugin.get_setting("hide_star_reaction", False):
                return
            
            hide_location = self.plugin.get_setting("star_reaction_hide_location", 0)
            if hide_location not in [0, 2]: 
                return
                
            container = param.thisObject
            if container is None:
                return
                
            try:
                if self._items_field is None:
                    self._items_field = container.getClass().getDeclaredField("items")
                    self._items_field.setAccessible(True)
                items = self._items_field.get(container)
                
                if items is not None and items.size() > 0:
                    filtered_items = []
                    star_count = 0
                    for i in range(items.size()):
                        item = items.get(i)
                        if item is not None:
                            reaction = getattr(item, 'reaction', None)
                            if reaction is not None:
                                is_star_property = getattr(reaction, 'isStar', False)
                                is_star_class = isinstance(reaction, jclass('org.telegram.tgnet.TLRPC$TL_reactionPaid'))
                                is_star = is_star_property or is_star_class
                                if is_star:
                                    star_count += 1
                                    continue
                                else:
                                    filtered_items.append(item)
                            else:
                                filtered_items.append(item)
                    
                    if len(filtered_items) < items.size():
                        from java.util import ArrayList
                        new_items = ArrayList()
                        for item in filtered_items:
                            new_items.add(item)
                        self._items_field.set(container, new_items)
                            
                        if hasattr(container, 'notifyDataSetChanged'):
                            container.notifyDataSetChanged()
                        
            except Exception as e:
                try:
                    if self._visible_reactions_field is None:
                        self._visible_reactions_field = container.getClass().getDeclaredField("visibleReactions")
                        self._visible_reactions_field.setAccessible(True)
                    visible_reactions = self._visible_reactions_field.get(container)
                    
                    if visible_reactions is not None:
                        filtered_reactions = []
                        for i in range(visible_reactions.size()):
                            reaction = visible_reactions.get(i)
                            if reaction is not None:
                                is_star_property = getattr(reaction, 'isStar', False)
                                is_star_class = isinstance(reaction, jclass('org.telegram.tgnet.TLRPC$TL_reactionPaid'))
                                is_star = is_star_property or is_star_class
                                if is_star:
                                    continue
                                else:
                                    filtered_reactions.append(reaction)
                        
                        if len(filtered_reactions) < visible_reactions.size():
                            from java.util import ArrayList
                            new_list = ArrayList()
                            for reaction in filtered_reactions:
                                new_list.add(reaction)
                            self._visible_reactions_field.set(container, new_list)
                            
                except Exception as e2:
                    pass
                
        except Exception as e:
            pass


class StarReactionVisibleListHook:
    def __init__(self, plugin: UiTweaksPlugin):
        self.plugin = plugin

    def before_hooked_method(self, param):
        try:
            
            if not self.plugin.get_setting("hide_star_reaction", False):
                return
                
            hide_location = self.plugin.get_setting("star_reaction_hide_location", 0)
            if hide_location not in [0, 2]: 
                return
                
            reactions_list = param.args[0]
            if reactions_list is None or reactions_list.size() == 0:
                return
                
            
            filtered_reactions = []
            has_star = False
            for i in range(reactions_list.size()):
                reaction = reactions_list.get(i)
                if reaction is not None:
                    is_star_property = getattr(reaction, 'isStar', False)
                    is_star_class = isinstance(reaction, jclass('org.telegram.tgnet.TLRPC$TL_reactionPaid'))
                    is_star = is_star_property or is_star_class
                    if is_star:
                        has_star = True
                    else:
                        filtered_reactions.append(reaction)
            
            if has_star and len(filtered_reactions) < reactions_list.size():
                from java.util import ArrayList
                new_list = ArrayList()
                for reaction in filtered_reactions:
                    new_list.add(reaction)
                param.args[0] = new_list
                
        except Exception as e:
            pass


class StarReactionGradientHook:
    def __init__(self, plugin: UiTweaksPlugin):
        self.plugin = plugin

    def before_hooked_method(self, param):
        try:
            if not self.plugin.get_setting("hide_star_reaction", False):
                return
                
            hide_location = self.plugin.get_setting("star_reaction_hide_location", 0)
            if hide_location not in [0, 2]:
                return
                
            container = param.thisObject
            if container is None:
                return
                
            try:
                has_star_field = container.getClass().getDeclaredField("hasStar")
                has_star_field.setAccessible(True)
                has_star_field.set(container, False)
            except Exception as e:
                pass
                
        except Exception as e:
            pass


class StarReactionLayoutDrawHook:
    def __init__(self, plugin: UiTweaksPlugin):
        self.plugin = plugin

    def before_hooked_method(self, param):
        try:
            if not self.plugin.get_setting("hide_star_reaction", False):
                return
                
            hide_cells = self.plugin.get_setting("star_reaction_hide_cells", False)
            if not hide_cells: 
                return
                
            message_object = param.args[0] if len(param.args) > 0 else None
            if message_object is None:
                return
            if (hasattr(message_object, 'messageOwner') and 
                message_object.messageOwner is not None and 
                hasattr(message_object.messageOwner, 'reactions') and 
                message_object.messageOwner.reactions is not None and
                hasattr(message_object.messageOwner.reactions, 'results') and
                message_object.messageOwner.reactions.results is not None):
                
                original_results = message_object.messageOwner.reactions.results
                filtered_results = []
                
                for i in range(original_results.size()):
                    reaction_count = original_results.get(i)
                    if reaction_count is not None and reaction_count.reaction is not None:
                        is_star_property = getattr(reaction_count.reaction, 'isStar', False)
                        is_star_class = isinstance(reaction_count.reaction, jclass('org.telegram.tgnet.TLRPC$TL_reactionPaid'))
                        is_star = is_star_property or is_star_class
                        
                        if not is_star:
                            filtered_results.append(reaction_count)
                
                if len(filtered_results) < original_results.size():
                    from java.util import ArrayList
                    new_results = ArrayList()
                    for result in filtered_results:
                        new_results.add(result)
                    message_object.messageOwner.reactions.results = new_results
                        
        except Exception as e:
            pass


class DownloadManagerHook:
    def __init__(self, plugin: UiTweaksPlugin):
        self.plugin = plugin

    def before_hooked_method(self, param):
        try:
            if self.plugin.get_setting("always_show_download_manager", False):
                param.setResult(True)
        except Exception as e:
            pass

class ProxyButtonHook:
    def __init__(self, plugin: UiTweaksPlugin):
        self.plugin = plugin

    def after_hooked_method(self, param):
        try:
            if not self.plugin.get_setting("always_show_proxy_button", False):
                return
            
            dialogs_activity = param.thisObject
            
            try:
                proxy_item_field = dialogs_activity.getClass().getDeclaredField("proxyItem")
                proxy_item_field.setAccessible(True)
                proxy_item = proxy_item_field.get(dialogs_activity)
                
                if proxy_item is not None:
                    proxy_item.setVisibility(0)
                    
                    proxy_visible_field = dialogs_activity.getClass().getDeclaredField("proxyItemVisible")
                    proxy_visible_field.setAccessible(True)
                    proxy_visible_field.set(dialogs_activity, True)
                    
            except Exception as e:
                pass
                
        except Exception as e:
            pass

class ArticleViewerFixHook:
    def __init__(self, plugin: UiTweaksPlugin):
        self.plugin = plugin

    def before_hooked_method(self, param):
        try:
            if self.plugin.get_setting("disable_article_viewer_swipe", False):
                param.setResult(False)
        except Exception as e:
            pass


class WebAppSwipePreventionHook:
    def __init__(self, plugin: UiTweaksPlugin):
        self.plugin = plugin

    def after_hooked_method(self, param):
        try:
            swipe_container = param.thisObject
            if swipe_container:
                swipe_container.setAllowSwipes(False)
        except Exception as e:
            pass


class PhoneFormatHook:
    def __init__(self, plugin):
        self.plugin = plugin
    
    def after_hooked_method(self, param):
        try:
            phone_str = param.args[0]
            if phone_str and str(phone_str).startswith('+'):
                is_other = self.is_other_user_profile()
                if is_other:
                    param.setResult(get_text("MobileHidden", "Mobile hidden"))
        except:
            pass
    
    def is_other_user_profile(self):
        try:
            fragment = get_last_fragment()
            if not fragment or fragment.getClass().getSimpleName() != "ProfileActivity":
                return False
            
            userId_field = fragment.getClass().getDeclaredField("userId")
            userId_field.setAccessible(True)
            user_id = userId_field.getLong(fragment)
            
            if user_id == 0:
                return False
            
            from org.telegram.messenger import UserConfig
            current_user_id = UserConfig.getInstance(fragment.getCurrentAccount()).getClientUserId()
            return user_id != current_user_id
        except:
            return False


class MessagesControllerGetDialogsHook:
    def __init__(self, plugin: UiTweaksPlugin):
        self.plugin = plugin
        self.removed_archive = {}

    def before_hooked_method(self, param):
        try:
            if not self.plugin.get_setting("hide_archived_chats", False):
                return

            try:
                messages_controller = param.thisObject
                account_id = messages_controller.currentAccount
                
                if self.removed_archive.get(account_id, False):
                    return
                
                dialogs_dict = messages_controller.dialogs_dict
                dialog_object = jclass("org.telegram.messenger.DialogObject")
                archive_dialog_id = dialog_object.makeFolderDialogId(1)
                
                archive_dialog = dialogs_dict.get(archive_dialog_id)
                if archive_dialog is not None:
                    dialogs_dict.remove(archive_dialog_id)
                    
                    all_dialogs = messages_controller.allDialogs
                    try:
                        for i in range(all_dialogs.size()):
                            if all_dialogs.get(i) == archive_dialog:
                                all_dialogs.remove(i)
                                break
                    except Exception:
                        pass
                    
                    self.removed_archive[account_id] = True
                    
            except Exception:
                pass
            
        except Exception:
            pass


class ChatUtilsHasArchivedHook:
    def __init__(self, plugin: UiTweaksPlugin):
        self.plugin = plugin

    def after_hooked_method(self, param):
        try:
            if self.plugin.get_setting("hide_archived_chats", False) and not self.plugin.get_setting("hide_archived_from_drawer", False):
                param.setResult(True)
        except Exception:
            pass


class ExteraConfigArchivedHook:
    def __init__(self, plugin: UiTweaksPlugin):
        self.plugin = plugin

    def before_hooked_method(self, param):
        try:
            if self.plugin.get_setting("hide_archived_chats", False) and not self.plugin.get_setting("hide_archived_from_drawer", False):
                if len(param.args) >= 2 and param.args[0] == "archivedChats":
                    param.thisObject.setObj("archivedChats", True)
                    param.setResult(None)
        except Exception:
            pass


class MessagesControllerSendTypingHook:
    def __init__(self, plugin: UiTweaksPlugin):
        self.plugin = plugin

    def before_hooked_method(self, param):
        try:
            if not self.plugin.get_setting("typing_instead_sticker", False):
                return

            if len(param.args) < 3:
                return

            action = param.args[2]
            if action == 10:
                from java.lang import Integer
                param.args[2] = Integer(0)
        except Exception:
            pass


class UpdateBotButtonHook:
    def __init__(self, plugin: UiTweaksPlugin):
        self.plugin = plugin

    def replace_hooked_method(self, param):
        try:
            if self.plugin.get_setting("hide_bot_button", False):
                self_instance = param.thisObject
                bot_button = getattr(self_instance, 'botButton', None)
                if bot_button:
                    bot_button.setVisibility(8)
                
                bot_commands_menu_button = getattr(self_instance, 'botCommandsMenuButton', None)
                if bot_commands_menu_button:
                    bot_commands_menu_button.setVisibility(8)
            
            return None
        except Exception as e:
            return None








class VoiceMessageControlHook:
    def __init__(self, plugin: UiTweaksPlugin):
        self.plugin = plugin

    def before_hooked_method(self, param):
        try:
            by_voice_end = param.args[2]
            if not by_voice_end:
                return
            
            media_controller = param.thisObject
            if media_controller is None:
                return
            
            try:
                playlist_field = media_controller.getClass().getDeclaredField("voiceMessagesPlaylist")
                playlist_field.setAccessible(True)
                voice_playlist = playlist_field.get(media_controller)
                
                playing_field = media_controller.getClass().getDeclaredField("playingMessageObject")
                playing_field.setAccessible(True)
                playing_message = playing_field.get(media_controller)
                
                if (playing_message and 
                    hasattr(playing_message, 'isVoice') and 
                    playing_message.isVoice() and
                    voice_playlist and 
                    voice_playlist.size() > 1):
                    
                    playlist_field.set(media_controller, None)
                    
                    playlist_map_field = media_controller.getClass().getDeclaredField("voiceMessagesPlaylistMap")
                    playlist_map_field.setAccessible(True)
                    playlist_map_field.set(media_controller, None)
                    
            except Exception as e:
                pass
                
        except Exception as e:
            pass


class VideoMessageControlHook:
    def __init__(self, plugin: UiTweaksPlugin):
        self.plugin = plugin

    def before_hooked_method(self, param):
        try:
            if not param.args[2] or not param.thisObject:
                return
            try:
                playing_field = param.thisObject.getClass().getDeclaredField("playingMessageObject")
                playing_field.setAccessible(True)
                playing_message = playing_field.get(param.thisObject)
                if (playing_message and hasattr(playing_message, 'isRoundVideo') and playing_message.isRoundVideo()):
                    voice_playlist_field = param.thisObject.getClass().getDeclaredField("voiceMessagesPlaylist")
                    voice_playlist_field.setAccessible(True)
                    voice_playlist = voice_playlist_field.get(param.thisObject)
                    if voice_playlist and voice_playlist.size() > 1:
                        voice_playlist_field.set(param.thisObject, None)
                        voice_playlist_map_field = param.thisObject.getClass().getDeclaredField("voiceMessagesPlaylistMap")
                        voice_playlist_map_field.setAccessible(True)
                        voice_playlist_map_field.set(param.thisObject, None)
            except:
                pass
        except:
            pass


class VoiceMessageTimeDisplayHook:
    def __init__(self, plugin: UiTweaksPlugin):
        self.plugin = plugin
        self._cell_cache = {}
        self._last_update_ts = {}
        self._cache_order = []
        self._cache_capacity = 16
        self._pending_updates = {}
        
    def after_hooked_method(self, param):
        try:
            if not self.plugin.get_setting("progress_timestamp_enabled", True):
                return
                
            cell = param.thisObject
            if not cell:
                return
                
            messageObject = get_private_field(cell, "currentMessageObject")
            if not messageObject:
                return
                
            documentAttachType = get_private_field(cell, "documentAttachType")
                
            if not self.is_voice_message(messageObject) and not self.is_round_video_message(messageObject):
                return
                
            if documentAttachType != 3 and not (hasattr(messageObject, 'isRoundVideo') and messageObject.isRoundVideo()):
                return
            
            if hasattr(messageObject, 'isRoundVideo') and messageObject.isRoundVideo():
                try:
                    set_private_field(cell, "roundPlayingDrawableProgress", 0.0)
                except:
                    pass
                
            self._apply_cached_update(cell, messageObject)
            
        except Exception as e:
            pass

    def _apply_cached_update(self, cell, messageObject):
        throttle_ms = 35
        key = id(cell)
        
        try:
            curr_id = int(messageObject.getId())
            curr_did = int(messageObject.getDialogId())
            duration = self.get_voice_duration(messageObject)
            currentProgress = 0
            if self.is_playing(messageObject):
                currentProgress = self.get_audio_progress_sec(messageObject)
        except:
            return
            
        prev = self._cell_cache.get(key)
        if prev is not None and len(prev) >= 5 and prev[3] == curr_id and prev[4] == curr_did and prev[0] == currentProgress and prev[1] == duration:
            try:
                if prev[2] is not None:
                    set_private_field(cell, "durationLayout", prev[2])
                cell.invalidate()
            except:
                pass
            return
            
        pend = self._pending_updates.get(key)
        if pend and pend[0] == curr_did and pend[1] == curr_id and pend[2] == currentProgress:
            return
            
        self._pending_updates[key] = (curr_did, curr_id, currentProgress)
        
        def runner():
            try:
                c = cell
                m = get_private_field(c, "currentMessageObject")
                if m is None:
                    return
                if int(m.getDialogId()) == curr_did and int(m.getId()) == curr_id:
                    self._force_update_with_cache(c, m)
            finally:
                self._pending_updates.pop(key, None)
        
        try:
            from org.telegram.messenger import AndroidUtilities
            AndroidUtilities.runOnUIThread(runner, throttle_ms)
        except:
            self._force_update_with_cache(cell, messageObject)

    def _force_update_with_cache(self, cell, messageObject):
        try:
            duration = self.get_voice_duration(messageObject)
            if duration <= 0:
                return
                
            currentProgress = 0
            if self.is_playing(messageObject):
                currentProgress = self.get_audio_progress_sec(messageObject)
                
            from org.telegram.messenger import AndroidUtilities
            from org.telegram.ui.ActionBar import Theme
            from android.text import StaticLayout, Layout
            from java import jint
            
            timeString = AndroidUtilities.formatShortDuration(currentProgress, int(duration))
            
            chatAudioTimePaint = Theme.chat_audioTimePaint
            if not chatAudioTimePaint:
                return
                
            timeWidth = int(chatAudioTimePaint.measureText(timeString))
            
            durationLayout = StaticLayout(
                timeString,
                chatAudioTimePaint,
                timeWidth,
                Layout.Alignment.ALIGN_NORMAL,
                1.0,
                0.0,
                False
            )
            
            set_private_field(cell, "durationLayout", durationLayout)
            set_private_field(cell, "timeWidthAudio", jint(timeWidth))
            set_private_field(cell, "lastTime", jint(currentProgress))
            cell.invalidate()
            
            key = id(cell)
            try:
                curr_id = int(messageObject.getId())
                curr_did = int(messageObject.getDialogId())
                self._cell_cache[key] = (currentProgress, duration, durationLayout, curr_id, curr_did)
                
                if key in self._cache_order:
                    self._cache_order.remove(key)
                self._cache_order.append(key)
                if len(self._cache_order) > self._cache_capacity:
                    old_key = self._cache_order.pop(0)
                    self._cell_cache.pop(old_key, None)
                    self._last_update_ts.pop(old_key, None)
            except:
                pass
                
        except Exception as e:
            pass
    
    def is_voice_message(self, messageObject):
        if not self.plugin.get_setting("voice_message_time_display", True):
            return False
        return hasattr(messageObject, 'isVoice') and messageObject.isVoice()
    
    def is_round_video_message(self, messageObject):
        if not self.plugin.get_setting("round_video_time_display", True):
            return False
        return hasattr(messageObject, 'isRoundVideo') and messageObject.isRoundVideo()
    
    def get_voice_duration(self, messageObject):
        return messageObject.getDuration() if hasattr(messageObject, 'getDuration') else 0
    
    def is_playing(self, messageObject):
        try:
            from org.telegram.messenger import MediaController
            return MediaController.getInstance().isPlayingMessage(messageObject)
        except:
            return False
    
    def get_audio_progress_sec(self, messageObject):
        return messageObject.audioProgressSec if hasattr(messageObject, 'audioProgressSec') else 0


class GifSpoilerHook:
    def __init__(self, plugin: UiTweaksPlugin):
        self.plugin = plugin
        self.added_items = []
        self.current_viewer = None

    def after_hooked_method(self, param):
        try:
            viewer = get_private_field(param.thisObject, "this$0")
            if not viewer:
                return

            if self.current_viewer and self.current_viewer != viewer:
                self.cleanup_menu_items()
                self.plugin.log("GIF Menu: Cleaned up previous menu items due to viewer change")

            self.current_viewer = viewer

            popup_window = get_private_field(viewer, "popupWindow")
            preview_menu = None
            if popup_window:
                preview_menu = popup_window.getContentView()
            else:
                preview_menu = get_private_field(viewer, "popupLayout")
            document = get_private_field(viewer, "currentDocument")

            if preview_menu and document:
                self.plugin.log("GIF Menu: Adding spoiler and caption menu items")
                self.add_spoiler_menu(preview_menu, viewer, document)

        except Exception as e:
            self.plugin.log(f"GIF Menu Error: {e}")
            pass

    def add_spoiler_menu(self, preview_menu, viewer, document):
        try:
            if not MessageObject.isGifDocument(document):
                self.plugin.log("GIF Menu: Document is not a GIF, skipping menu addition")
                return

            resources_provider = get_private_field(viewer, "resourcesProvider")
            delegate = get_private_field(viewer, "delegate")

            if not delegate or not delegate.needSend(1):
                self.plugin.log("GIF Menu: Delegate cannot send, skipping menu addition")
                return

            try:
                from client_utils import get_last_fragment
                current_fragment = get_last_fragment()
                if current_fragment and hasattr(current_fragment, 'getTopicId'):
                    topic_id = current_fragment.getTopicId()
                    if topic_id > 0:
                        self.plugin.log("GIF Menu: In topic chat, skipping menu addition")
                        return 
            except:
                pass

            self.cleanup_menu_items()

            self.plugin.log("GIF Menu: Creating spoiler menu item")
            spoiler_item = ActionBarMenuItem.addItem(
                preview_menu,
                R_tg.drawable.msg_spoiler,
                get_text("hide_with_spoiler", "Hide with spoiler"),
                False,
                resources_provider)
            spoiler_item.setOnClickListener(OnClickListener(lambda *_: self.send_gif_with_spoiler(viewer, document, delegate)))
            self.added_items.append(spoiler_item)

            self.plugin.log("GIF Menu: Creating caption menu item")
            caption_item = ActionBarMenuItem.addItem(
                preview_menu,
                R_tg.drawable.menu_tag_edit_solar,
                get_text("send_with_caption", "Send with Caption"),
                False,
                resources_provider)
            caption_item.setOnClickListener(OnClickListener(lambda *_: self.show_caption_dialog(viewer, document, delegate)))
            self.added_items.append(caption_item)

            self.plugin.log(f"GIF Menu: Successfully added {len(self.added_items)} menu items")

        except Exception as e:
            self.plugin.log(f"GIF Menu: Error adding spoiler menu: {e}")
            pass

    def cleanup_menu_items(self):
        try:
            if not self.added_items:
                return
                
            self.plugin.log(f"GIF Menu: Cleaning up {len(self.added_items)} menu items")
            
            for item in self.added_items:
                try:
                    if item and hasattr(item, 'getParent'):
                        parent = item.getParent()
                        if parent:
                            parent.removeView(item)
                            self.plugin.log("GIF Menu: Removed menu item from parent")
                except Exception as e:
                    self.plugin.log(f"GIF Menu: Error removing menu item: {e}")
            
            self.added_items.clear()
            self.plugin.log("GIF Menu: Menu items cleanup completed")
            
        except Exception as e:
            self.plugin.log(f"GIF Menu: Error during cleanup: {e}")

    def send_gif_with_spoiler(self, viewer, document, delegate):
        try:
            parent = get_private_field(viewer, "parentObject")
            current_account = get_private_field(viewer, "currentAccount")

            send_messages_helper = SendMessagesHelper.getInstance(current_account)

            send_message_params = SendMessagesHelper.SendMessageParams.of(
                document,
                None,
                None,
                delegate.getDialogId(),
                None,
                None,
                None,
                None,
                None,
                None,
                True,
                0,
                0,
                parent,
                None,
                False,
                True
            )

            send_messages_helper.sendMessage(send_message_params)

            from org.telegram.messenger import MediaDataController
            from java.lang import System
            MediaDataController.getInstance(current_account).addRecentGif(document, int(System.currentTimeMillis() / 1000), True)

        except Exception as e:
            pass
        finally:
            self.dismiss_popup(viewer)

    def show_caption_dialog(self, viewer, document, delegate):
        try:
            from org.telegram.ui.Components import EditTextBoldCursor
            from android.text import InputType
            from android.util import TypedValue
            
            activity = get_last_fragment().getParentActivity()
            if not activity:
                return

            input_field = EditTextBoldCursor(activity)
            input_field.setHint(get_text("enter_caption", "Enter caption..."))
            input_field.setInputType(InputType.TYPE_CLASS_TEXT)
            input_field.setMaxLines(1)
            input_field.setSingleLine(True)
            input_field.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 16)
            input_field.setTextColor(Theme.getColor(Theme.key_dialogTextBlack))
            input_field.setHintTextColor(Theme.getColor(Theme.key_dialogTextHint))
            input_field.setBackground(None)
            input_field.setCursorColor(Theme.getColor(Theme.key_dialogTextLink))
            input_field.setCursorWidth(1.5)
            input_field.setPadding(AndroidUtilities.dp(12), AndroidUtilities.dp(12), AndroidUtilities.dp(12), AndroidUtilities.dp(12))

            builder = AlertDialogBuilder(activity)
            builder.set_title(get_text("add_caption_to_gif", "Add Caption to GIF"))
            builder.set_view(input_field)
            builder.set_positive_button(get_text("send", "Send"), lambda b, w: (self.send_gif_with_caption(viewer, document, delegate, input_field.getText().toString()), b.dismiss()))
            builder.set_negative_button(get_text("cancel", "Cancel"), lambda b, w: b.dismiss())
            builder.show()
        except:
            pass

    def send_gif_with_caption(self, viewer, document, delegate, caption):
        try:
            current_account = get_private_field(viewer, "currentAccount")
            SendMessagesHelper.getInstance(current_account).sendMessage(
                SendMessagesHelper.SendMessageParams.of(
                    document, None, None, delegate.getDialogId(), None, None, caption,
                    None, None, None, True, 0, 0, get_private_field(viewer, "parentObject"), None, False
                )
            )
            from org.telegram.messenger import MediaDataController
            from java.lang import System
            MediaDataController.getInstance(current_account).addRecentGif(document, int(System.currentTimeMillis() / 1000), True)
            self.dismiss_popup(viewer)
        except:
            pass

    def dismiss_popup(self, viewer):
        try:
            self.plugin.log("GIF Menu: Dismissing popup and cleaning up menu items")
            self.cleanup_menu_items()
            
            method = viewer.getClass().getDeclaredMethod("dismissPopupWindow")
            method.setAccessible(True)
            method.invoke(viewer)
            self.plugin.log("GIF Menu: Popup dismissed successfully")
        except Exception as e:
            self.plugin.log(f"GIF Menu: Error dismissing popup: {e}")
            pass


class GifDismissHook:
    def __init__(self, plugin: UiTweaksPlugin):
        self.plugin = plugin

    def before_hooked_method(self, param):
        try:
            if hasattr(self.plugin, 'hook_gif_spoiler_ref') and self.plugin.hook_gif_spoiler_ref:
                hook_instance = self.plugin.hook_gif_spoiler_ref
                if hasattr(hook_instance, 'cleanup_menu_items'):
                    self.plugin.log("GIF Menu: Auto-cleanup triggered by dismiss hook")
                    hook_instance.cleanup_menu_items()
        except Exception as e:
            self.plugin.log(f"GIF Menu: Error in dismiss hook cleanup: {e}")


class ProcessExternalUrlHook:
    def __init__(self, plugin: UiTweaksPlugin):
        self.plugin = plugin

    def before_hooked_method(self, param):
        try:
            url = param.args[1]
            if url and self.is_external(url):
                param.args[4] = True
        except Exception:
            pass

    def is_external(self, url):
        try:
            from android.net import Uri
            uri = Uri.parse(url)
            host = uri.getHost()
            if not host:
                return False
            host = host.lower()
            return not any(host == domain or host.endswith("." + domain) 
                          for domain in ["t.me", "telegram.me", "telegram.dog", "telegram.org", "telegram.com"])
        except Exception:
            return True


class UnreadBadgeHook:
    def __init__(self, plugin: UiTweaksPlugin):
        self.plugin = plugin
        
    def after_hooked_method(self, param):
        try:
            chat_activity = param.thisObject
            if chat_activity is None:
                return
                
            action_bar = chat_activity.getActionBar()
            if action_bar is None:
                return
                
            back_button = action_bar.backButtonImageView
            if back_button is None:
                return
                
            current_dialog_id = chat_activity.getDialogId()
            current_time = int(jclass("java.lang.System").currentTimeMillis() / 1000)
            
            if (self.plugin._cached_dialog_id == current_dialog_id and 
                current_time - self.plugin._last_unread_update < 2):
                if self.plugin.unread_count != self.plugin._unread_count_cache:
                    self.plugin.unread_count = self.plugin._unread_count_cache
                    back_button.invalidate()
                return
                
            messages_storage = chat_activity.getMessagesStorage()
            if messages_storage is None:
                return
                
            total_unread_count = messages_storage.getMainUnreadCount()
            current_chat_unread = 0
            
            try:
                messages_controller = chat_activity.getMessagesController()
                if messages_controller and current_dialog_id != 0:
                    dialog = messages_controller.getDialog(current_dialog_id)
                    if dialog:
                        current_chat_unread = dialog.unread_count
            except Exception:
                pass
            
            unread_count = max(0, total_unread_count - current_chat_unread)
            
            if self.plugin.current_back_button != back_button:
                self._hook_back_button(back_button, action_bar)
                self.plugin.current_back_button = back_button
            
            if self.plugin.unread_count != unread_count:
                self.plugin.unread_count = unread_count
                self.plugin._unread_count_cache = unread_count
                self.plugin._last_unread_update = current_time
                self.plugin._cached_dialog_id = current_dialog_id
                back_button.invalidate()
                
        except Exception as e:
            pass
            
    def _hook_back_button(self, back_button, action_bar):
        try:
            if self.plugin.hook_back_button_draw_ref:
                self.plugin.unhook_method(self.plugin.hook_back_button_draw_ref)
                self.plugin.hook_back_button_draw_ref = None
                
            back_button_class = back_button.getClass()
            on_draw_method = back_button_class.getDeclaredMethod("onDraw", jclass("android.graphics.Canvas"))
            on_draw_method.setAccessible(True)
            
            draw_hook = BackButtonDrawHook(self.plugin, action_bar)
            self.plugin.hook_back_button_draw_ref = self.plugin.hook_method(on_draw_method, draw_hook)
            
        except Exception as e:
            pass


class BackButtonDrawHook:
    def __init__(self, plugin: UiTweaksPlugin, action_bar):
        self.plugin = plugin
        self.action_bar = action_bar
        self.rect = jclass("android.graphics.RectF")()
        self._action_mode_cached = False
        self._last_action_mode_check = 0
        
    def after_hooked_method(self, param):
        try:
            current_view = param.thisObject
            if current_view != self.plugin.current_back_button:
                return
                
            canvas = param.args[0]
            if canvas is None or self.plugin.unread_count <= 0:
                return
                
            current_time = int(jclass("java.lang.System").currentTimeMillis() / 1000)
            if current_time - self._last_action_mode_check > 1:
                try:
                    parent_view = current_view.getParent()
                    while parent_view is not None:
                        if parent_view.getClass().getSimpleName() == "ActionBar":
                            self._action_mode_cached = parent_view.isActionModeShowed()
                            break
                        parent_view = parent_view.getParent()
                    self._last_action_mode_check = current_time
                except:
                    self._action_mode_cached = False
                    
            if self._action_mode_cached:
                return
                
            paint = jclass("org.telegram.ui.ActionBar.Theme").dialogs_countPaint
            text_paint = jclass("org.telegram.ui.ActionBar.Theme").dialogs_countTextPaint
            
            count_text = "99+" if self.plugin.unread_count > 99 else str(self.plugin.unread_count)
            
            text_width = int(text_paint.measureText(count_text))
            badge_width = max(jclass("org.telegram.messenger.AndroidUtilities").dp(20), text_width + jclass("org.telegram.messenger.AndroidUtilities").dp(12))
            badge_height = jclass("org.telegram.messenger.AndroidUtilities").dp(20)
            
            badge_left = current_view.getMeasuredWidth() - badge_width - jclass("org.telegram.messenger.AndroidUtilities").dp(8)
            badge_top = jclass("org.telegram.messenger.AndroidUtilities").dp(8)
            
            self.rect.set(badge_left, badge_top, badge_left + badge_width, badge_top + badge_height)
            canvas.drawRoundRect(self.rect, jclass("org.telegram.messenger.AndroidUtilities").dp(10), jclass("org.telegram.messenger.AndroidUtilities").dp(10), paint)
            
            text_x = badge_left + (badge_width - text_width) / 2
            text_y = badge_top + jclass("org.telegram.messenger.AndroidUtilities").dp(14)
            canvas.drawText(count_text, text_x, text_y, text_paint)
                
        except Exception as e:
            pass


class ForwardConfirmationHook:
    def __init__(self, plugin: UiTweaksPlugin, reflected_method):
        self.plugin = plugin
        self.reflected_method = reflected_method
        self._suppress_next = False

    def before_hooked_method(self, param):
        try:
            chat_activity = param.thisObject
            if chat_activity is None:
                return
            if self._suppress_next:
                self._suppress_next = False
                return
            if not self.plugin.get_setting("enable_confirmation_settings", True) or not self.plugin.get_setting("confirm_forward", True):
                return
            args = list(param.args) if param.args else []
            def on_confirm():
                try:
                    self._suppress_next = True
                    self.reflected_method.setAccessible(True)
                    coerced = list(args)
                    if len(coerced) >= 6:
                        try:
                            coerced[4] = jclass("java.lang.Integer")(int(coerced[4]))
                        except Exception:
                            pass
                        try:
                            coerced[5] = jclass("java.lang.Long")(int(coerced[5]))
                        except Exception:
                            pass
                    self.reflected_method.invoke(chat_activity, *coerced)
                except Exception:
                    pass
  
            ctx = None
            try:
                fragment = get_last_fragment()
                ctx = fragment.getParentActivity() if fragment and fragment.getParentActivity() else None
            except Exception:
                ctx = None
            if ctx:
                def _show():
                    try:
                        builder = AlertDialogBuilder(ctx)
                        builder.set_title(get_text("confirm_forward", "Confirm Forwarding Messages"))
                        builder.set_message(get_text("confirm_forward_message", "Are you sure you want to forward this message?"))
                        builder.set_positive_button(get_text("ok", "OK"), lambda dialog, which: on_confirm())
                        builder.set_negative_button(get_text("cancel", "Cancel"), None)
                        builder.show()
                    except Exception:
                        pass
                run_on_ui_thread(_show)
                param.setResult(None)
            else:
                pass
        except Exception:
            pass


class JoinConfirmationClickListener(dynamic_proxy(find_class("android.view.View$OnClickListener"))):
    def __init__(self, original_listener):
        super().__init__()
        self.original_listener = original_listener

    def onClick(self, view):
        plugin_instance = uitweaks_plugin_instance
        if (not plugin_instance or 
            not plugin_instance.get_setting("enable_confirmation_settings", True) or 
            not plugin_instance.get_setting("confirm_join_chat", False) or 
            not self._is_join_action()):
            self.original_listener.onClick(view)
            return
            
        def show_confirmation():
            try:
                builder = AlertDialogBuilder(view.getContext())
                
                chat_name = self._get_chat_name()
                
                builder.set_title(get_text("join_confirmation", "Join Confirmation"))
                message = get_text("join_confirmation_message", "Are you sure you want to join **{chat_name}**?").format(chat_name=chat_name)
                builder.set_message(AndroidUtilities.replaceTags(message))
                
                def on_confirm(dialog, which):
                    dialog.dismiss()
                    self.original_listener.onClick(view)
                
                def on_cancel(dialog, which):
                    dialog.dismiss()
                
                builder.set_positive_button(get_text("join", "Join"), on_confirm)
                builder.set_negative_button(get_text("cancel", "Cancel"), on_cancel)
                builder.show()
                
            except Exception as e:
                self.original_listener.onClick(view)

        run_on_ui_thread(show_confirmation)

    def _is_join_action(self):
        try:
            fragment = get_last_fragment()
            if not fragment:
                return False
            
            if hasattr(fragment, 'currentChat') and fragment.currentChat:
                try:
                    chat_activity_class = find_class("org.telegram.ui.ChatActivity")
                    overlay_field = chat_activity_class.getClass().getDeclaredField("bottomOverlayChatText")
                    overlay_field.setAccessible(True)
                    overlay_text_view = overlay_field.get(fragment)
                    
                    if overlay_text_view and hasattr(overlay_text_view, 'getText'):
                        try:
                            if hasattr(fragment, 'currentChat') and fragment.currentChat:
                                chat_object_class = find_class("org.telegram.messenger.ChatObject")
                                if chat_object_class:
                                    is_not_in_chat_method = chat_object_class.getClass().getDeclaredMethod("isNotInChat", find_class("org.telegram.tgnet.TLRPC$Chat"))
                                    is_not_in_chat = is_not_in_chat_method.invoke(None, fragment.currentChat)
                                    return is_not_in_chat
                        except Exception as e:
                            pass
                except Exception as e:
                    pass
                
                return False
            
            return False
        except Exception as e:
            return False

    def _get_chat_name(self):
        try:
            fragment = get_last_fragment()
            if fragment and hasattr(fragment, 'currentChat') and fragment.currentChat and hasattr(fragment.currentChat, 'title'):
                return fragment.currentChat.title
            return "this chat"
        except:
            return "this chat"


class FillActionModeMenuHook:
    def __init__(self, plugin):
        self.plugin = plugin
    
    def after_hooked_method(self, param):
        try:
            menu = param.args[0]
            
            if menu.findItem(CUSTOM_CODE_ID) is not None:
                return
            
            string_builder = SpannableStringBuilder(get_text("code_menu_item", "Code"))
            string_builder.setSpan(TypefaceSpan(Typeface.MONOSPACE), 0, string_builder.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE)
            menu.add(R_tg.id.menu_groupbolditalic, CUSTOM_CODE_ID, 7, string_builder)
            
            mention_string_builder = SpannableStringBuilder(get_text("mention_menu_item", "Mention"))
            menu.add(R_tg.id.menu_groupbolditalic, CUSTOM_MENTION_ID, 8, mention_string_builder)
            
        except Exception as e:
            traceback.print_exc()

class PerformMenuActionHook:
    def __init__(self, plugin):
        self.plugin = plugin
    
    def before_hooked_method(self, param):
        try:
            item_id = param.args[0]
            edit_text = param.thisObject
            
            if item_id == CUSTOM_CODE_ID:
                import time
                current_time = time.time()
                
                if not hasattr(self.plugin, '_last_code_click'):
                    self.plugin._last_code_click = 0
                
                if current_time - self.plugin._last_code_click > DEBOUNCE_TIME:
                    self.plugin._last_code_click = current_time
                    self.plugin._make_selected_code(edit_text)
                return
                
            elif item_id == CUSTOM_MENTION_ID:
                import time
                current_time = time.time()
                
                if not hasattr(self.plugin, '_last_mention_click'):
                    self.plugin._last_mention_click = 0
                
                if current_time - self.plugin._last_mention_click > DEBOUNCE_TIME:
                    self.plugin._last_mention_click = current_time
                    self.plugin._make_selected_mention(edit_text)
                return
                
        except Exception as e:
            traceback.print_exc()


class JoinConfirmationHook:
    def __init__(self, plugin):
        self.plugin = plugin

    def after_hooked_method(self, param: Any):
        try:
            chat_activity = param.thisObject
            if not chat_activity:
                return

            chat_activity_class = find_class("org.telegram.ui.ChatActivity")
            overlay_field = chat_activity_class.getClass().getDeclaredField("bottomOverlayChatText")
            overlay_field.setAccessible(True)
            overlay_text_view = overlay_field.get(chat_activity)
            
            if not overlay_text_view:
                return

            view_class = find_class("android.view.View")
            listener_info_method = view_class.getClass().getDeclaredMethod("getListenerInfo")
            listener_info_method.setAccessible(True)
            listener_info = listener_info_method.invoke(overlay_text_view)
            
            if not listener_info:
                return

            click_listener_field = listener_info.getClass().getDeclaredField("mOnClickListener")
            click_listener_field.setAccessible(True)
            original_listener = click_listener_field.get(listener_info)
            
            if original_listener and not isinstance(original_listener, JoinConfirmationClickListener):
                custom_listener = JoinConfirmationClickListener(original_listener)
                overlay_text_view.setOnClickListener(custom_listener)
                
        except Exception as e:
            pass



uitweaks_plugin_instance = None

def uitweaks_log(message: str):
    if uitweaks_plugin_instance and uitweaks_plugin_instance.get_setting("show_logs", False):
        log(f"[UiTweaks] {message}")


class MessagePreviewViewHook:
    def __init__(self, plugin):
        self.plugin = plugin

    def after_hooked_method(self, param):
        try:
            preview_view = param.thisObject
            if preview_view and preview_view not in self.plugin.added_send_media_buttons:
                run_on_ui_thread(lambda: self.plugin._add_send_media_button(preview_view), 100)
        except:
            pass


class DisableAutoWebLoginHook:
    def __init__(self, plugin):
        self.plugin = plugin
        uitweaks_log("DisableAutoWebLoginHook initialized")

    def before_hooked_method(self, param):
        try:
            from org.telegram.messenger import AccountInstance, UserConfig
            currentAccount = UserConfig.selectedAccount
            messagesController = AccountInstance.getInstance(currentAccount).getMessagesController()
            if hasattr(messagesController, 'autologinDomains'):
                uitweaks_log("Clearing autologinDomains to prevent token injection")
                messagesController.autologinDomains.clear()
        except Exception as e:
            uitweaks_log("Error clearing autologinDomains: " + str(e))


class DoNotSharePhoneNumberHook:
    def __init__(self, plugin):
        self.plugin = plugin
        self.fill_items_hook = None

    def setup(self):
        try:
            ContactAddActivity = find_class("org.telegram.ui.ContactAddActivity")
            if not ContactAddActivity:
                return
            activity_class = ContactAddActivity.getClass()
            array_list_class = jclass("java.util.ArrayList")
            universal_adapter = find_class("org.telegram.ui.Components.UniversalAdapter")
            method = activity_class.getDeclaredMethod("fillItems", array_list_class, universal_adapter)
            method.setAccessible(True)
            self.fill_items_hook = self.plugin.hook_method(method, _ContactAddActivityFillItemsHook(), priority=0)
        except Exception:
            pass

    def teardown(self):
        if self.fill_items_hook:
            self.plugin.unhook_method(self.fill_items_hook)
            self.fill_items_hook = None
        if hasattr(self, "do_not_share_hook") and self.do_not_share_hook:
            self.do_not_share_hook.teardown()
            self.do_not_share_hook = None

    def on_plugin_unload(self):
        self.teardown()


class _ContactAddActivityFillItemsHook:
    def before_hooked_method(self, param):
        activity = param.thisObject
        try:
            activity_class = activity.getClass()
            check_share_field = activity_class.getDeclaredField("checkShare")
            check_share_field.setAccessible(True)
            if check_share_field.getBoolean(activity):
                first_set_field = activity_class.getDeclaredField("firstSet")
                first_set_field.setAccessible(True)
                if first_set_field.getBoolean(activity):
                    check_share_field.setBoolean(activity, False)
        except Exception:
            pass


class PreferCommonGroupsTabHook:
    def __init__(self, plugin):
        self.plugin = plugin

    def after_hooked_method(self, param):
        try:
            userInfo = param.args[0]
            sharedMediaLayout = param.thisObject
            
            if userInfo and hasattr(userInfo, 'common_chats_count') and userInfo.common_chats_count > 0:
                try:
                    scrollSlidingTextTabStrip = getattr(sharedMediaLayout, 'scrollSlidingTextTabStrip', None)
                    if scrollSlidingTextTabStrip:
                        currentTabId = scrollSlidingTextTabStrip.getCurrentTabId()
                        if currentTabId == 14:
                            sharedMediaLayout.scrollToPage(6)
                except Exception as e:
                    pass
        except Exception as e:
            pass


class SafeModeHook:
    def __init__(self, plugin):
        self.plugin = plugin
    
    def before_hooked_method(self, param):
        try:
            from android.view import KeyEvent
            from java.lang import System
            
            key_event = param.args[0]
            if not key_event:
                return
            
            key_code = key_event.getKeyCode()
            action = key_event.getAction()
            
            if key_code == KeyEvent.KEYCODE_VOLUME_DOWN:
                current_time = System.currentTimeMillis()
                
                if action == KeyEvent.ACTION_DOWN:
                    self.plugin.safe_mode_volume_down_press_time = current_time
                    self.plugin.safe_mode_is_holding = False
                elif action == KeyEvent.ACTION_UP:
                    press_duration = current_time - self.plugin.safe_mode_volume_down_press_time
                    
                    if press_duration > 500:
                        self.plugin.safe_mode_is_holding = True
                        self.plugin.safe_mode_volume_down_count = 0
                        return
                    
                    if (current_time - self.plugin.safe_mode_last_volume_down_time) > self.plugin.safe_mode_cooldown:
                        self.plugin.safe_mode_volume_down_count = 1
                        self.plugin.safe_mode_last_volume_down_time = current_time
                    elif (current_time - self.plugin.safe_mode_last_volume_down_time) <= self.plugin.safe_mode_multi_tap_window:
                        self.plugin.safe_mode_volume_down_count += 1
                        self.plugin.safe_mode_last_volume_down_time = current_time
                        if self.plugin.safe_mode_volume_down_count >= self.plugin.safe_mode_required_taps:
                            self.plugin.safe_mode_volume_down_count = 0
                            self.plugin._on_safe_mode_detected()
                            param.setResult(True)
                            return
                        
                        param.setResult(True)
        except Exception:
            pass


class ChatActionBarItemsHook:
    def __init__(self, plugin):
        self.plugin = plugin
    
    def after_hooked_method(self, param):
        try:
            chat_activity = param.thisObject
            activity_id = id(chat_activity)
            
            if activity_id not in self.plugin.chat_action_bar_hooked_activities:
                self.plugin.chat_action_bar_hooked_activities.add(activity_id)
                
                if self.plugin.get_setting("enable_goto_message", False):
                    self.add_goto_message_menu_item(chat_activity)
                
                if self.plugin.get_setting("enable_ai_summarize", False):
                    self.add_summarize_menu_item(chat_activity)
        except Exception as e:
            self.plugin.log(f"Error in Chat Action Bar Items Hook: {e}")
    
    def add_summarize_menu_item(self, chat_activity):
        try:
            AiController = find_class("com.exteragram.messenger.ai.AiController")
            if not AiController:
                return

            if hasattr(AiController, 'canUseAI') and not AiController.canUseAI():
                return
            
            headerItem = get_private_field(chat_activity, "headerItem")
            if headerItem is None:
                return
            
            R = find_class("org.telegram.messenger.R")
            if R is None:
                return
            
            try:
                ai_icon = R.drawable.ai_chat
                summarize_text = get_text("summarize_menu_item", "Summarize")
                
                lazy_list = get_private_field(headerItem, "lazyList")
                lazy_map = get_private_field(headerItem, "lazyMap")
                
                if lazy_list is not None:
                    admin_gap = get_private_field(chat_activity, "adminItemsGap")
                    insert_position = lazy_list.size()
                    
                    if admin_gap is not None and lazy_map is not None:
                        for i in range(lazy_list.size()):
                            item = lazy_list.get(i)
                            if item == admin_gap:
                                insert_position = i
                                break
                    
                    ActionBarMenuItem = jclass("org.telegram.ui.ActionBar.ActionBarMenuItem")
                    ItemClass = jclass("org.telegram.ui.ActionBar.ActionBarMenuItem$Item")
                    item_java_class = ItemClass.getClass()
                    
                    asSubItemMethod = item_java_class.getDeclaredMethod("asSubItem", 
                        jclass("java.lang.Integer").TYPE,
                        jclass("java.lang.Integer").TYPE, 
                        jclass("android.graphics.drawable.Drawable"),
                        jclass("java.lang.CharSequence"),
                        jclass("java.lang.Boolean").TYPE,
                        jclass("java.lang.Boolean").TYPE
                    )
                    asSubItemMethod.setAccessible(True)
                    
                    Integer = jclass("java.lang.Integer")
                    Boolean = jclass("java.lang.Boolean")
                    
                    our_item = asSubItemMethod.invoke(None, 
                        Integer(self.plugin.ai_summarize_menu_id),
                        Integer(ai_icon),
                        None,
                        summarize_text,
                        Boolean(True),
                        Boolean(False)
                    )
                    
                    lazy_list.add(insert_position, our_item)
                    
                    if lazy_map is not None:
                        lazy_map.put(self.plugin.ai_summarize_menu_id, our_item)
                else:
                    headerItem.lazilyAddSubItem(
                        self.plugin.ai_summarize_menu_id,
                        ai_icon,
                        summarize_text
                    )
                
                self.hook_action_bar_callback(chat_activity)
                
            except Exception as e:
                self.plugin.log(f"Error adding AI Summarize menu item: {e}")
                
        except Exception as e:
            self.plugin.log(f"Error in add_summarize_menu_item: {e}")
    
    def add_goto_message_menu_item(self, chat_activity):
        try:
            headerItem = get_private_field(chat_activity, "headerItem")
            if headerItem is None:
                return
            
            R = find_class("org.telegram.messenger.R")
            if R is None:
                return
            
            try:
                goto_icon = R.drawable.msg_to_beginning_solar
                goto_text = get_text("goto_message", "Go to Message")
                
                lazy_list = get_private_field(headerItem, "lazyList")
                lazy_map = get_private_field(headerItem, "lazyMap")
                
                if lazy_list is not None:
                    admin_gap = get_private_field(chat_activity, "adminItemsGap")
                    insert_position = lazy_list.size()
                    
                    if admin_gap is not None and lazy_map is not None:
                        for i in range(lazy_list.size()):
                            item = lazy_list.get(i)
                            if item == admin_gap:
                                insert_position = i
                                break
                    
                    ActionBarMenuItem = jclass("org.telegram.ui.ActionBar.ActionBarMenuItem")
                    ItemClass = jclass("org.telegram.ui.ActionBar.ActionBarMenuItem$Item")
                    item_java_class = ItemClass.getClass()
                    
                    asSubItemMethod = item_java_class.getDeclaredMethod("asSubItem", 
                        jclass("java.lang.Integer").TYPE,
                        jclass("java.lang.Integer").TYPE, 
                        jclass("android.graphics.drawable.Drawable"),
                        jclass("java.lang.CharSequence"),
                        jclass("java.lang.Boolean").TYPE,
                        jclass("java.lang.Boolean").TYPE
                    )
                    asSubItemMethod.setAccessible(True)
                    
                    Integer = jclass("java.lang.Integer")
                    Boolean = jclass("java.lang.Boolean")
                    
                    our_item = asSubItemMethod.invoke(None, 
                        Integer(self.plugin.goto_message_menu_id),
                        Integer(goto_icon),
                        None,
                        goto_text,
                        Boolean(True),
                        Boolean(False)
                    )
                    
                    lazy_list.add(insert_position, our_item)
                    
                    if lazy_map is not None:
                        lazy_map.put(self.plugin.goto_message_menu_id, our_item)
                else:
                    headerItem.lazilyAddSubItem(
                        self.plugin.goto_message_menu_id,
                        goto_icon,
                        goto_text
                    )
                
                self.hook_action_bar_callback(chat_activity)
                
            except Exception as e:
                self.plugin.log(f"Error adding Goto Message menu item: {e}")
                
        except Exception as e:
            self.plugin.log(f"Error in add_goto_message_menu_item: {e}")
    
    def hook_action_bar_callback(self, chat_activity):
        try:
            action_bar = get_private_field(chat_activity, "actionBar")
            if action_bar is None:
                return
            
            current_callback = get_private_field(action_bar, "actionBarMenuOnItemClick")
            if current_callback is None:
                return
            
            callback_class = current_callback.getClass()
            jint = jclass("java.lang.Integer").TYPE
            
            onItemClickMethod = callback_class.getDeclaredMethod("onItemClick", jint)
            onItemClickMethod.setAccessible(True)
            
            hook_handler = ChatActionBarMenuItemClickHook(self.plugin, chat_activity)
            
            if self.plugin.hook_ai_summarize_item_click_ref:
                self.plugin.unhook_method(self.plugin.hook_ai_summarize_item_click_ref)
            
            self.plugin.hook_ai_summarize_item_click_ref = self.plugin.hook_method(
                onItemClickMethod,
                hook_handler
            )
            
        except Exception as e:
            self.plugin.log(f"Error hooking AI Summarize action bar callback: {e}")


class ChatActionBarMenuItemClickHook:
    def __init__(self, plugin, chat_activity):
        self.plugin = plugin
        self.chat_activity = chat_activity
    
    def get_unread_count(self, chat_activity):
        try:
            mc = get_messages_controller()
            dialog = mc.getDialog(chat_activity.getDialogId()) if mc else None
            if dialog:
                unread_count = getattr(dialog, 'unread_count', 0) or 0
                return unread_count if unread_count > 0 else 200
        except Exception:
            pass
        return 200
    
    def before_hooked_method(self, param):
        try:
            item_id = int(param.args[0])
            
            if item_id == self.plugin.ai_summarize_menu_id:
                self.open_summarize_view(self.chat_activity)
                param.setResult(None)
            elif item_id == self.plugin.goto_message_menu_id:
                self.plugin.show_goto_message_dialog(self.chat_activity)
                param.setResult(None)
                
        except Exception as e:
            self.plugin.log(f"Error in Chat Action Bar Menu Item Click Hook: {e}")
    
    def open_summarize_view(self, chat_activity):
        GenerateFromMessageBottomSheet = find_class("com.exteragram.messenger.ai.ui.GenerateFromMessageBottomSheet")
        if not GenerateFromMessageBottomSheet:
            return
        
        LocaleController = find_class("org.telegram.messenger.LocaleController")
        R = find_class("org.telegram.messenger.R")
        
        if LocaleController and R:
            getStringMethod = LocaleController.getClass().getDeclaredMethod("getString", jclass("java.lang.Integer").TYPE)
            
            class LocaleHook:
                def __init__(self):
                    self.role_prompt_id = R.string.RolePrompt
                    self.proceed_id = R.string.Proceed
                    self.generate_id = R.string.Generate
                
                def after_hooked_method(self, param):
                    string_id = param.args[0]
                    if string_id == self.role_prompt_id:
                        param.setResult(get_text("message_count_label", "Message Count"))
                    elif string_id == self.proceed_id:
                        param.setResult(get_text("summarize_button", "Summarize"))
                    elif string_id == self.generate_id:
                        param.setResult(get_text("summarize_title", "Summarize"))
            
            unhook_locale = self.plugin.hook_method(getStringMethod, LocaleHook())
        
        Callback = jclass("org.telegram.messenger.Utilities$Callback")
        
        class DataCallback(dynamic_proxy(Callback)):
            def __init__(self, plugin_ref, activity_ref):
                super().__init__()
                self.plugin = plugin_ref
                self.activity = activity_ref
            
            def run(self, data):
                default_count = ChatActionBarMenuItemClickHook(self.plugin, self.activity).get_unread_count(self.activity)
                count = int(str(data.prompt() or str(default_count)).strip())
                count = max(1, count)
                self.fetch_and_summarize(self.activity, count)
            
            def fetch_and_summarize(self, chat_activity, count):
                loading = AlertDialogBuilder(chat_activity.getParentActivity(), AlertDialogBuilder.ALERT_TYPE_SPINNER)
                loading.set_cancelable(False)
                loading.show()
                
                def process():
                    try:
                        messages = ChatActionBarMenuItemClickHook.get_messages(chat_activity, count, self.plugin)
                        run_on_ui_thread(loading.dismiss)
                        
                        if messages:
                            run_on_ui_thread(lambda: ChatActionBarMenuItemClickHook(self.plugin, chat_activity).show_alert(chat_activity, messages))
                        else:
                            run_on_ui_thread(lambda: BulletinHelper.of(chat_activity).createErrorBulletin("No messages to summarize").show())
                    except Exception as e:
                        self.plugin.log(f"Error fetching messages for summarization: {e}")
                        run_on_ui_thread(loading.dismiss)
                
                run_on_queue(process)
        
        callback = DataCallback(self.plugin, chat_activity)
        
        unread_count = self.get_unread_count(chat_activity)
        
        sheet = GenerateFromMessageBottomSheet(
            str(unread_count),
            None,
            chat_activity,
            chat_activity.getContext(),
            callback,
            False
        )
        sheet.show()
        
        if 'unhook_locale' in locals():
            self.plugin.unhook_method(unhook_locale)
    
    def show_alert(self, chat_activity, messages):
        try:
            AiConfig = find_class("com.exteragram.messenger.ai.AiConfig")
            if AiConfig:
                AiConfig.showResponseOnly = True
            
            context = self.build_message_context(messages)
            full_prompt = context
            
            AiController = find_class("com.exteragram.messenger.ai.AiController")
            controller = AiController.getInstance()
            
            summarizer_role = None
            roles_list = controller.getRoles()
            if roles_list:
                for i in range(roles_list.size()):
                    role = roles_list.get(i)
                    if role and role.getName() == "Quanta!":
                        summarizer_role = role
                        break
            
            client_builder = find_class("com.exteragram.messenger.ai.network.Client").Builder()
            if summarizer_role:
                client_builder.roleOverride(summarizer_role)
            client = client_builder.build()
            
            if not client:
                return
            
            current_chat = get_private_field(chat_activity, "currentChat")
            no_forwards = find_class("org.telegram.messenger.MessagesController").getInstance(0).isChatNoForwards(current_chat) if current_chat else False
            
            setText = jclass("android.widget.TextView").getClass().getDeclaredMethod("setText", jclass("java.lang.CharSequence"))
            
            class TextViewHook:
                def __init__(self, full_text, display_text):
                    self.full_text = full_text
                    self.display_text = display_text
                    self.hooked = False
                
                def before_hooked_method(self, param):
                    if not self.hooked:
                        text = str(param.args[0]) if param.args[0] else ""
                        if self.full_text in text:
                            param.args[0] = self.display_text
                            self.hooked = True
            
            unhook = self.plugin.hook_method(setText, TextViewHook(full_prompt, get_text("ai_summarizing", "Summarizing...")))
            
            Callback2 = jclass("org.telegram.messenger.Utilities$Callback2")
            class InsertCallback(dynamic_proxy(Callback2)):
                def run(self, prompt, response):
                    chatActivityEnterView = get_private_field(chat_activity, "chatActivityEnterView")
                    if chatActivityEnterView:
                        AiConfig = find_class("com.exteragram.messenger.ai.AiConfig")
                        if AiConfig and AiConfig.insertAsQuote:
                            editField = chatActivityEnterView.getEditField()
                            editField.setText(str(response) + "\n")
                            QuoteSpan = find_class("org.telegram.ui.Components.QuoteSpan")
                            if QuoteSpan:
                                QuoteSpan.putQuoteToEditable(chatActivityEnterView.getEditText(), 0, len(str(response)), True)
                        else:
                            chatActivityEnterView.getEditField().setText(str(response))
                        chatActivityEnterView.getEditField().setSelection(chatActivityEnterView.getEditText().length())
                        chatActivityEnterView.openKeyboard()
            
            find_class("com.exteragram.messenger.ai.ui.ResponseAlert").showAlert(
                chat_activity,
                client,
                full_prompt,
                True,
                no_forwards,
                None,
                None,
                InsertCallback()
            )
            
            if unhook:
                self.plugin.unhook_method(unhook)
            
        except Exception as e:
            self.plugin.log(f"Error opening AI Summarize view: {e}")
            import traceback
            self.plugin.log(f"Traceback: {traceback.format_exc()}")
    
    @staticmethod
    def get_messages(chat_activity, count, plugin):
        try:
            from client_utils import get_messages_controller, send_request, RequestCallback
            from org.telegram.tgnet import TLRPC
            import time
            
            dialog_id = get_private_field(chat_activity, "dialog_id")
            if dialog_id is None:
                return []
            
            result_container = {'messages': [], 'done': False, 'offset_id': 0}
            
            def fetch_batch():
                remaining = count - len(result_container['messages'])
                if remaining <= 0:
                    result_container['done'] = True
                    return
                
                batch_size = min(100, remaining)
                
                req = TLRPC.TL_messages_getHistory()
                req.peer = get_messages_controller().getInputPeer(dialog_id)
                req.offset_id = result_container['offset_id']
                req.limit = batch_size
                req.add_offset = 0
                req.max_id = 0
                req.min_id = 0
                req.hash = 0
                
                def handle_response(response, error):
                    if error or not response or not hasattr(response, 'messages'):
                        result_container['done'] = True
                        return
                    
                    messages_count = response.messages.size()
                    if messages_count == 0:
                        result_container['done'] = True
                        return
                    
                    last_id = result_container['offset_id']
                    for i in range(messages_count):
                        msg = response.messages.get(i)
                        if msg and hasattr(msg, 'message') and msg.message:
                            result_container['messages'].append(msg)
                            if hasattr(msg, 'id'):
                                last_id = msg.id
                    
                    result_container['offset_id'] = last_id
                    
                    if len(result_container['messages']) >= count or messages_count < batch_size:
                        result_container['done'] = True
                    else:
                        fetch_batch()
                
                callback = RequestCallback(handle_response)
                send_request(req, callback)
            
            fetch_batch()
            
            timeout = 30
            start_time = time.time()
            while not result_container['done'] and (time.time() - start_time) < timeout:
                time.sleep(0.1)
            
            messages = result_container['messages'][:count]
            messages.reverse()
            return messages
            
        except Exception as e:
            plugin.log(f"Error getting messages for summarization: {e}")
            return []
    
    def build_message_context(self, messages):
        try:
            from client_utils import get_messages_controller
            mc = get_messages_controller()
            parts = []
            
            for msg in messages:
                if not (hasattr(msg, 'message') and msg.message):
                    continue
                
                text = str(msg.message).strip()
                if not text:
                    continue
                
                sender = "User"
                is_channel_post = getattr(msg, 'post', False)
                
                if is_channel_post or (hasattr(msg, 'peer_id') and msg.peer_id and hasattr(msg.peer_id, 'channel_id') and (not hasattr(msg, 'from_id') or msg.from_id is None)):
                    if hasattr(msg, 'peer_id') and msg.peer_id and hasattr(msg.peer_id, 'channel_id'):
                        chat = mc.getChat(msg.peer_id.channel_id)
                        if chat and hasattr(chat, 'title'):
                            sender = str(chat.title)
                            if hasattr(msg, 'post_author') and msg.post_author:
                                sender = f"{sender} ({msg.post_author})"
                elif hasattr(msg, 'from_id') and msg.from_id:
                    fid = msg.from_id
                    if hasattr(fid, 'user_id'):
                        user = mc.getUser(fid.user_id)
                        if user:
                            name = f"{user.first_name or ''} {user.last_name or ''}".strip()
                            sender = name or "User"
                    elif hasattr(fid, 'channel_id'):
                        chat = mc.getChat(fid.channel_id)
                        if chat and hasattr(chat, 'title'):
                            sender = str(chat.title)
                
                parts.append(f"{sender}: {text}")
            
            return "\n".join(parts)
        except Exception as e:
            self.plugin.log(f"Error building AI Summarize context: {e}")
            return ""


RIGHT_DURATION = 20

def show_duration_selector_sheet(context, on_duration_selected):
    BottomSheet = find_class("org.telegram.ui.ActionBar.BottomSheet")
    LinearLayout = find_class("android.widget.LinearLayout")
    HeaderCell = find_class("org.telegram.ui.Cells.HeaderCell")
    Theme = find_class("org.telegram.ui.ActionBar.Theme")
    LayoutHelper = find_class("org.telegram.ui.Components.LayoutHelper")
    LocaleController = find_class("org.telegram.messenger.LocaleController")
    R_string = find_class("org.telegram.messenger.R$string")
    ConnectionsManager = find_class("org.telegram.tgnet.ConnectionsManager")
    AlertsCreator = find_class("org.telegram.ui.Components.AlertsCreator")
    UserConfig = find_class("org.telegram.messenger.UserConfig")
    AndroidUtilities = find_class("org.telegram.messenger.AndroidUtilities")
    
    builder = BottomSheet.Builder(context)
    builder.setApplyTopPadding(False)
    
    linear_layout = LinearLayout(context)
    linear_layout.setOrientation(LinearLayout.VERTICAL)
    
    header_cell = HeaderCell(context, Theme.key_dialogTextBlue2, 23, 15, False)
    header_cell.setHeight(47)
    header_cell.setText(LocaleController.getString("UserRestrictionsDuration", R_string.UserRestrictionsDuration))
    linear_layout.addView(header_cell)
    
    buttons_container = LinearLayout(context)
    buttons_container.setOrientation(LinearLayout.VERTICAL)
    linear_layout.addView(buttons_container, LayoutHelper.createLinear(-1, -2))
    durations = [
        (LocaleController.getString("UserRestrictionsUntilForever", R_string.UserRestrictionsUntilForever), 0),
        (LocaleController.formatPluralString("Days", 1), 86400),
        (LocaleController.formatPluralString("Weeks", 1), 604800),
        (LocaleController.formatPluralString("Months", 1), 2592000),
        (LocaleController.getString("UserRestrictionsCustom", R_string.UserRestrictionsCustom), -1)
    ]
    
    current_account = UserConfig.selectedAccount
    
    for idx, (label, duration_seconds) in enumerate(durations):
        cell = BottomSheet.BottomSheetCell(context, 0)
        cell.setPadding(AndroidUtilities.dp(7), 0, AndroidUtilities.dp(7), 0)
        cell.setTag(idx)
        cell.setBackgroundDrawable(Theme.getSelectorDrawable(False))
        cell.setTextAndIcon(label, 0)
        buttons_container.addView(cell, LayoutHelper.createLinear(-1, -2))
        
        def create_click_listener(duration, is_custom):
            def on_click(view=None):
                if is_custom:
                    current_time = ConnectionsManager.getInstance(current_account).getCurrentTime()
                    
                    ScheduleDatePickerDelegate = find_class("org.telegram.ui.Components.AlertsCreator$ScheduleDatePickerDelegate")
                    DateDelegateProxy = dynamic_proxy(ScheduleDatePickerDelegate)
                    
                    class DateDelegate(DateDelegateProxy):
                        def __init__(self):
                            super().__init__()
                        
                        def didSelectDate(self, notify, schedule_date):
                            on_duration_selected(schedule_date)
                    
                    date_builder = AlertsCreator.createDatePickerDialog(
                        context,
                        LocaleController.getString("UserRestrictionsDuration", R_string.UserRestrictionsDuration),
                        LocaleController.getString("Set", R_string.Set),
                        current_time,
                        DateDelegate()
                    )
                    if date_builder:
                        date_builder.show()
                else:
                    if duration == 0:
                        on_duration_selected(0)
                    else:
                        current_time = ConnectionsManager.getInstance(current_account).getCurrentTime()
                        on_duration_selected(current_time + duration)
                builder.getDismissRunnable().run()
            return on_click
        
        cell.setOnClickListener(OnClickListener(create_click_listener(duration_seconds, duration_seconds == -1)))
    
    builder.setCustomView(linear_layout)
    sheet = builder.create()
    sheet.show()

class DeleteWithDurationFillItemsHook:
    def __init__(self, plugin):
        self.plugin = plugin
    
    def after_hooked_method(self, param):
        try:
            sheet_instance = param.thisObject
            items = param.args[0]
            banOrRestrict = get_private_field(sheet_instance, 'banOrRestrict')
            restrict = get_private_field(sheet_instance, 'restrict')
            bannedRights = get_private_field(sheet_instance, 'bannedRights')
            
            if banOrRestrict and bannedRights:
                checks = get_private_field(banOrRestrict, 'checks')
                if checks and (checks[0] or restrict):
                    UItem = find_class("org.telegram.ui.Components.UItem")
                    LocaleController = find_class("org.telegram.messenger.LocaleController")
                    R_string = find_class("org.telegram.messenger.R$string")
                    
                    if bannedRights.until_date == 0 or abs(bannedRights.until_date - int(time.time())) > 10 * 365 * 24 * 60 * 60:
                        value = LocaleController.getString("UserRestrictionsUntilForever", R_string.UserRestrictionsUntilForever)
                    else:
                        value = LocaleController.formatDateForBan(bannedRights.until_date)
                    
                    duration_item = UItem.asButton(
                        RIGHT_DURATION,
                        LocaleController.getString("UserRestrictionsDuration", R_string.UserRestrictionsDuration),
                        value
                    )
                    items.add(duration_item)
                    
        except Exception as e:
            self.plugin.log(f"Error adding duration item: {e}")

class DeleteWithDurationOnClickHook:
    def __init__(self, plugin):
        self.plugin = plugin
    
    def before_hooked_method(self, param):
        try:
            sheet_instance = param.thisObject
            item = param.args[0]
            
            if item.id == RIGHT_DURATION:
                context = sheet_instance.getContext()
                
                bannedRights = get_private_field(sheet_instance, 'bannedRights')
                adapter = get_private_field(sheet_instance, 'adapter')
                
                def on_duration_selected(duration):
                    if bannedRights:
                        bannedRights.until_date = duration
                        if adapter:
                            adapter.update(True)
                
                show_duration_selector_sheet(context, on_duration_selected)
                param.setResult(None)
                return
                
        except Exception as e:
            self.plugin.log(f"Error handling duration click: {e}")


class SleepTimerHook:
    def __init__(self, plugin):
        self.plugin = plugin
    
    def after_hooked_method(self, param):
        try:
            alert = param.thisObject
            options_button = get_private_field(alert, "optionsButton")
            if not options_button:
                return
            
            options_button.addSubItem(1390, R_tg.drawable.menu_premium_clock, get_text("sleep_timer_menu", "Sleep Timer"))
            ActionBarMenuItem_ActionBarMenuItemDelegate = jclass("org.telegram.ui.ActionBar.ActionBarMenuItem$ActionBarMenuItemDelegate")
            DelegateProxy = dynamic_proxy(ActionBarMenuItem_ActionBarMenuItemDelegate)
            hook_instance = self
            
            class SleepTimerDelegate(DelegateProxy):
                def onItemClick(self, id):
                    if id == 1390:
                        hook_instance._show_sleep_timer_dialog(alert)
                    else:
                        if hasattr(alert, 'onSubItemClick'):
                            alert.onSubItemClick(id)
            
            options_button.setDelegate(SleepTimerDelegate())
        except:
            pass
    
    def _show_sleep_timer_dialog(self, alert):
        try:
            preset_labels = [
                get_text("sleep_timer_disable", "Disable"),
                LocaleController.formatPluralString("Minutes", 1),
                LocaleController.formatPluralString("Minutes", 5),
                LocaleController.formatPluralString("Minutes", 10),
                LocaleController.formatPluralString("Minutes", 20),
                LocaleController.formatPluralString("Minutes", 40),
                LocaleController.formatPluralString("Hours", 1),
                LocaleController.getString(R_tg.string.AutoDownloadCustom)
            ]
            
            preset_values = [0, 1, 5, 10, 20, 40, 60]
            hook_instance = self
            
            def on_preset_click(builder, which):
                if which < len(preset_values):
                    minutes = preset_values[which]
                    hook_instance._set_sleep_timer(alert, minutes * 60)
                else:
                    Callback = jclass("org.telegram.messenger.Utilities$Callback")
                    CallbackProxy = dynamic_proxy(Callback)
                    
                    class TimePickerCallback(CallbackProxy):
                        def run(self, picked_minutes):
                            hook_instance._set_sleep_timer(alert, picked_minutes * 60)
                    
                    from org.telegram.ui.Components import AlertsCreator
                    AlertsCreator.createTimePickerDialog(
                        alert.getContext(),
                        get_text("sleep_timer_custom", "Sleep Timer"),
                        0,
                        0,
                        12 * 60,
                        TimePickerCallback()
                    )
            
            resources_provider = get_private_field(alert, "resourcesProvider")
            builder = AlertDialogBuilder(alert.getContext(), resources_provider=resources_provider)
            builder.set_title(get_text("sleep_timer_title", "Sleep Timer"))
            builder.set_items(preset_labels, on_preset_click)
            builder.set_negative_button(LocaleController.getString(R_tg.string.Cancel))
            builder.show()
        except:
            pass
    
    def _set_sleep_timer(self, alert, seconds):
        try:
            self.plugin.log(f"Setting sleep timer to {seconds} seconds")
            if not hasattr(self.plugin, '_sleep_handler') or self.plugin._sleep_handler is None:
                self.plugin._sleep_handler = Handler(Looper.getMainLooper())
            if hasattr(self.plugin, '_sleep_runnable') and self.plugin._sleep_runnable is not None:
                self.plugin._sleep_handler.removeCallbacks(self.plugin._sleep_runnable)
            
            if seconds > 0:
                def pause_music():
                    from org.telegram.messenger import MediaController
                    media_controller = MediaController.getInstance()
                    if not media_controller.isMessagePaused():
                        media_controller.pauseMessage(media_controller.getPlayingMessageObject())
                    self.plugin.sleep_timer_active = False
                
                from android_utils import R as Runnable
                self.plugin._sleep_runnable = Runnable(pause_music)
                self.plugin._sleep_handler.postDelayed(self.plugin._sleep_runnable, seconds * 1000)
                
                self.plugin.sleep_timer_active = True
                if seconds < 3600:
                    minutes = seconds // 60
                    formatted_time = LocaleController.formatPluralString("Minutes", minutes)
                else:
                    hours = seconds // 3600
                    formatted_time = LocaleController.formatPluralString("Hours", hours)
                
                from org.telegram.ui.Components import BulletinFactory
                container_view = get_private_field(alert, "containerView")
                resources_provider = get_private_field(alert, "resourcesProvider")
                if container_view and isinstance(container_view, FrameLayout):
                    message = get_text("sleep_timer_set", "Sleep timer is set to {time}").format(time=formatted_time)
                    BulletinFactory.of(container_view, resources_provider).createSimpleBulletin(
                        R_tg.raw.done,
                        AndroidUtilities.replaceTags(message)
                    ).show()
            else:
                if self.plugin.sleep_timer_active:
                    from org.telegram.ui.Components import BulletinFactory
                    container_view = get_private_field(alert, "containerView")
                    resources_provider = get_private_field(alert, "resourcesProvider")
                    if container_view and isinstance(container_view, FrameLayout):
                        BulletinFactory.of(container_view, resources_provider).createSimpleBulletin(
                            R_tg.raw.done,
                            get_text("sleep_timer_disabled", "Sleep timer is disabled")
                        ).show()
                self.plugin.sleep_timer_active = False
        except Exception as e:
            self.plugin.log(f"Error in sleep timer: {e}")


class AdaptiveAudioHook:
    def __init__(self, plugin):
        self.plugin = plugin
    
    def after_hooked_method(self, param):
        try:
            cell = param.thisObject
            
            documentAttachTypeField = cell.getClass().getDeclaredField("documentAttachType")
            documentAttachTypeField.setAccessible(True)
            documentAttachType = documentAttachTypeField.getInt(cell)
            
            if documentAttachType != 3:
                return
            
            currentMessageObjectField = cell.getClass().getDeclaredField("currentMessageObject")
            currentMessageObjectField.setAccessible(True)
            messageObject = currentMessageObjectField.get(cell)
            
            if messageObject is None:
                return
            
            documentAttachField = cell.getClass().getDeclaredField("documentAttach")
            documentAttachField.setAccessible(True)
            documentAttach = documentAttachField.get(cell)
            
            if documentAttach is None:
                return
            
            duration = 0
            attributes = documentAttach.attributes
            for i in range(attributes.size()):
                attr = attributes.get(i)
                attr_class_name = attr.getClass().getName()
                if "TL_documentAttributeAudio" in attr_class_name:
                    duration = attr.duration
                    break
            
            if duration <= 0:
                return
            
            backgroundWidthField = cell.getClass().getDeclaredField("backgroundWidth")
            backgroundWidthField.setAccessible(True)
            currentBackgroundWidth = backgroundWidthField.getInt(cell)
            
            extra = 0
            if duration >= 180:
                extra = AndroidUtilities.dp(120)
            elif duration >= 120:
                extra = AndroidUtilities.dp(80)
            elif duration >= 60:
                extra = AndroidUtilities.dp(40)
            
            if extra > 0:
                from java.lang import Class
                AndroidUtilitiesClass = Class.forName("org.telegram.messenger.AndroidUtilities")
                displaySizeField = AndroidUtilitiesClass.getDeclaredField("displaySize")
                displaySizeField.setAccessible(True)
                displaySize = displaySizeField.get(None)
                
                screenLimit = displaySize.x - AndroidUtilities.dp(75)
                
                newBackgroundWidth = min(currentBackgroundWidth + extra, screenLimit)
                backgroundWidthField.setInt(cell, newBackgroundWidth)
        except:
            pass


class MusicSpeedControlHook:
    def __init__(self, plugin):
        self.plugin = plugin
        self._is_music_field = None
        self._playback_button_field = None
    
    def after_hooked_method(self, param):
        try:
            instance = param.thisObject
            if self._is_music_field is None or self._playback_button_field is None:
                c = instance.getClass()
                self._is_music_field = c.getDeclaredField("isMusic")
                self._is_music_field.setAccessible(True)
                self._playback_button_field = c.getDeclaredField("playbackSpeedButton")
                self._playback_button_field.setAccessible(True)
            is_music = self._is_music_field.getBoolean(instance)
            btn = self._playback_button_field.get(instance)
            if is_music and btn is not None:
                btn.setVisibility(0)
                btn.setAlpha(1.0)
                btn.setEnabled(True)
                try:
                    methods = instance.getClass().getDeclaredMethods()
                    target = None
                    for m in methods:
                        if m.getName() == "updatePlaybackButton" and len(m.getParameterTypes()) == 1:
                            target = m
                            break
                    if target is not None:
                        target.setAccessible(True)
                        target.invoke(instance, False)
                except Exception:
                    pass
        except Exception as e:
            pass


class SendCommentsAfterForwardHook:
    def __init__(self, plugin):
        self.plugin = plugin
    
    def before_hooked_method(self, param):
        return None


class AlwaysVisibleScheduleButtonHook:
    def __init__(self, plugin):
        self.plugin = plugin
    
    def replace_hooked_method(self, param):
        try:
            enter_view = param.thisObject
            animated = param.args[0]
            
            schedule_button_hidden = get_private_field(enter_view, "scheduleButtonHidden")
            recording_audio_video = get_private_field(enter_view, "recordingAudioVideo")
            visible = (not schedule_button_hidden) and (not recording_audio_video)
            scheduled_button = get_private_field(enter_view, "scheduledButton")
            
            if visible and not scheduled_button:
                try:
                    ChatActivityEnterViewClass = find_class("org.telegram.ui.Components.ChatActivityEnterView")
                    create_method = ChatActivityEnterViewClass.getClass().getDeclaredMethod("createScheduledButton")
                    create_method.setAccessible(True)
                    create_method.invoke(enter_view)
                    scheduled_button = get_private_field(enter_view, "scheduledButton")
                except Exception:
                    pass
            
            if scheduled_button and visible:
                scheduled_button.setVisibility(0)
                scheduled_button.setAlpha(1.0)
                scheduled_button.setScaleX(1.0)
                scheduled_button.setScaleY(1.0)
                scheduled_button.setTag(1)
        except Exception:
            pass
        
        return None

